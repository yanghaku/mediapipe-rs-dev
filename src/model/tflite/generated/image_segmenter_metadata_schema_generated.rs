// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mediapipe {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod tasks {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_ACTIVATION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_ACTIVATION: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_ACTIVATION: [Activation; 3] =
            [Activation::NONE, Activation::SIGMOID, Activation::SOFTMAX];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct Activation(pub i8);
        #[allow(non_upper_case_globals)]
        impl Activation {
            pub const NONE: Self = Self(0);
            pub const SIGMOID: Self = Self(1);
            pub const SOFTMAX: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SIGMOID, Self::SOFTMAX];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::SIGMOID => Some("SIGMOID"),
                    Self::SOFTMAX => Some("SOFTMAX"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for Activation {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for Activation {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for Activation {
            type Output = Activation;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for Activation {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for Activation {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Activation {}
        pub enum ImageSegmenterOptionsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ImageSegmenterOptions<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ImageSegmenterOptions<'a> {
            type Inner = ImageSegmenterOptions<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ImageSegmenterOptions<'a> {
            pub const VT_ACTIVATION: flatbuffers::VOffsetT = 4;
            pub const VT_MIN_PARSER_VERSION: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ImageSegmenterOptions { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ImageSegmenterOptionsArgs<'args>,
            ) -> flatbuffers::WIPOffset<ImageSegmenterOptions<'bldr>> {
                let mut builder = ImageSegmenterOptionsBuilder::new(_fbb);
                if let Some(x) = args.min_parser_version {
                    builder.add_min_parser_version(x);
                }
                builder.add_activation(args.activation);
                builder.finish()
            }

            #[inline]
            pub fn activation(&self) -> Activation {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Activation>(
                            ImageSegmenterOptions::VT_ACTIVATION,
                            Some(Activation::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn min_parser_version(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        ImageSegmenterOptions::VT_MIN_PARSER_VERSION,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for ImageSegmenterOptions<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Activation>("activation", Self::VT_ACTIVATION, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "min_parser_version",
                        Self::VT_MIN_PARSER_VERSION,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ImageSegmenterOptionsArgs<'a> {
            pub activation: Activation,
            pub min_parser_version: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ImageSegmenterOptionsArgs<'a> {
            #[inline]
            fn default() -> Self {
                ImageSegmenterOptionsArgs {
                    activation: Activation::NONE,
                    min_parser_version: None,
                }
            }
        }

        pub struct ImageSegmenterOptionsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ImageSegmenterOptionsBuilder<'a, 'b> {
            #[inline]
            pub fn add_activation(&mut self, activation: Activation) {
                self.fbb_.push_slot::<Activation>(
                    ImageSegmenterOptions::VT_ACTIVATION,
                    activation,
                    Activation::NONE,
                );
            }
            #[inline]
            pub fn add_min_parser_version(
                &mut self,
                min_parser_version: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ImageSegmenterOptions::VT_MIN_PARSER_VERSION,
                    min_parser_version,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ImageSegmenterOptionsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ImageSegmenterOptionsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ImageSegmenterOptions<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ImageSegmenterOptions<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ImageSegmenterOptions");
                ds.field("activation", &self.activation());
                ds.field("min_parser_version", &self.min_parser_version());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `ImageSegmenterOptions`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_image_segmenter_options_unchecked`.
        pub fn root_as_image_segmenter_options(
            buf: &[u8],
        ) -> Result<ImageSegmenterOptions, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<ImageSegmenterOptions>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `ImageSegmenterOptions` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_image_segmenter_options_unchecked`.
        pub fn size_prefixed_root_as_image_segmenter_options(
            buf: &[u8],
        ) -> Result<ImageSegmenterOptions, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<ImageSegmenterOptions>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `ImageSegmenterOptions` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_image_segmenter_options_unchecked`.
        pub fn root_as_image_segmenter_options_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<ImageSegmenterOptions<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<ImageSegmenterOptions<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `ImageSegmenterOptions` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_image_segmenter_options_unchecked`.
        pub fn size_prefixed_root_as_image_segmenter_options_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<ImageSegmenterOptions<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<ImageSegmenterOptions<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a ImageSegmenterOptions and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `ImageSegmenterOptions`.
        pub unsafe fn root_as_image_segmenter_options_unchecked(
            buf: &[u8],
        ) -> ImageSegmenterOptions {
            flatbuffers::root_unchecked::<ImageSegmenterOptions>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed ImageSegmenterOptions and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `ImageSegmenterOptions`.
        pub unsafe fn size_prefixed_root_as_image_segmenter_options_unchecked(
            buf: &[u8],
        ) -> ImageSegmenterOptions {
            flatbuffers::size_prefixed_root_unchecked::<ImageSegmenterOptions>(buf)
        }
        pub const IMAGE_SEGMENTER_OPTIONS_IDENTIFIER: &str = "V001";

        #[inline]
        pub fn image_segmenter_options_buffer_has_identifier(buf: &[u8]) -> bool {
            flatbuffers::buffer_has_identifier(buf, IMAGE_SEGMENTER_OPTIONS_IDENTIFIER, false)
        }

        #[inline]
        pub fn image_segmenter_options_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
            flatbuffers::buffer_has_identifier(buf, IMAGE_SEGMENTER_OPTIONS_IDENTIFIER, true)
        }

        #[inline]
        pub fn finish_image_segmenter_options_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<ImageSegmenterOptions<'a>>,
        ) {
            fbb.finish(root, Some(IMAGE_SEGMENTER_OPTIONS_IDENTIFIER));
        }

        #[inline]
        pub fn finish_size_prefixed_image_segmenter_options_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<ImageSegmenterOptions<'a>>,
        ) {
            fbb.finish_size_prefixed(root, Some(IMAGE_SEGMENTER_OPTIONS_IDENTIFIER));
        }
    } // pub mod tasks
} // pub mod mediapipe
