// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tflite {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TENSOR_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TENSOR_TYPE: i8 = 17;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TENSOR_TYPE: [TensorType; 18] = [
        TensorType::FLOAT32,
        TensorType::FLOAT16,
        TensorType::INT32,
        TensorType::UINT8,
        TensorType::INT64,
        TensorType::STRING,
        TensorType::BOOL,
        TensorType::INT16,
        TensorType::COMPLEX64,
        TensorType::INT8,
        TensorType::FLOAT64,
        TensorType::COMPLEX128,
        TensorType::UINT64,
        TensorType::RESOURCE,
        TensorType::VARIANT,
        TensorType::UINT32,
        TensorType::UINT16,
        TensorType::INT4,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TensorType(pub i8);
    #[allow(non_upper_case_globals)]
    impl TensorType {
        pub const FLOAT32: Self = Self(0);
        pub const FLOAT16: Self = Self(1);
        pub const INT32: Self = Self(2);
        pub const UINT8: Self = Self(3);
        pub const INT64: Self = Self(4);
        pub const STRING: Self = Self(5);
        pub const BOOL: Self = Self(6);
        pub const INT16: Self = Self(7);
        pub const COMPLEX64: Self = Self(8);
        pub const INT8: Self = Self(9);
        pub const FLOAT64: Self = Self(10);
        pub const COMPLEX128: Self = Self(11);
        pub const UINT64: Self = Self(12);
        pub const RESOURCE: Self = Self(13);
        pub const VARIANT: Self = Self(14);
        pub const UINT32: Self = Self(15);
        pub const UINT16: Self = Self(16);
        pub const INT4: Self = Self(17);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 17;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::FLOAT32,
            Self::FLOAT16,
            Self::INT32,
            Self::UINT8,
            Self::INT64,
            Self::STRING,
            Self::BOOL,
            Self::INT16,
            Self::COMPLEX64,
            Self::INT8,
            Self::FLOAT64,
            Self::COMPLEX128,
            Self::UINT64,
            Self::RESOURCE,
            Self::VARIANT,
            Self::UINT32,
            Self::UINT16,
            Self::INT4,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::FLOAT32 => Some("FLOAT32"),
                Self::FLOAT16 => Some("FLOAT16"),
                Self::INT32 => Some("INT32"),
                Self::UINT8 => Some("UINT8"),
                Self::INT64 => Some("INT64"),
                Self::STRING => Some("STRING"),
                Self::BOOL => Some("BOOL"),
                Self::INT16 => Some("INT16"),
                Self::COMPLEX64 => Some("COMPLEX64"),
                Self::INT8 => Some("INT8"),
                Self::FLOAT64 => Some("FLOAT64"),
                Self::COMPLEX128 => Some("COMPLEX128"),
                Self::UINT64 => Some("UINT64"),
                Self::RESOURCE => Some("RESOURCE"),
                Self::VARIANT => Some("VARIANT"),
                Self::UINT32 => Some("UINT32"),
                Self::UINT16 => Some("UINT16"),
                Self::INT4 => Some("INT4"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TensorType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TensorType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TensorType {
        type Output = TensorType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TensorType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TensorType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TensorType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_QUANTIZATION_DETAILS: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_QUANTIZATION_DETAILS: u8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_QUANTIZATION_DETAILS: [QuantizationDetails; 2] = [
        QuantizationDetails::NONE,
        QuantizationDetails::CustomQuantization,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct QuantizationDetails(pub u8);
    #[allow(non_upper_case_globals)]
    impl QuantizationDetails {
        pub const NONE: Self = Self(0);
        pub const CustomQuantization: Self = Self(1);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::CustomQuantization];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::CustomQuantization => Some("CustomQuantization"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for QuantizationDetails {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for QuantizationDetails {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for QuantizationDetails {
        type Output = QuantizationDetails;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for QuantizationDetails {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for QuantizationDetails {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for QuantizationDetails {}
    pub struct QuantizationDetailsUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_DIMENSION_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_DIMENSION_TYPE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_DIMENSION_TYPE: [DimensionType; 2] =
        [DimensionType::DENSE, DimensionType::SPARSE_CSR];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct DimensionType(pub i8);
    #[allow(non_upper_case_globals)]
    impl DimensionType {
        pub const DENSE: Self = Self(0);
        pub const SPARSE_CSR: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::DENSE, Self::SPARSE_CSR];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::DENSE => Some("DENSE"),
                Self::SPARSE_CSR => Some("SPARSE_CSR"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for DimensionType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for DimensionType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for DimensionType {
        type Output = DimensionType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for DimensionType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for DimensionType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for DimensionType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SPARSE_INDEX_VECTOR: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SPARSE_INDEX_VECTOR: u8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SPARSE_INDEX_VECTOR: [SparseIndexVector; 4] = [
        SparseIndexVector::NONE,
        SparseIndexVector::Int32Vector,
        SparseIndexVector::Uint16Vector,
        SparseIndexVector::Uint8Vector,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct SparseIndexVector(pub u8);
    #[allow(non_upper_case_globals)]
    impl SparseIndexVector {
        pub const NONE: Self = Self(0);
        pub const Int32Vector: Self = Self(1);
        pub const Uint16Vector: Self = Self(2);
        pub const Uint8Vector: Self = Self(3);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::Int32Vector,
            Self::Uint16Vector,
            Self::Uint8Vector,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Int32Vector => Some("Int32Vector"),
                Self::Uint16Vector => Some("Uint16Vector"),
                Self::Uint8Vector => Some("Uint8Vector"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for SparseIndexVector {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for SparseIndexVector {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for SparseIndexVector {
        type Output = SparseIndexVector;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for SparseIndexVector {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for SparseIndexVector {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for SparseIndexVector {}
    pub struct SparseIndexVectorUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_BUILTIN_OPERATOR: i32 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_BUILTIN_OPERATOR: i32 = 161;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_BUILTIN_OPERATOR: [BuiltinOperator; 162] = [
        BuiltinOperator::ADD,
        BuiltinOperator::AVERAGE_POOL_2D,
        BuiltinOperator::CONCATENATION,
        BuiltinOperator::CONV_2D,
        BuiltinOperator::DEPTHWISE_CONV_2D,
        BuiltinOperator::DEPTH_TO_SPACE,
        BuiltinOperator::DEQUANTIZE,
        BuiltinOperator::EMBEDDING_LOOKUP,
        BuiltinOperator::FLOOR,
        BuiltinOperator::FULLY_CONNECTED,
        BuiltinOperator::HASHTABLE_LOOKUP,
        BuiltinOperator::L2_NORMALIZATION,
        BuiltinOperator::L2_POOL_2D,
        BuiltinOperator::LOCAL_RESPONSE_NORMALIZATION,
        BuiltinOperator::LOGISTIC,
        BuiltinOperator::LSH_PROJECTION,
        BuiltinOperator::LSTM,
        BuiltinOperator::MAX_POOL_2D,
        BuiltinOperator::MUL,
        BuiltinOperator::RELU,
        BuiltinOperator::RELU_N1_TO_1,
        BuiltinOperator::RELU6,
        BuiltinOperator::RESHAPE,
        BuiltinOperator::RESIZE_BILINEAR,
        BuiltinOperator::RNN,
        BuiltinOperator::SOFTMAX,
        BuiltinOperator::SPACE_TO_DEPTH,
        BuiltinOperator::SVDF,
        BuiltinOperator::TANH,
        BuiltinOperator::CONCAT_EMBEDDINGS,
        BuiltinOperator::SKIP_GRAM,
        BuiltinOperator::CALL,
        BuiltinOperator::CUSTOM,
        BuiltinOperator::EMBEDDING_LOOKUP_SPARSE,
        BuiltinOperator::PAD,
        BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_RNN,
        BuiltinOperator::GATHER,
        BuiltinOperator::BATCH_TO_SPACE_ND,
        BuiltinOperator::SPACE_TO_BATCH_ND,
        BuiltinOperator::TRANSPOSE,
        BuiltinOperator::MEAN,
        BuiltinOperator::SUB,
        BuiltinOperator::DIV,
        BuiltinOperator::SQUEEZE,
        BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_LSTM,
        BuiltinOperator::STRIDED_SLICE,
        BuiltinOperator::BIDIRECTIONAL_SEQUENCE_RNN,
        BuiltinOperator::EXP,
        BuiltinOperator::TOPK_V2,
        BuiltinOperator::SPLIT,
        BuiltinOperator::LOG_SOFTMAX,
        BuiltinOperator::DELEGATE,
        BuiltinOperator::BIDIRECTIONAL_SEQUENCE_LSTM,
        BuiltinOperator::CAST,
        BuiltinOperator::PRELU,
        BuiltinOperator::MAXIMUM,
        BuiltinOperator::ARG_MAX,
        BuiltinOperator::MINIMUM,
        BuiltinOperator::LESS,
        BuiltinOperator::NEG,
        BuiltinOperator::PADV2,
        BuiltinOperator::GREATER,
        BuiltinOperator::GREATER_EQUAL,
        BuiltinOperator::LESS_EQUAL,
        BuiltinOperator::SELECT,
        BuiltinOperator::SLICE,
        BuiltinOperator::SIN,
        BuiltinOperator::TRANSPOSE_CONV,
        BuiltinOperator::SPARSE_TO_DENSE,
        BuiltinOperator::TILE,
        BuiltinOperator::EXPAND_DIMS,
        BuiltinOperator::EQUAL,
        BuiltinOperator::NOT_EQUAL,
        BuiltinOperator::LOG,
        BuiltinOperator::SUM,
        BuiltinOperator::SQRT,
        BuiltinOperator::RSQRT,
        BuiltinOperator::SHAPE,
        BuiltinOperator::POW,
        BuiltinOperator::ARG_MIN,
        BuiltinOperator::FAKE_QUANT,
        BuiltinOperator::REDUCE_PROD,
        BuiltinOperator::REDUCE_MAX,
        BuiltinOperator::PACK,
        BuiltinOperator::LOGICAL_OR,
        BuiltinOperator::ONE_HOT,
        BuiltinOperator::LOGICAL_AND,
        BuiltinOperator::LOGICAL_NOT,
        BuiltinOperator::UNPACK,
        BuiltinOperator::REDUCE_MIN,
        BuiltinOperator::FLOOR_DIV,
        BuiltinOperator::REDUCE_ANY,
        BuiltinOperator::SQUARE,
        BuiltinOperator::ZEROS_LIKE,
        BuiltinOperator::FILL,
        BuiltinOperator::FLOOR_MOD,
        BuiltinOperator::RANGE,
        BuiltinOperator::RESIZE_NEAREST_NEIGHBOR,
        BuiltinOperator::LEAKY_RELU,
        BuiltinOperator::SQUARED_DIFFERENCE,
        BuiltinOperator::MIRROR_PAD,
        BuiltinOperator::ABS,
        BuiltinOperator::SPLIT_V,
        BuiltinOperator::UNIQUE,
        BuiltinOperator::CEIL,
        BuiltinOperator::REVERSE_V2,
        BuiltinOperator::ADD_N,
        BuiltinOperator::GATHER_ND,
        BuiltinOperator::COS,
        BuiltinOperator::WHERE,
        BuiltinOperator::RANK,
        BuiltinOperator::ELU,
        BuiltinOperator::REVERSE_SEQUENCE,
        BuiltinOperator::MATRIX_DIAG,
        BuiltinOperator::QUANTIZE,
        BuiltinOperator::MATRIX_SET_DIAG,
        BuiltinOperator::ROUND,
        BuiltinOperator::HARD_SWISH,
        BuiltinOperator::IF,
        BuiltinOperator::WHILE,
        BuiltinOperator::NON_MAX_SUPPRESSION_V4,
        BuiltinOperator::NON_MAX_SUPPRESSION_V5,
        BuiltinOperator::SCATTER_ND,
        BuiltinOperator::SELECT_V2,
        BuiltinOperator::DENSIFY,
        BuiltinOperator::SEGMENT_SUM,
        BuiltinOperator::BATCH_MATMUL,
        BuiltinOperator::PLACEHOLDER_FOR_GREATER_OP_CODES,
        BuiltinOperator::CUMSUM,
        BuiltinOperator::CALL_ONCE,
        BuiltinOperator::BROADCAST_TO,
        BuiltinOperator::RFFT2D,
        BuiltinOperator::CONV_3D,
        BuiltinOperator::IMAG,
        BuiltinOperator::REAL,
        BuiltinOperator::COMPLEX_ABS,
        BuiltinOperator::HASHTABLE,
        BuiltinOperator::HASHTABLE_FIND,
        BuiltinOperator::HASHTABLE_IMPORT,
        BuiltinOperator::HASHTABLE_SIZE,
        BuiltinOperator::REDUCE_ALL,
        BuiltinOperator::CONV_3D_TRANSPOSE,
        BuiltinOperator::VAR_HANDLE,
        BuiltinOperator::READ_VARIABLE,
        BuiltinOperator::ASSIGN_VARIABLE,
        BuiltinOperator::BROADCAST_ARGS,
        BuiltinOperator::RANDOM_STANDARD_NORMAL,
        BuiltinOperator::BUCKETIZE,
        BuiltinOperator::RANDOM_UNIFORM,
        BuiltinOperator::MULTINOMIAL,
        BuiltinOperator::GELU,
        BuiltinOperator::DYNAMIC_UPDATE_SLICE,
        BuiltinOperator::RELU_0_TO_1,
        BuiltinOperator::UNSORTED_SEGMENT_PROD,
        BuiltinOperator::UNSORTED_SEGMENT_MAX,
        BuiltinOperator::UNSORTED_SEGMENT_SUM,
        BuiltinOperator::ATAN2,
        BuiltinOperator::UNSORTED_SEGMENT_MIN,
        BuiltinOperator::SIGN,
        BuiltinOperator::BITCAST,
        BuiltinOperator::BITWISE_XOR,
        BuiltinOperator::RIGHT_SHIFT,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct BuiltinOperator(pub i32);
    #[allow(non_upper_case_globals)]
    impl BuiltinOperator {
        pub const ADD: Self = Self(0);
        pub const AVERAGE_POOL_2D: Self = Self(1);
        pub const CONCATENATION: Self = Self(2);
        pub const CONV_2D: Self = Self(3);
        pub const DEPTHWISE_CONV_2D: Self = Self(4);
        pub const DEPTH_TO_SPACE: Self = Self(5);
        pub const DEQUANTIZE: Self = Self(6);
        pub const EMBEDDING_LOOKUP: Self = Self(7);
        pub const FLOOR: Self = Self(8);
        pub const FULLY_CONNECTED: Self = Self(9);
        pub const HASHTABLE_LOOKUP: Self = Self(10);
        pub const L2_NORMALIZATION: Self = Self(11);
        pub const L2_POOL_2D: Self = Self(12);
        pub const LOCAL_RESPONSE_NORMALIZATION: Self = Self(13);
        pub const LOGISTIC: Self = Self(14);
        pub const LSH_PROJECTION: Self = Self(15);
        pub const LSTM: Self = Self(16);
        pub const MAX_POOL_2D: Self = Self(17);
        pub const MUL: Self = Self(18);
        pub const RELU: Self = Self(19);
        pub const RELU_N1_TO_1: Self = Self(20);
        pub const RELU6: Self = Self(21);
        pub const RESHAPE: Self = Self(22);
        pub const RESIZE_BILINEAR: Self = Self(23);
        pub const RNN: Self = Self(24);
        pub const SOFTMAX: Self = Self(25);
        pub const SPACE_TO_DEPTH: Self = Self(26);
        pub const SVDF: Self = Self(27);
        pub const TANH: Self = Self(28);
        pub const CONCAT_EMBEDDINGS: Self = Self(29);
        pub const SKIP_GRAM: Self = Self(30);
        pub const CALL: Self = Self(31);
        pub const CUSTOM: Self = Self(32);
        pub const EMBEDDING_LOOKUP_SPARSE: Self = Self(33);
        pub const PAD: Self = Self(34);
        pub const UNIDIRECTIONAL_SEQUENCE_RNN: Self = Self(35);
        pub const GATHER: Self = Self(36);
        pub const BATCH_TO_SPACE_ND: Self = Self(37);
        pub const SPACE_TO_BATCH_ND: Self = Self(38);
        pub const TRANSPOSE: Self = Self(39);
        pub const MEAN: Self = Self(40);
        pub const SUB: Self = Self(41);
        pub const DIV: Self = Self(42);
        pub const SQUEEZE: Self = Self(43);
        pub const UNIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(44);
        pub const STRIDED_SLICE: Self = Self(45);
        pub const BIDIRECTIONAL_SEQUENCE_RNN: Self = Self(46);
        pub const EXP: Self = Self(47);
        pub const TOPK_V2: Self = Self(48);
        pub const SPLIT: Self = Self(49);
        pub const LOG_SOFTMAX: Self = Self(50);
        pub const DELEGATE: Self = Self(51);
        pub const BIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(52);
        pub const CAST: Self = Self(53);
        pub const PRELU: Self = Self(54);
        pub const MAXIMUM: Self = Self(55);
        pub const ARG_MAX: Self = Self(56);
        pub const MINIMUM: Self = Self(57);
        pub const LESS: Self = Self(58);
        pub const NEG: Self = Self(59);
        pub const PADV2: Self = Self(60);
        pub const GREATER: Self = Self(61);
        pub const GREATER_EQUAL: Self = Self(62);
        pub const LESS_EQUAL: Self = Self(63);
        pub const SELECT: Self = Self(64);
        pub const SLICE: Self = Self(65);
        pub const SIN: Self = Self(66);
        pub const TRANSPOSE_CONV: Self = Self(67);
        pub const SPARSE_TO_DENSE: Self = Self(68);
        pub const TILE: Self = Self(69);
        pub const EXPAND_DIMS: Self = Self(70);
        pub const EQUAL: Self = Self(71);
        pub const NOT_EQUAL: Self = Self(72);
        pub const LOG: Self = Self(73);
        pub const SUM: Self = Self(74);
        pub const SQRT: Self = Self(75);
        pub const RSQRT: Self = Self(76);
        pub const SHAPE: Self = Self(77);
        pub const POW: Self = Self(78);
        pub const ARG_MIN: Self = Self(79);
        pub const FAKE_QUANT: Self = Self(80);
        pub const REDUCE_PROD: Self = Self(81);
        pub const REDUCE_MAX: Self = Self(82);
        pub const PACK: Self = Self(83);
        pub const LOGICAL_OR: Self = Self(84);
        pub const ONE_HOT: Self = Self(85);
        pub const LOGICAL_AND: Self = Self(86);
        pub const LOGICAL_NOT: Self = Self(87);
        pub const UNPACK: Self = Self(88);
        pub const REDUCE_MIN: Self = Self(89);
        pub const FLOOR_DIV: Self = Self(90);
        pub const REDUCE_ANY: Self = Self(91);
        pub const SQUARE: Self = Self(92);
        pub const ZEROS_LIKE: Self = Self(93);
        pub const FILL: Self = Self(94);
        pub const FLOOR_MOD: Self = Self(95);
        pub const RANGE: Self = Self(96);
        pub const RESIZE_NEAREST_NEIGHBOR: Self = Self(97);
        pub const LEAKY_RELU: Self = Self(98);
        pub const SQUARED_DIFFERENCE: Self = Self(99);
        pub const MIRROR_PAD: Self = Self(100);
        pub const ABS: Self = Self(101);
        pub const SPLIT_V: Self = Self(102);
        pub const UNIQUE: Self = Self(103);
        pub const CEIL: Self = Self(104);
        pub const REVERSE_V2: Self = Self(105);
        pub const ADD_N: Self = Self(106);
        pub const GATHER_ND: Self = Self(107);
        pub const COS: Self = Self(108);
        pub const WHERE: Self = Self(109);
        pub const RANK: Self = Self(110);
        pub const ELU: Self = Self(111);
        pub const REVERSE_SEQUENCE: Self = Self(112);
        pub const MATRIX_DIAG: Self = Self(113);
        pub const QUANTIZE: Self = Self(114);
        pub const MATRIX_SET_DIAG: Self = Self(115);
        pub const ROUND: Self = Self(116);
        pub const HARD_SWISH: Self = Self(117);
        pub const IF: Self = Self(118);
        pub const WHILE: Self = Self(119);
        pub const NON_MAX_SUPPRESSION_V4: Self = Self(120);
        pub const NON_MAX_SUPPRESSION_V5: Self = Self(121);
        pub const SCATTER_ND: Self = Self(122);
        pub const SELECT_V2: Self = Self(123);
        pub const DENSIFY: Self = Self(124);
        pub const SEGMENT_SUM: Self = Self(125);
        pub const BATCH_MATMUL: Self = Self(126);
        pub const PLACEHOLDER_FOR_GREATER_OP_CODES: Self = Self(127);
        pub const CUMSUM: Self = Self(128);
        pub const CALL_ONCE: Self = Self(129);
        pub const BROADCAST_TO: Self = Self(130);
        pub const RFFT2D: Self = Self(131);
        pub const CONV_3D: Self = Self(132);
        pub const IMAG: Self = Self(133);
        pub const REAL: Self = Self(134);
        pub const COMPLEX_ABS: Self = Self(135);
        pub const HASHTABLE: Self = Self(136);
        pub const HASHTABLE_FIND: Self = Self(137);
        pub const HASHTABLE_IMPORT: Self = Self(138);
        pub const HASHTABLE_SIZE: Self = Self(139);
        pub const REDUCE_ALL: Self = Self(140);
        pub const CONV_3D_TRANSPOSE: Self = Self(141);
        pub const VAR_HANDLE: Self = Self(142);
        pub const READ_VARIABLE: Self = Self(143);
        pub const ASSIGN_VARIABLE: Self = Self(144);
        pub const BROADCAST_ARGS: Self = Self(145);
        pub const RANDOM_STANDARD_NORMAL: Self = Self(146);
        pub const BUCKETIZE: Self = Self(147);
        pub const RANDOM_UNIFORM: Self = Self(148);
        pub const MULTINOMIAL: Self = Self(149);
        pub const GELU: Self = Self(150);
        pub const DYNAMIC_UPDATE_SLICE: Self = Self(151);
        pub const RELU_0_TO_1: Self = Self(152);
        pub const UNSORTED_SEGMENT_PROD: Self = Self(153);
        pub const UNSORTED_SEGMENT_MAX: Self = Self(154);
        pub const UNSORTED_SEGMENT_SUM: Self = Self(155);
        pub const ATAN2: Self = Self(156);
        pub const UNSORTED_SEGMENT_MIN: Self = Self(157);
        pub const SIGN: Self = Self(158);
        pub const BITCAST: Self = Self(159);
        pub const BITWISE_XOR: Self = Self(160);
        pub const RIGHT_SHIFT: Self = Self(161);

        pub const ENUM_MIN: i32 = 0;
        pub const ENUM_MAX: i32 = 161;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::ADD,
            Self::AVERAGE_POOL_2D,
            Self::CONCATENATION,
            Self::CONV_2D,
            Self::DEPTHWISE_CONV_2D,
            Self::DEPTH_TO_SPACE,
            Self::DEQUANTIZE,
            Self::EMBEDDING_LOOKUP,
            Self::FLOOR,
            Self::FULLY_CONNECTED,
            Self::HASHTABLE_LOOKUP,
            Self::L2_NORMALIZATION,
            Self::L2_POOL_2D,
            Self::LOCAL_RESPONSE_NORMALIZATION,
            Self::LOGISTIC,
            Self::LSH_PROJECTION,
            Self::LSTM,
            Self::MAX_POOL_2D,
            Self::MUL,
            Self::RELU,
            Self::RELU_N1_TO_1,
            Self::RELU6,
            Self::RESHAPE,
            Self::RESIZE_BILINEAR,
            Self::RNN,
            Self::SOFTMAX,
            Self::SPACE_TO_DEPTH,
            Self::SVDF,
            Self::TANH,
            Self::CONCAT_EMBEDDINGS,
            Self::SKIP_GRAM,
            Self::CALL,
            Self::CUSTOM,
            Self::EMBEDDING_LOOKUP_SPARSE,
            Self::PAD,
            Self::UNIDIRECTIONAL_SEQUENCE_RNN,
            Self::GATHER,
            Self::BATCH_TO_SPACE_ND,
            Self::SPACE_TO_BATCH_ND,
            Self::TRANSPOSE,
            Self::MEAN,
            Self::SUB,
            Self::DIV,
            Self::SQUEEZE,
            Self::UNIDIRECTIONAL_SEQUENCE_LSTM,
            Self::STRIDED_SLICE,
            Self::BIDIRECTIONAL_SEQUENCE_RNN,
            Self::EXP,
            Self::TOPK_V2,
            Self::SPLIT,
            Self::LOG_SOFTMAX,
            Self::DELEGATE,
            Self::BIDIRECTIONAL_SEQUENCE_LSTM,
            Self::CAST,
            Self::PRELU,
            Self::MAXIMUM,
            Self::ARG_MAX,
            Self::MINIMUM,
            Self::LESS,
            Self::NEG,
            Self::PADV2,
            Self::GREATER,
            Self::GREATER_EQUAL,
            Self::LESS_EQUAL,
            Self::SELECT,
            Self::SLICE,
            Self::SIN,
            Self::TRANSPOSE_CONV,
            Self::SPARSE_TO_DENSE,
            Self::TILE,
            Self::EXPAND_DIMS,
            Self::EQUAL,
            Self::NOT_EQUAL,
            Self::LOG,
            Self::SUM,
            Self::SQRT,
            Self::RSQRT,
            Self::SHAPE,
            Self::POW,
            Self::ARG_MIN,
            Self::FAKE_QUANT,
            Self::REDUCE_PROD,
            Self::REDUCE_MAX,
            Self::PACK,
            Self::LOGICAL_OR,
            Self::ONE_HOT,
            Self::LOGICAL_AND,
            Self::LOGICAL_NOT,
            Self::UNPACK,
            Self::REDUCE_MIN,
            Self::FLOOR_DIV,
            Self::REDUCE_ANY,
            Self::SQUARE,
            Self::ZEROS_LIKE,
            Self::FILL,
            Self::FLOOR_MOD,
            Self::RANGE,
            Self::RESIZE_NEAREST_NEIGHBOR,
            Self::LEAKY_RELU,
            Self::SQUARED_DIFFERENCE,
            Self::MIRROR_PAD,
            Self::ABS,
            Self::SPLIT_V,
            Self::UNIQUE,
            Self::CEIL,
            Self::REVERSE_V2,
            Self::ADD_N,
            Self::GATHER_ND,
            Self::COS,
            Self::WHERE,
            Self::RANK,
            Self::ELU,
            Self::REVERSE_SEQUENCE,
            Self::MATRIX_DIAG,
            Self::QUANTIZE,
            Self::MATRIX_SET_DIAG,
            Self::ROUND,
            Self::HARD_SWISH,
            Self::IF,
            Self::WHILE,
            Self::NON_MAX_SUPPRESSION_V4,
            Self::NON_MAX_SUPPRESSION_V5,
            Self::SCATTER_ND,
            Self::SELECT_V2,
            Self::DENSIFY,
            Self::SEGMENT_SUM,
            Self::BATCH_MATMUL,
            Self::PLACEHOLDER_FOR_GREATER_OP_CODES,
            Self::CUMSUM,
            Self::CALL_ONCE,
            Self::BROADCAST_TO,
            Self::RFFT2D,
            Self::CONV_3D,
            Self::IMAG,
            Self::REAL,
            Self::COMPLEX_ABS,
            Self::HASHTABLE,
            Self::HASHTABLE_FIND,
            Self::HASHTABLE_IMPORT,
            Self::HASHTABLE_SIZE,
            Self::REDUCE_ALL,
            Self::CONV_3D_TRANSPOSE,
            Self::VAR_HANDLE,
            Self::READ_VARIABLE,
            Self::ASSIGN_VARIABLE,
            Self::BROADCAST_ARGS,
            Self::RANDOM_STANDARD_NORMAL,
            Self::BUCKETIZE,
            Self::RANDOM_UNIFORM,
            Self::MULTINOMIAL,
            Self::GELU,
            Self::DYNAMIC_UPDATE_SLICE,
            Self::RELU_0_TO_1,
            Self::UNSORTED_SEGMENT_PROD,
            Self::UNSORTED_SEGMENT_MAX,
            Self::UNSORTED_SEGMENT_SUM,
            Self::ATAN2,
            Self::UNSORTED_SEGMENT_MIN,
            Self::SIGN,
            Self::BITCAST,
            Self::BITWISE_XOR,
            Self::RIGHT_SHIFT,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::ADD => Some("ADD"),
                Self::AVERAGE_POOL_2D => Some("AVERAGE_POOL_2D"),
                Self::CONCATENATION => Some("CONCATENATION"),
                Self::CONV_2D => Some("CONV_2D"),
                Self::DEPTHWISE_CONV_2D => Some("DEPTHWISE_CONV_2D"),
                Self::DEPTH_TO_SPACE => Some("DEPTH_TO_SPACE"),
                Self::DEQUANTIZE => Some("DEQUANTIZE"),
                Self::EMBEDDING_LOOKUP => Some("EMBEDDING_LOOKUP"),
                Self::FLOOR => Some("FLOOR"),
                Self::FULLY_CONNECTED => Some("FULLY_CONNECTED"),
                Self::HASHTABLE_LOOKUP => Some("HASHTABLE_LOOKUP"),
                Self::L2_NORMALIZATION => Some("L2_NORMALIZATION"),
                Self::L2_POOL_2D => Some("L2_POOL_2D"),
                Self::LOCAL_RESPONSE_NORMALIZATION => Some("LOCAL_RESPONSE_NORMALIZATION"),
                Self::LOGISTIC => Some("LOGISTIC"),
                Self::LSH_PROJECTION => Some("LSH_PROJECTION"),
                Self::LSTM => Some("LSTM"),
                Self::MAX_POOL_2D => Some("MAX_POOL_2D"),
                Self::MUL => Some("MUL"),
                Self::RELU => Some("RELU"),
                Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
                Self::RELU6 => Some("RELU6"),
                Self::RESHAPE => Some("RESHAPE"),
                Self::RESIZE_BILINEAR => Some("RESIZE_BILINEAR"),
                Self::RNN => Some("RNN"),
                Self::SOFTMAX => Some("SOFTMAX"),
                Self::SPACE_TO_DEPTH => Some("SPACE_TO_DEPTH"),
                Self::SVDF => Some("SVDF"),
                Self::TANH => Some("TANH"),
                Self::CONCAT_EMBEDDINGS => Some("CONCAT_EMBEDDINGS"),
                Self::SKIP_GRAM => Some("SKIP_GRAM"),
                Self::CALL => Some("CALL"),
                Self::CUSTOM => Some("CUSTOM"),
                Self::EMBEDDING_LOOKUP_SPARSE => Some("EMBEDDING_LOOKUP_SPARSE"),
                Self::PAD => Some("PAD"),
                Self::UNIDIRECTIONAL_SEQUENCE_RNN => Some("UNIDIRECTIONAL_SEQUENCE_RNN"),
                Self::GATHER => Some("GATHER"),
                Self::BATCH_TO_SPACE_ND => Some("BATCH_TO_SPACE_ND"),
                Self::SPACE_TO_BATCH_ND => Some("SPACE_TO_BATCH_ND"),
                Self::TRANSPOSE => Some("TRANSPOSE"),
                Self::MEAN => Some("MEAN"),
                Self::SUB => Some("SUB"),
                Self::DIV => Some("DIV"),
                Self::SQUEEZE => Some("SQUEEZE"),
                Self::UNIDIRECTIONAL_SEQUENCE_LSTM => Some("UNIDIRECTIONAL_SEQUENCE_LSTM"),
                Self::STRIDED_SLICE => Some("STRIDED_SLICE"),
                Self::BIDIRECTIONAL_SEQUENCE_RNN => Some("BIDIRECTIONAL_SEQUENCE_RNN"),
                Self::EXP => Some("EXP"),
                Self::TOPK_V2 => Some("TOPK_V2"),
                Self::SPLIT => Some("SPLIT"),
                Self::LOG_SOFTMAX => Some("LOG_SOFTMAX"),
                Self::DELEGATE => Some("DELEGATE"),
                Self::BIDIRECTIONAL_SEQUENCE_LSTM => Some("BIDIRECTIONAL_SEQUENCE_LSTM"),
                Self::CAST => Some("CAST"),
                Self::PRELU => Some("PRELU"),
                Self::MAXIMUM => Some("MAXIMUM"),
                Self::ARG_MAX => Some("ARG_MAX"),
                Self::MINIMUM => Some("MINIMUM"),
                Self::LESS => Some("LESS"),
                Self::NEG => Some("NEG"),
                Self::PADV2 => Some("PADV2"),
                Self::GREATER => Some("GREATER"),
                Self::GREATER_EQUAL => Some("GREATER_EQUAL"),
                Self::LESS_EQUAL => Some("LESS_EQUAL"),
                Self::SELECT => Some("SELECT"),
                Self::SLICE => Some("SLICE"),
                Self::SIN => Some("SIN"),
                Self::TRANSPOSE_CONV => Some("TRANSPOSE_CONV"),
                Self::SPARSE_TO_DENSE => Some("SPARSE_TO_DENSE"),
                Self::TILE => Some("TILE"),
                Self::EXPAND_DIMS => Some("EXPAND_DIMS"),
                Self::EQUAL => Some("EQUAL"),
                Self::NOT_EQUAL => Some("NOT_EQUAL"),
                Self::LOG => Some("LOG"),
                Self::SUM => Some("SUM"),
                Self::SQRT => Some("SQRT"),
                Self::RSQRT => Some("RSQRT"),
                Self::SHAPE => Some("SHAPE"),
                Self::POW => Some("POW"),
                Self::ARG_MIN => Some("ARG_MIN"),
                Self::FAKE_QUANT => Some("FAKE_QUANT"),
                Self::REDUCE_PROD => Some("REDUCE_PROD"),
                Self::REDUCE_MAX => Some("REDUCE_MAX"),
                Self::PACK => Some("PACK"),
                Self::LOGICAL_OR => Some("LOGICAL_OR"),
                Self::ONE_HOT => Some("ONE_HOT"),
                Self::LOGICAL_AND => Some("LOGICAL_AND"),
                Self::LOGICAL_NOT => Some("LOGICAL_NOT"),
                Self::UNPACK => Some("UNPACK"),
                Self::REDUCE_MIN => Some("REDUCE_MIN"),
                Self::FLOOR_DIV => Some("FLOOR_DIV"),
                Self::REDUCE_ANY => Some("REDUCE_ANY"),
                Self::SQUARE => Some("SQUARE"),
                Self::ZEROS_LIKE => Some("ZEROS_LIKE"),
                Self::FILL => Some("FILL"),
                Self::FLOOR_MOD => Some("FLOOR_MOD"),
                Self::RANGE => Some("RANGE"),
                Self::RESIZE_NEAREST_NEIGHBOR => Some("RESIZE_NEAREST_NEIGHBOR"),
                Self::LEAKY_RELU => Some("LEAKY_RELU"),
                Self::SQUARED_DIFFERENCE => Some("SQUARED_DIFFERENCE"),
                Self::MIRROR_PAD => Some("MIRROR_PAD"),
                Self::ABS => Some("ABS"),
                Self::SPLIT_V => Some("SPLIT_V"),
                Self::UNIQUE => Some("UNIQUE"),
                Self::CEIL => Some("CEIL"),
                Self::REVERSE_V2 => Some("REVERSE_V2"),
                Self::ADD_N => Some("ADD_N"),
                Self::GATHER_ND => Some("GATHER_ND"),
                Self::COS => Some("COS"),
                Self::WHERE => Some("WHERE"),
                Self::RANK => Some("RANK"),
                Self::ELU => Some("ELU"),
                Self::REVERSE_SEQUENCE => Some("REVERSE_SEQUENCE"),
                Self::MATRIX_DIAG => Some("MATRIX_DIAG"),
                Self::QUANTIZE => Some("QUANTIZE"),
                Self::MATRIX_SET_DIAG => Some("MATRIX_SET_DIAG"),
                Self::ROUND => Some("ROUND"),
                Self::HARD_SWISH => Some("HARD_SWISH"),
                Self::IF => Some("IF"),
                Self::WHILE => Some("WHILE"),
                Self::NON_MAX_SUPPRESSION_V4 => Some("NON_MAX_SUPPRESSION_V4"),
                Self::NON_MAX_SUPPRESSION_V5 => Some("NON_MAX_SUPPRESSION_V5"),
                Self::SCATTER_ND => Some("SCATTER_ND"),
                Self::SELECT_V2 => Some("SELECT_V2"),
                Self::DENSIFY => Some("DENSIFY"),
                Self::SEGMENT_SUM => Some("SEGMENT_SUM"),
                Self::BATCH_MATMUL => Some("BATCH_MATMUL"),
                Self::PLACEHOLDER_FOR_GREATER_OP_CODES => Some("PLACEHOLDER_FOR_GREATER_OP_CODES"),
                Self::CUMSUM => Some("CUMSUM"),
                Self::CALL_ONCE => Some("CALL_ONCE"),
                Self::BROADCAST_TO => Some("BROADCAST_TO"),
                Self::RFFT2D => Some("RFFT2D"),
                Self::CONV_3D => Some("CONV_3D"),
                Self::IMAG => Some("IMAG"),
                Self::REAL => Some("REAL"),
                Self::COMPLEX_ABS => Some("COMPLEX_ABS"),
                Self::HASHTABLE => Some("HASHTABLE"),
                Self::HASHTABLE_FIND => Some("HASHTABLE_FIND"),
                Self::HASHTABLE_IMPORT => Some("HASHTABLE_IMPORT"),
                Self::HASHTABLE_SIZE => Some("HASHTABLE_SIZE"),
                Self::REDUCE_ALL => Some("REDUCE_ALL"),
                Self::CONV_3D_TRANSPOSE => Some("CONV_3D_TRANSPOSE"),
                Self::VAR_HANDLE => Some("VAR_HANDLE"),
                Self::READ_VARIABLE => Some("READ_VARIABLE"),
                Self::ASSIGN_VARIABLE => Some("ASSIGN_VARIABLE"),
                Self::BROADCAST_ARGS => Some("BROADCAST_ARGS"),
                Self::RANDOM_STANDARD_NORMAL => Some("RANDOM_STANDARD_NORMAL"),
                Self::BUCKETIZE => Some("BUCKETIZE"),
                Self::RANDOM_UNIFORM => Some("RANDOM_UNIFORM"),
                Self::MULTINOMIAL => Some("MULTINOMIAL"),
                Self::GELU => Some("GELU"),
                Self::DYNAMIC_UPDATE_SLICE => Some("DYNAMIC_UPDATE_SLICE"),
                Self::RELU_0_TO_1 => Some("RELU_0_TO_1"),
                Self::UNSORTED_SEGMENT_PROD => Some("UNSORTED_SEGMENT_PROD"),
                Self::UNSORTED_SEGMENT_MAX => Some("UNSORTED_SEGMENT_MAX"),
                Self::UNSORTED_SEGMENT_SUM => Some("UNSORTED_SEGMENT_SUM"),
                Self::ATAN2 => Some("ATAN2"),
                Self::UNSORTED_SEGMENT_MIN => Some("UNSORTED_SEGMENT_MIN"),
                Self::SIGN => Some("SIGN"),
                Self::BITCAST => Some("BITCAST"),
                Self::BITWISE_XOR => Some("BITWISE_XOR"),
                Self::RIGHT_SHIFT => Some("RIGHT_SHIFT"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for BuiltinOperator {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for BuiltinOperator {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for BuiltinOperator {
        type Output = BuiltinOperator;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for BuiltinOperator {
        type Scalar = i32;
        #[inline]
        fn to_little_endian(self) -> i32 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i32) -> Self {
            let b = i32::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for BuiltinOperator {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i32::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for BuiltinOperator {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_BUILTIN_OPTIONS: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_BUILTIN_OPTIONS: u8 = 126;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_BUILTIN_OPTIONS: [BuiltinOptions; 127] = [
        BuiltinOptions::NONE,
        BuiltinOptions::Conv2DOptions,
        BuiltinOptions::DepthwiseConv2DOptions,
        BuiltinOptions::ConcatEmbeddingsOptions,
        BuiltinOptions::LSHProjectionOptions,
        BuiltinOptions::Pool2DOptions,
        BuiltinOptions::SVDFOptions,
        BuiltinOptions::RNNOptions,
        BuiltinOptions::FullyConnectedOptions,
        BuiltinOptions::SoftmaxOptions,
        BuiltinOptions::ConcatenationOptions,
        BuiltinOptions::AddOptions,
        BuiltinOptions::L2NormOptions,
        BuiltinOptions::LocalResponseNormalizationOptions,
        BuiltinOptions::LSTMOptions,
        BuiltinOptions::ResizeBilinearOptions,
        BuiltinOptions::CallOptions,
        BuiltinOptions::ReshapeOptions,
        BuiltinOptions::SkipGramOptions,
        BuiltinOptions::SpaceToDepthOptions,
        BuiltinOptions::EmbeddingLookupSparseOptions,
        BuiltinOptions::MulOptions,
        BuiltinOptions::PadOptions,
        BuiltinOptions::GatherOptions,
        BuiltinOptions::BatchToSpaceNDOptions,
        BuiltinOptions::SpaceToBatchNDOptions,
        BuiltinOptions::TransposeOptions,
        BuiltinOptions::ReducerOptions,
        BuiltinOptions::SubOptions,
        BuiltinOptions::DivOptions,
        BuiltinOptions::SqueezeOptions,
        BuiltinOptions::SequenceRNNOptions,
        BuiltinOptions::StridedSliceOptions,
        BuiltinOptions::ExpOptions,
        BuiltinOptions::TopKV2Options,
        BuiltinOptions::SplitOptions,
        BuiltinOptions::LogSoftmaxOptions,
        BuiltinOptions::CastOptions,
        BuiltinOptions::DequantizeOptions,
        BuiltinOptions::MaximumMinimumOptions,
        BuiltinOptions::ArgMaxOptions,
        BuiltinOptions::LessOptions,
        BuiltinOptions::NegOptions,
        BuiltinOptions::PadV2Options,
        BuiltinOptions::GreaterOptions,
        BuiltinOptions::GreaterEqualOptions,
        BuiltinOptions::LessEqualOptions,
        BuiltinOptions::SelectOptions,
        BuiltinOptions::SliceOptions,
        BuiltinOptions::TransposeConvOptions,
        BuiltinOptions::SparseToDenseOptions,
        BuiltinOptions::TileOptions,
        BuiltinOptions::ExpandDimsOptions,
        BuiltinOptions::EqualOptions,
        BuiltinOptions::NotEqualOptions,
        BuiltinOptions::ShapeOptions,
        BuiltinOptions::PowOptions,
        BuiltinOptions::ArgMinOptions,
        BuiltinOptions::FakeQuantOptions,
        BuiltinOptions::PackOptions,
        BuiltinOptions::LogicalOrOptions,
        BuiltinOptions::OneHotOptions,
        BuiltinOptions::LogicalAndOptions,
        BuiltinOptions::LogicalNotOptions,
        BuiltinOptions::UnpackOptions,
        BuiltinOptions::FloorDivOptions,
        BuiltinOptions::SquareOptions,
        BuiltinOptions::ZerosLikeOptions,
        BuiltinOptions::FillOptions,
        BuiltinOptions::BidirectionalSequenceLSTMOptions,
        BuiltinOptions::BidirectionalSequenceRNNOptions,
        BuiltinOptions::UnidirectionalSequenceLSTMOptions,
        BuiltinOptions::FloorModOptions,
        BuiltinOptions::RangeOptions,
        BuiltinOptions::ResizeNearestNeighborOptions,
        BuiltinOptions::LeakyReluOptions,
        BuiltinOptions::SquaredDifferenceOptions,
        BuiltinOptions::MirrorPadOptions,
        BuiltinOptions::AbsOptions,
        BuiltinOptions::SplitVOptions,
        BuiltinOptions::UniqueOptions,
        BuiltinOptions::ReverseV2Options,
        BuiltinOptions::AddNOptions,
        BuiltinOptions::GatherNdOptions,
        BuiltinOptions::CosOptions,
        BuiltinOptions::WhereOptions,
        BuiltinOptions::RankOptions,
        BuiltinOptions::ReverseSequenceOptions,
        BuiltinOptions::MatrixDiagOptions,
        BuiltinOptions::QuantizeOptions,
        BuiltinOptions::MatrixSetDiagOptions,
        BuiltinOptions::HardSwishOptions,
        BuiltinOptions::IfOptions,
        BuiltinOptions::WhileOptions,
        BuiltinOptions::DepthToSpaceOptions,
        BuiltinOptions::NonMaxSuppressionV4Options,
        BuiltinOptions::NonMaxSuppressionV5Options,
        BuiltinOptions::ScatterNdOptions,
        BuiltinOptions::SelectV2Options,
        BuiltinOptions::DensifyOptions,
        BuiltinOptions::SegmentSumOptions,
        BuiltinOptions::BatchMatMulOptions,
        BuiltinOptions::CumsumOptions,
        BuiltinOptions::CallOnceOptions,
        BuiltinOptions::BroadcastToOptions,
        BuiltinOptions::Rfft2dOptions,
        BuiltinOptions::Conv3DOptions,
        BuiltinOptions::HashtableOptions,
        BuiltinOptions::HashtableFindOptions,
        BuiltinOptions::HashtableImportOptions,
        BuiltinOptions::HashtableSizeOptions,
        BuiltinOptions::VarHandleOptions,
        BuiltinOptions::ReadVariableOptions,
        BuiltinOptions::AssignVariableOptions,
        BuiltinOptions::RandomOptions,
        BuiltinOptions::BucketizeOptions,
        BuiltinOptions::GeluOptions,
        BuiltinOptions::DynamicUpdateSliceOptions,
        BuiltinOptions::UnsortedSegmentProdOptions,
        BuiltinOptions::UnsortedSegmentMaxOptions,
        BuiltinOptions::UnsortedSegmentMinOptions,
        BuiltinOptions::UnsortedSegmentSumOptions,
        BuiltinOptions::ATan2Options,
        BuiltinOptions::SignOptions,
        BuiltinOptions::BitcastOptions,
        BuiltinOptions::BitwiseXorOptions,
        BuiltinOptions::RightShiftOptions,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct BuiltinOptions(pub u8);
    #[allow(non_upper_case_globals)]
    impl BuiltinOptions {
        pub const NONE: Self = Self(0);
        pub const Conv2DOptions: Self = Self(1);
        pub const DepthwiseConv2DOptions: Self = Self(2);
        pub const ConcatEmbeddingsOptions: Self = Self(3);
        pub const LSHProjectionOptions: Self = Self(4);
        pub const Pool2DOptions: Self = Self(5);
        pub const SVDFOptions: Self = Self(6);
        pub const RNNOptions: Self = Self(7);
        pub const FullyConnectedOptions: Self = Self(8);
        pub const SoftmaxOptions: Self = Self(9);
        pub const ConcatenationOptions: Self = Self(10);
        pub const AddOptions: Self = Self(11);
        pub const L2NormOptions: Self = Self(12);
        pub const LocalResponseNormalizationOptions: Self = Self(13);
        pub const LSTMOptions: Self = Self(14);
        pub const ResizeBilinearOptions: Self = Self(15);
        pub const CallOptions: Self = Self(16);
        pub const ReshapeOptions: Self = Self(17);
        pub const SkipGramOptions: Self = Self(18);
        pub const SpaceToDepthOptions: Self = Self(19);
        pub const EmbeddingLookupSparseOptions: Self = Self(20);
        pub const MulOptions: Self = Self(21);
        pub const PadOptions: Self = Self(22);
        pub const GatherOptions: Self = Self(23);
        pub const BatchToSpaceNDOptions: Self = Self(24);
        pub const SpaceToBatchNDOptions: Self = Self(25);
        pub const TransposeOptions: Self = Self(26);
        pub const ReducerOptions: Self = Self(27);
        pub const SubOptions: Self = Self(28);
        pub const DivOptions: Self = Self(29);
        pub const SqueezeOptions: Self = Self(30);
        pub const SequenceRNNOptions: Self = Self(31);
        pub const StridedSliceOptions: Self = Self(32);
        pub const ExpOptions: Self = Self(33);
        pub const TopKV2Options: Self = Self(34);
        pub const SplitOptions: Self = Self(35);
        pub const LogSoftmaxOptions: Self = Self(36);
        pub const CastOptions: Self = Self(37);
        pub const DequantizeOptions: Self = Self(38);
        pub const MaximumMinimumOptions: Self = Self(39);
        pub const ArgMaxOptions: Self = Self(40);
        pub const LessOptions: Self = Self(41);
        pub const NegOptions: Self = Self(42);
        pub const PadV2Options: Self = Self(43);
        pub const GreaterOptions: Self = Self(44);
        pub const GreaterEqualOptions: Self = Self(45);
        pub const LessEqualOptions: Self = Self(46);
        pub const SelectOptions: Self = Self(47);
        pub const SliceOptions: Self = Self(48);
        pub const TransposeConvOptions: Self = Self(49);
        pub const SparseToDenseOptions: Self = Self(50);
        pub const TileOptions: Self = Self(51);
        pub const ExpandDimsOptions: Self = Self(52);
        pub const EqualOptions: Self = Self(53);
        pub const NotEqualOptions: Self = Self(54);
        pub const ShapeOptions: Self = Self(55);
        pub const PowOptions: Self = Self(56);
        pub const ArgMinOptions: Self = Self(57);
        pub const FakeQuantOptions: Self = Self(58);
        pub const PackOptions: Self = Self(59);
        pub const LogicalOrOptions: Self = Self(60);
        pub const OneHotOptions: Self = Self(61);
        pub const LogicalAndOptions: Self = Self(62);
        pub const LogicalNotOptions: Self = Self(63);
        pub const UnpackOptions: Self = Self(64);
        pub const FloorDivOptions: Self = Self(65);
        pub const SquareOptions: Self = Self(66);
        pub const ZerosLikeOptions: Self = Self(67);
        pub const FillOptions: Self = Self(68);
        pub const BidirectionalSequenceLSTMOptions: Self = Self(69);
        pub const BidirectionalSequenceRNNOptions: Self = Self(70);
        pub const UnidirectionalSequenceLSTMOptions: Self = Self(71);
        pub const FloorModOptions: Self = Self(72);
        pub const RangeOptions: Self = Self(73);
        pub const ResizeNearestNeighborOptions: Self = Self(74);
        pub const LeakyReluOptions: Self = Self(75);
        pub const SquaredDifferenceOptions: Self = Self(76);
        pub const MirrorPadOptions: Self = Self(77);
        pub const AbsOptions: Self = Self(78);
        pub const SplitVOptions: Self = Self(79);
        pub const UniqueOptions: Self = Self(80);
        pub const ReverseV2Options: Self = Self(81);
        pub const AddNOptions: Self = Self(82);
        pub const GatherNdOptions: Self = Self(83);
        pub const CosOptions: Self = Self(84);
        pub const WhereOptions: Self = Self(85);
        pub const RankOptions: Self = Self(86);
        pub const ReverseSequenceOptions: Self = Self(87);
        pub const MatrixDiagOptions: Self = Self(88);
        pub const QuantizeOptions: Self = Self(89);
        pub const MatrixSetDiagOptions: Self = Self(90);
        pub const HardSwishOptions: Self = Self(91);
        pub const IfOptions: Self = Self(92);
        pub const WhileOptions: Self = Self(93);
        pub const DepthToSpaceOptions: Self = Self(94);
        pub const NonMaxSuppressionV4Options: Self = Self(95);
        pub const NonMaxSuppressionV5Options: Self = Self(96);
        pub const ScatterNdOptions: Self = Self(97);
        pub const SelectV2Options: Self = Self(98);
        pub const DensifyOptions: Self = Self(99);
        pub const SegmentSumOptions: Self = Self(100);
        pub const BatchMatMulOptions: Self = Self(101);
        pub const CumsumOptions: Self = Self(102);
        pub const CallOnceOptions: Self = Self(103);
        pub const BroadcastToOptions: Self = Self(104);
        pub const Rfft2dOptions: Self = Self(105);
        pub const Conv3DOptions: Self = Self(106);
        pub const HashtableOptions: Self = Self(107);
        pub const HashtableFindOptions: Self = Self(108);
        pub const HashtableImportOptions: Self = Self(109);
        pub const HashtableSizeOptions: Self = Self(110);
        pub const VarHandleOptions: Self = Self(111);
        pub const ReadVariableOptions: Self = Self(112);
        pub const AssignVariableOptions: Self = Self(113);
        pub const RandomOptions: Self = Self(114);
        pub const BucketizeOptions: Self = Self(115);
        pub const GeluOptions: Self = Self(116);
        pub const DynamicUpdateSliceOptions: Self = Self(117);
        pub const UnsortedSegmentProdOptions: Self = Self(118);
        pub const UnsortedSegmentMaxOptions: Self = Self(119);
        pub const UnsortedSegmentMinOptions: Self = Self(120);
        pub const UnsortedSegmentSumOptions: Self = Self(121);
        pub const ATan2Options: Self = Self(122);
        pub const SignOptions: Self = Self(123);
        pub const BitcastOptions: Self = Self(124);
        pub const BitwiseXorOptions: Self = Self(125);
        pub const RightShiftOptions: Self = Self(126);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 126;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::Conv2DOptions,
            Self::DepthwiseConv2DOptions,
            Self::ConcatEmbeddingsOptions,
            Self::LSHProjectionOptions,
            Self::Pool2DOptions,
            Self::SVDFOptions,
            Self::RNNOptions,
            Self::FullyConnectedOptions,
            Self::SoftmaxOptions,
            Self::ConcatenationOptions,
            Self::AddOptions,
            Self::L2NormOptions,
            Self::LocalResponseNormalizationOptions,
            Self::LSTMOptions,
            Self::ResizeBilinearOptions,
            Self::CallOptions,
            Self::ReshapeOptions,
            Self::SkipGramOptions,
            Self::SpaceToDepthOptions,
            Self::EmbeddingLookupSparseOptions,
            Self::MulOptions,
            Self::PadOptions,
            Self::GatherOptions,
            Self::BatchToSpaceNDOptions,
            Self::SpaceToBatchNDOptions,
            Self::TransposeOptions,
            Self::ReducerOptions,
            Self::SubOptions,
            Self::DivOptions,
            Self::SqueezeOptions,
            Self::SequenceRNNOptions,
            Self::StridedSliceOptions,
            Self::ExpOptions,
            Self::TopKV2Options,
            Self::SplitOptions,
            Self::LogSoftmaxOptions,
            Self::CastOptions,
            Self::DequantizeOptions,
            Self::MaximumMinimumOptions,
            Self::ArgMaxOptions,
            Self::LessOptions,
            Self::NegOptions,
            Self::PadV2Options,
            Self::GreaterOptions,
            Self::GreaterEqualOptions,
            Self::LessEqualOptions,
            Self::SelectOptions,
            Self::SliceOptions,
            Self::TransposeConvOptions,
            Self::SparseToDenseOptions,
            Self::TileOptions,
            Self::ExpandDimsOptions,
            Self::EqualOptions,
            Self::NotEqualOptions,
            Self::ShapeOptions,
            Self::PowOptions,
            Self::ArgMinOptions,
            Self::FakeQuantOptions,
            Self::PackOptions,
            Self::LogicalOrOptions,
            Self::OneHotOptions,
            Self::LogicalAndOptions,
            Self::LogicalNotOptions,
            Self::UnpackOptions,
            Self::FloorDivOptions,
            Self::SquareOptions,
            Self::ZerosLikeOptions,
            Self::FillOptions,
            Self::BidirectionalSequenceLSTMOptions,
            Self::BidirectionalSequenceRNNOptions,
            Self::UnidirectionalSequenceLSTMOptions,
            Self::FloorModOptions,
            Self::RangeOptions,
            Self::ResizeNearestNeighborOptions,
            Self::LeakyReluOptions,
            Self::SquaredDifferenceOptions,
            Self::MirrorPadOptions,
            Self::AbsOptions,
            Self::SplitVOptions,
            Self::UniqueOptions,
            Self::ReverseV2Options,
            Self::AddNOptions,
            Self::GatherNdOptions,
            Self::CosOptions,
            Self::WhereOptions,
            Self::RankOptions,
            Self::ReverseSequenceOptions,
            Self::MatrixDiagOptions,
            Self::QuantizeOptions,
            Self::MatrixSetDiagOptions,
            Self::HardSwishOptions,
            Self::IfOptions,
            Self::WhileOptions,
            Self::DepthToSpaceOptions,
            Self::NonMaxSuppressionV4Options,
            Self::NonMaxSuppressionV5Options,
            Self::ScatterNdOptions,
            Self::SelectV2Options,
            Self::DensifyOptions,
            Self::SegmentSumOptions,
            Self::BatchMatMulOptions,
            Self::CumsumOptions,
            Self::CallOnceOptions,
            Self::BroadcastToOptions,
            Self::Rfft2dOptions,
            Self::Conv3DOptions,
            Self::HashtableOptions,
            Self::HashtableFindOptions,
            Self::HashtableImportOptions,
            Self::HashtableSizeOptions,
            Self::VarHandleOptions,
            Self::ReadVariableOptions,
            Self::AssignVariableOptions,
            Self::RandomOptions,
            Self::BucketizeOptions,
            Self::GeluOptions,
            Self::DynamicUpdateSliceOptions,
            Self::UnsortedSegmentProdOptions,
            Self::UnsortedSegmentMaxOptions,
            Self::UnsortedSegmentMinOptions,
            Self::UnsortedSegmentSumOptions,
            Self::ATan2Options,
            Self::SignOptions,
            Self::BitcastOptions,
            Self::BitwiseXorOptions,
            Self::RightShiftOptions,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::Conv2DOptions => Some("Conv2DOptions"),
                Self::DepthwiseConv2DOptions => Some("DepthwiseConv2DOptions"),
                Self::ConcatEmbeddingsOptions => Some("ConcatEmbeddingsOptions"),
                Self::LSHProjectionOptions => Some("LSHProjectionOptions"),
                Self::Pool2DOptions => Some("Pool2DOptions"),
                Self::SVDFOptions => Some("SVDFOptions"),
                Self::RNNOptions => Some("RNNOptions"),
                Self::FullyConnectedOptions => Some("FullyConnectedOptions"),
                Self::SoftmaxOptions => Some("SoftmaxOptions"),
                Self::ConcatenationOptions => Some("ConcatenationOptions"),
                Self::AddOptions => Some("AddOptions"),
                Self::L2NormOptions => Some("L2NormOptions"),
                Self::LocalResponseNormalizationOptions => {
                    Some("LocalResponseNormalizationOptions")
                }
                Self::LSTMOptions => Some("LSTMOptions"),
                Self::ResizeBilinearOptions => Some("ResizeBilinearOptions"),
                Self::CallOptions => Some("CallOptions"),
                Self::ReshapeOptions => Some("ReshapeOptions"),
                Self::SkipGramOptions => Some("SkipGramOptions"),
                Self::SpaceToDepthOptions => Some("SpaceToDepthOptions"),
                Self::EmbeddingLookupSparseOptions => Some("EmbeddingLookupSparseOptions"),
                Self::MulOptions => Some("MulOptions"),
                Self::PadOptions => Some("PadOptions"),
                Self::GatherOptions => Some("GatherOptions"),
                Self::BatchToSpaceNDOptions => Some("BatchToSpaceNDOptions"),
                Self::SpaceToBatchNDOptions => Some("SpaceToBatchNDOptions"),
                Self::TransposeOptions => Some("TransposeOptions"),
                Self::ReducerOptions => Some("ReducerOptions"),
                Self::SubOptions => Some("SubOptions"),
                Self::DivOptions => Some("DivOptions"),
                Self::SqueezeOptions => Some("SqueezeOptions"),
                Self::SequenceRNNOptions => Some("SequenceRNNOptions"),
                Self::StridedSliceOptions => Some("StridedSliceOptions"),
                Self::ExpOptions => Some("ExpOptions"),
                Self::TopKV2Options => Some("TopKV2Options"),
                Self::SplitOptions => Some("SplitOptions"),
                Self::LogSoftmaxOptions => Some("LogSoftmaxOptions"),
                Self::CastOptions => Some("CastOptions"),
                Self::DequantizeOptions => Some("DequantizeOptions"),
                Self::MaximumMinimumOptions => Some("MaximumMinimumOptions"),
                Self::ArgMaxOptions => Some("ArgMaxOptions"),
                Self::LessOptions => Some("LessOptions"),
                Self::NegOptions => Some("NegOptions"),
                Self::PadV2Options => Some("PadV2Options"),
                Self::GreaterOptions => Some("GreaterOptions"),
                Self::GreaterEqualOptions => Some("GreaterEqualOptions"),
                Self::LessEqualOptions => Some("LessEqualOptions"),
                Self::SelectOptions => Some("SelectOptions"),
                Self::SliceOptions => Some("SliceOptions"),
                Self::TransposeConvOptions => Some("TransposeConvOptions"),
                Self::SparseToDenseOptions => Some("SparseToDenseOptions"),
                Self::TileOptions => Some("TileOptions"),
                Self::ExpandDimsOptions => Some("ExpandDimsOptions"),
                Self::EqualOptions => Some("EqualOptions"),
                Self::NotEqualOptions => Some("NotEqualOptions"),
                Self::ShapeOptions => Some("ShapeOptions"),
                Self::PowOptions => Some("PowOptions"),
                Self::ArgMinOptions => Some("ArgMinOptions"),
                Self::FakeQuantOptions => Some("FakeQuantOptions"),
                Self::PackOptions => Some("PackOptions"),
                Self::LogicalOrOptions => Some("LogicalOrOptions"),
                Self::OneHotOptions => Some("OneHotOptions"),
                Self::LogicalAndOptions => Some("LogicalAndOptions"),
                Self::LogicalNotOptions => Some("LogicalNotOptions"),
                Self::UnpackOptions => Some("UnpackOptions"),
                Self::FloorDivOptions => Some("FloorDivOptions"),
                Self::SquareOptions => Some("SquareOptions"),
                Self::ZerosLikeOptions => Some("ZerosLikeOptions"),
                Self::FillOptions => Some("FillOptions"),
                Self::BidirectionalSequenceLSTMOptions => Some("BidirectionalSequenceLSTMOptions"),
                Self::BidirectionalSequenceRNNOptions => Some("BidirectionalSequenceRNNOptions"),
                Self::UnidirectionalSequenceLSTMOptions => {
                    Some("UnidirectionalSequenceLSTMOptions")
                }
                Self::FloorModOptions => Some("FloorModOptions"),
                Self::RangeOptions => Some("RangeOptions"),
                Self::ResizeNearestNeighborOptions => Some("ResizeNearestNeighborOptions"),
                Self::LeakyReluOptions => Some("LeakyReluOptions"),
                Self::SquaredDifferenceOptions => Some("SquaredDifferenceOptions"),
                Self::MirrorPadOptions => Some("MirrorPadOptions"),
                Self::AbsOptions => Some("AbsOptions"),
                Self::SplitVOptions => Some("SplitVOptions"),
                Self::UniqueOptions => Some("UniqueOptions"),
                Self::ReverseV2Options => Some("ReverseV2Options"),
                Self::AddNOptions => Some("AddNOptions"),
                Self::GatherNdOptions => Some("GatherNdOptions"),
                Self::CosOptions => Some("CosOptions"),
                Self::WhereOptions => Some("WhereOptions"),
                Self::RankOptions => Some("RankOptions"),
                Self::ReverseSequenceOptions => Some("ReverseSequenceOptions"),
                Self::MatrixDiagOptions => Some("MatrixDiagOptions"),
                Self::QuantizeOptions => Some("QuantizeOptions"),
                Self::MatrixSetDiagOptions => Some("MatrixSetDiagOptions"),
                Self::HardSwishOptions => Some("HardSwishOptions"),
                Self::IfOptions => Some("IfOptions"),
                Self::WhileOptions => Some("WhileOptions"),
                Self::DepthToSpaceOptions => Some("DepthToSpaceOptions"),
                Self::NonMaxSuppressionV4Options => Some("NonMaxSuppressionV4Options"),
                Self::NonMaxSuppressionV5Options => Some("NonMaxSuppressionV5Options"),
                Self::ScatterNdOptions => Some("ScatterNdOptions"),
                Self::SelectV2Options => Some("SelectV2Options"),
                Self::DensifyOptions => Some("DensifyOptions"),
                Self::SegmentSumOptions => Some("SegmentSumOptions"),
                Self::BatchMatMulOptions => Some("BatchMatMulOptions"),
                Self::CumsumOptions => Some("CumsumOptions"),
                Self::CallOnceOptions => Some("CallOnceOptions"),
                Self::BroadcastToOptions => Some("BroadcastToOptions"),
                Self::Rfft2dOptions => Some("Rfft2dOptions"),
                Self::Conv3DOptions => Some("Conv3DOptions"),
                Self::HashtableOptions => Some("HashtableOptions"),
                Self::HashtableFindOptions => Some("HashtableFindOptions"),
                Self::HashtableImportOptions => Some("HashtableImportOptions"),
                Self::HashtableSizeOptions => Some("HashtableSizeOptions"),
                Self::VarHandleOptions => Some("VarHandleOptions"),
                Self::ReadVariableOptions => Some("ReadVariableOptions"),
                Self::AssignVariableOptions => Some("AssignVariableOptions"),
                Self::RandomOptions => Some("RandomOptions"),
                Self::BucketizeOptions => Some("BucketizeOptions"),
                Self::GeluOptions => Some("GeluOptions"),
                Self::DynamicUpdateSliceOptions => Some("DynamicUpdateSliceOptions"),
                Self::UnsortedSegmentProdOptions => Some("UnsortedSegmentProdOptions"),
                Self::UnsortedSegmentMaxOptions => Some("UnsortedSegmentMaxOptions"),
                Self::UnsortedSegmentMinOptions => Some("UnsortedSegmentMinOptions"),
                Self::UnsortedSegmentSumOptions => Some("UnsortedSegmentSumOptions"),
                Self::ATan2Options => Some("ATan2Options"),
                Self::SignOptions => Some("SignOptions"),
                Self::BitcastOptions => Some("BitcastOptions"),
                Self::BitwiseXorOptions => Some("BitwiseXorOptions"),
                Self::RightShiftOptions => Some("RightShiftOptions"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for BuiltinOptions {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for BuiltinOptions {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for BuiltinOptions {
        type Output = BuiltinOptions;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for BuiltinOptions {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for BuiltinOptions {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for BuiltinOptions {}
    pub struct BuiltinOptionsUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PADDING: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PADDING: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PADDING: [Padding; 2] = [Padding::SAME, Padding::VALID];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct Padding(pub i8);
    #[allow(non_upper_case_globals)]
    impl Padding {
        pub const SAME: Self = Self(0);
        pub const VALID: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::SAME, Self::VALID];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::SAME => Some("SAME"),
                Self::VALID => Some("VALID"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for Padding {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for Padding {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for Padding {
        type Output = Padding;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for Padding {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for Padding {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Padding {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ACTIVATION_FUNCTION_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ACTIVATION_FUNCTION_TYPE: i8 = 5;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ACTIVATION_FUNCTION_TYPE: [ActivationFunctionType; 6] = [
        ActivationFunctionType::NONE,
        ActivationFunctionType::RELU,
        ActivationFunctionType::RELU_N1_TO_1,
        ActivationFunctionType::RELU6,
        ActivationFunctionType::TANH,
        ActivationFunctionType::SIGN_BIT,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ActivationFunctionType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ActivationFunctionType {
        pub const NONE: Self = Self(0);
        pub const RELU: Self = Self(1);
        pub const RELU_N1_TO_1: Self = Self(2);
        pub const RELU6: Self = Self(3);
        pub const TANH: Self = Self(4);
        pub const SIGN_BIT: Self = Self(5);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 5;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::RELU,
            Self::RELU_N1_TO_1,
            Self::RELU6,
            Self::TANH,
            Self::SIGN_BIT,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::RELU => Some("RELU"),
                Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
                Self::RELU6 => Some("RELU6"),
                Self::TANH => Some("TANH"),
                Self::SIGN_BIT => Some("SIGN_BIT"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ActivationFunctionType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ActivationFunctionType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ActivationFunctionType {
        type Output = ActivationFunctionType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ActivationFunctionType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ActivationFunctionType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ActivationFunctionType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_LSHPROJECTION_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_LSHPROJECTION_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_LSHPROJECTION_TYPE: [LSHProjectionType; 3] = [
        LSHProjectionType::UNKNOWN,
        LSHProjectionType::SPARSE,
        LSHProjectionType::DENSE,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct LSHProjectionType(pub i8);
    #[allow(non_upper_case_globals)]
    impl LSHProjectionType {
        pub const UNKNOWN: Self = Self(0);
        pub const SPARSE: Self = Self(1);
        pub const DENSE: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::UNKNOWN, Self::SPARSE, Self::DENSE];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN => Some("UNKNOWN"),
                Self::SPARSE => Some("SPARSE"),
                Self::DENSE => Some("DENSE"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for LSHProjectionType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for LSHProjectionType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for LSHProjectionType {
        type Output = LSHProjectionType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for LSHProjectionType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for LSHProjectionType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for LSHProjectionType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT:
        [FullyConnectedOptionsWeightsFormat; 2] = [
        FullyConnectedOptionsWeightsFormat::DEFAULT,
        FullyConnectedOptionsWeightsFormat::SHUFFLED4x16INT8,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct FullyConnectedOptionsWeightsFormat(pub i8);
    #[allow(non_upper_case_globals)]
    impl FullyConnectedOptionsWeightsFormat {
        pub const DEFAULT: Self = Self(0);
        pub const SHUFFLED4x16INT8: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::DEFAULT, Self::SHUFFLED4x16INT8];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::DEFAULT => Some("DEFAULT"),
                Self::SHUFFLED4x16INT8 => Some("SHUFFLED4x16INT8"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for FullyConnectedOptionsWeightsFormat {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptionsWeightsFormat {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for FullyConnectedOptionsWeightsFormat {
        type Output = FullyConnectedOptionsWeightsFormat;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for FullyConnectedOptionsWeightsFormat {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for FullyConnectedOptionsWeightsFormat {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for FullyConnectedOptionsWeightsFormat {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_LSTMKERNEL_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_LSTMKERNEL_TYPE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_LSTMKERNEL_TYPE: [LSTMKernelType; 2] =
        [LSTMKernelType::FULL, LSTMKernelType::BASIC];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct LSTMKernelType(pub i8);
    #[allow(non_upper_case_globals)]
    impl LSTMKernelType {
        pub const FULL: Self = Self(0);
        pub const BASIC: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::FULL, Self::BASIC];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::FULL => Some("FULL"),
                Self::BASIC => Some("BASIC"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for LSTMKernelType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for LSTMKernelType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for LSTMKernelType {
        type Output = LSTMKernelType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for LSTMKernelType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for LSTMKernelType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for LSTMKernelType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COMBINER_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COMBINER_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COMBINER_TYPE: [CombinerType; 3] =
        [CombinerType::SUM, CombinerType::MEAN, CombinerType::SQRTN];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct CombinerType(pub i8);
    #[allow(non_upper_case_globals)]
    impl CombinerType {
        pub const SUM: Self = Self(0);
        pub const MEAN: Self = Self(1);
        pub const SQRTN: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::SUM, Self::MEAN, Self::SQRTN];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::SUM => Some("SUM"),
                Self::MEAN => Some("MEAN"),
                Self::SQRTN => Some("SQRTN"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for CombinerType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for CombinerType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for CombinerType {
        type Output = CombinerType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for CombinerType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for CombinerType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for CombinerType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_MIRROR_PAD_MODE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_MIRROR_PAD_MODE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_MIRROR_PAD_MODE: [MirrorPadMode; 2] =
        [MirrorPadMode::REFLECT, MirrorPadMode::SYMMETRIC];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct MirrorPadMode(pub i8);
    #[allow(non_upper_case_globals)]
    impl MirrorPadMode {
        pub const REFLECT: Self = Self(0);
        pub const SYMMETRIC: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::REFLECT, Self::SYMMETRIC];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::REFLECT => Some("REFLECT"),
                Self::SYMMETRIC => Some("SYMMETRIC"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for MirrorPadMode {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for MirrorPadMode {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for MirrorPadMode {
        type Output = MirrorPadMode;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for MirrorPadMode {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for MirrorPadMode {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for MirrorPadMode {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CUSTOM_OPTIONS_FORMAT: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CUSTOM_OPTIONS_FORMAT: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CUSTOM_OPTIONS_FORMAT: [CustomOptionsFormat; 1] =
        [CustomOptionsFormat::FLEXBUFFERS];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct CustomOptionsFormat(pub i8);
    #[allow(non_upper_case_globals)]
    impl CustomOptionsFormat {
        pub const FLEXBUFFERS: Self = Self(0);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 0;
        pub const ENUM_VALUES: &'static [Self] = &[Self::FLEXBUFFERS];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::FLEXBUFFERS => Some("FLEXBUFFERS"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for CustomOptionsFormat {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for CustomOptionsFormat {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for CustomOptionsFormat {
        type Output = CustomOptionsFormat;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for CustomOptionsFormat {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for CustomOptionsFormat {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for CustomOptionsFormat {}
    pub enum CustomQuantizationOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CustomQuantization<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CustomQuantization<'a> {
        type Inner = CustomQuantization<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CustomQuantization<'a> {
        pub const VT_CUSTOM: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CustomQuantization { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CustomQuantizationArgs<'args>,
        ) -> flatbuffers::WIPOffset<CustomQuantization<'bldr>> {
            let mut builder = CustomQuantizationBuilder::new(_fbb);
            if let Some(x) = args.custom {
                builder.add_custom(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn custom(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CustomQuantization::VT_CUSTOM,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for CustomQuantization<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "custom",
                    Self::VT_CUSTOM,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CustomQuantizationArgs<'a> {
        pub custom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CustomQuantizationArgs<'a> {
        #[inline]
        fn default() -> Self {
            CustomQuantizationArgs { custom: None }
        }
    }

    pub struct CustomQuantizationBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CustomQuantizationBuilder<'a, 'b> {
        #[inline]
        pub fn add_custom(&mut self, custom: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                CustomQuantization::VT_CUSTOM,
                custom,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CustomQuantizationBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CustomQuantizationBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CustomQuantization<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CustomQuantization<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CustomQuantization");
            ds.field("custom", &self.custom());
            ds.finish()
        }
    }
    pub enum QuantizationParametersOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct QuantizationParameters<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for QuantizationParameters<'a> {
        type Inner = QuantizationParameters<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> QuantizationParameters<'a> {
        pub const VT_MIN: flatbuffers::VOffsetT = 4;
        pub const VT_MAX: flatbuffers::VOffsetT = 6;
        pub const VT_SCALE: flatbuffers::VOffsetT = 8;
        pub const VT_ZERO_POINT: flatbuffers::VOffsetT = 10;
        pub const VT_DETAILS_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_DETAILS: flatbuffers::VOffsetT = 14;
        pub const VT_QUANTIZED_DIMENSION: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            QuantizationParameters { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args QuantizationParametersArgs<'args>,
        ) -> flatbuffers::WIPOffset<QuantizationParameters<'bldr>> {
            let mut builder = QuantizationParametersBuilder::new(_fbb);
            builder.add_quantized_dimension(args.quantized_dimension);
            if let Some(x) = args.details {
                builder.add_details(x);
            }
            if let Some(x) = args.zero_point {
                builder.add_zero_point(x);
            }
            if let Some(x) = args.scale {
                builder.add_scale(x);
            }
            if let Some(x) = args.max {
                builder.add_max(x);
            }
            if let Some(x) = args.min {
                builder.add_min(x);
            }
            builder.add_details_type(args.details_type);
            builder.finish()
        }

        #[inline]
        pub fn min(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        QuantizationParameters::VT_MIN,
                        None,
                    )
            }
        }
        #[inline]
        pub fn max(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        QuantizationParameters::VT_MAX,
                        None,
                    )
            }
        }
        #[inline]
        pub fn scale(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        QuantizationParameters::VT_SCALE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn zero_point(&self) -> Option<flatbuffers::Vector<'a, i64>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                        QuantizationParameters::VT_ZERO_POINT,
                        None,
                    )
            }
        }
        #[inline]
        pub fn details_type(&self) -> QuantizationDetails {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<QuantizationDetails>(
                        QuantizationParameters::VT_DETAILS_TYPE,
                        Some(QuantizationDetails::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn details(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        QuantizationParameters::VT_DETAILS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn quantized_dimension(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(QuantizationParameters::VT_QUANTIZED_DIMENSION, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn details_as_custom_quantization(&self) -> Option<CustomQuantization<'a>> {
            if self.details_type() == QuantizationDetails::CustomQuantization {
                self.details().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CustomQuantization::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for QuantizationParameters<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "min",
                    Self::VT_MIN,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "max",
                    Self::VT_MAX,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "scale",
                    Self::VT_SCALE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(
                    "zero_point",
                    Self::VT_ZERO_POINT,
                    false,
                )?
                .visit_union::<QuantizationDetails, _>(
                    "details_type",
                    Self::VT_DETAILS_TYPE,
                    "details",
                    Self::VT_DETAILS,
                    false,
                    |key, v, pos| {
                        match key {
                            QuantizationDetails::CustomQuantization => v
                                .verify_union_variant::<flatbuffers::ForwardsUOffset<
                                CustomQuantization,
                            >>(
                                "QuantizationDetails::CustomQuantization",
                                pos,
                            ),
                            _ => Ok(()),
                        }
                    },
                )?
                .visit_field::<i32>("quantized_dimension", Self::VT_QUANTIZED_DIMENSION, false)?
                .finish();
            Ok(())
        }
    }
    pub struct QuantizationParametersArgs<'a> {
        pub min: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
        pub max: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
        pub scale: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
        pub zero_point: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
        pub details_type: QuantizationDetails,
        pub details: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub quantized_dimension: i32,
    }
    impl<'a> Default for QuantizationParametersArgs<'a> {
        #[inline]
        fn default() -> Self {
            QuantizationParametersArgs {
                min: None,
                max: None,
                scale: None,
                zero_point: None,
                details_type: QuantizationDetails::NONE,
                details: None,
                quantized_dimension: 0,
            }
        }
    }

    pub struct QuantizationParametersBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> QuantizationParametersBuilder<'a, 'b> {
        #[inline]
        pub fn add_min(&mut self, min: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MIN, min);
        }
        #[inline]
        pub fn add_max(&mut self, max: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MAX, max);
        }
        #[inline]
        pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                QuantizationParameters::VT_SCALE,
                scale,
            );
        }
        #[inline]
        pub fn add_zero_point(
            &mut self,
            zero_point: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                QuantizationParameters::VT_ZERO_POINT,
                zero_point,
            );
        }
        #[inline]
        pub fn add_details_type(&mut self, details_type: QuantizationDetails) {
            self.fbb_.push_slot::<QuantizationDetails>(
                QuantizationParameters::VT_DETAILS_TYPE,
                details_type,
                QuantizationDetails::NONE,
            );
        }
        #[inline]
        pub fn add_details(
            &mut self,
            details: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                QuantizationParameters::VT_DETAILS,
                details,
            );
        }
        #[inline]
        pub fn add_quantized_dimension(&mut self, quantized_dimension: i32) {
            self.fbb_.push_slot::<i32>(
                QuantizationParameters::VT_QUANTIZED_DIMENSION,
                quantized_dimension,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> QuantizationParametersBuilder<'a, 'b> {
            let start = _fbb.start_table();
            QuantizationParametersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<QuantizationParameters<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for QuantizationParameters<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("QuantizationParameters");
            ds.field("min", &self.min());
            ds.field("max", &self.max());
            ds.field("scale", &self.scale());
            ds.field("zero_point", &self.zero_point());
            ds.field("details_type", &self.details_type());
            match self.details_type() {
                QuantizationDetails::CustomQuantization => {
                    if let Some(x) = self.details_as_custom_quantization() {
                        ds.field("details", &x)
                    } else {
                        ds.field(
                            "details",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("details", &x)
                }
            };
            ds.field("quantized_dimension", &self.quantized_dimension());
            ds.finish()
        }
    }
    pub enum Int32VectorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Int32Vector<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Int32Vector<'a> {
        type Inner = Int32Vector<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Int32Vector<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Int32Vector { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Int32VectorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Int32Vector<'bldr>> {
            let mut builder = Int32VectorBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn values(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Int32Vector::VT_VALUES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Int32Vector<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "values",
                    Self::VT_VALUES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct Int32VectorArgs<'a> {
        pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    }
    impl<'a> Default for Int32VectorArgs<'a> {
        #[inline]
        fn default() -> Self {
            Int32VectorArgs { values: None }
        }
    }

    pub struct Int32VectorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Int32VectorBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Int32Vector::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Int32VectorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Int32VectorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Int32Vector<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Int32Vector<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Int32Vector");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum Uint16VectorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Uint16Vector<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Uint16Vector<'a> {
        type Inner = Uint16Vector<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Uint16Vector<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Uint16Vector { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Uint16VectorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Uint16Vector<'bldr>> {
            let mut builder = Uint16VectorBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn values(&self) -> Option<flatbuffers::Vector<'a, u16>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(
                        Uint16Vector::VT_VALUES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Uint16Vector<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>(
                    "values",
                    Self::VT_VALUES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct Uint16VectorArgs<'a> {
        pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    }
    impl<'a> Default for Uint16VectorArgs<'a> {
        #[inline]
        fn default() -> Self {
            Uint16VectorArgs { values: None }
        }
    }

    pub struct Uint16VectorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Uint16VectorBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u16>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Uint16Vector::VT_VALUES, values);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> Uint16VectorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Uint16VectorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Uint16Vector<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Uint16Vector<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Uint16Vector");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum Uint8VectorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Uint8Vector<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Uint8Vector<'a> {
        type Inner = Uint8Vector<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Uint8Vector<'a> {
        pub const VT_VALUES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Uint8Vector { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Uint8VectorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Uint8Vector<'bldr>> {
            let mut builder = Uint8VectorBuilder::new(_fbb);
            if let Some(x) = args.values {
                builder.add_values(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn values(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Uint8Vector::VT_VALUES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Uint8Vector<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "values",
                    Self::VT_VALUES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct Uint8VectorArgs<'a> {
        pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for Uint8VectorArgs<'a> {
        #[inline]
        fn default() -> Self {
            Uint8VectorArgs { values: None }
        }
    }

    pub struct Uint8VectorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Uint8VectorBuilder<'a, 'b> {
        #[inline]
        pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Uint8Vector::VT_VALUES, values);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Uint8VectorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Uint8VectorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Uint8Vector<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Uint8Vector<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Uint8Vector");
            ds.field("values", &self.values());
            ds.finish()
        }
    }
    pub enum DimensionMetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DimensionMetadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DimensionMetadata<'a> {
        type Inner = DimensionMetadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DimensionMetadata<'a> {
        pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
        pub const VT_DENSE_SIZE: flatbuffers::VOffsetT = 6;
        pub const VT_ARRAY_SEGMENTS_TYPE: flatbuffers::VOffsetT = 8;
        pub const VT_ARRAY_SEGMENTS: flatbuffers::VOffsetT = 10;
        pub const VT_ARRAY_INDICES_TYPE: flatbuffers::VOffsetT = 12;
        pub const VT_ARRAY_INDICES: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DimensionMetadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DimensionMetadataArgs,
        ) -> flatbuffers::WIPOffset<DimensionMetadata<'bldr>> {
            let mut builder = DimensionMetadataBuilder::new(_fbb);
            if let Some(x) = args.array_indices {
                builder.add_array_indices(x);
            }
            if let Some(x) = args.array_segments {
                builder.add_array_segments(x);
            }
            builder.add_dense_size(args.dense_size);
            builder.add_array_indices_type(args.array_indices_type);
            builder.add_array_segments_type(args.array_segments_type);
            builder.add_format(args.format);
            builder.finish()
        }

        #[inline]
        pub fn format(&self) -> DimensionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<DimensionType>(DimensionMetadata::VT_FORMAT, Some(DimensionType::DENSE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn dense_size(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DimensionMetadata::VT_DENSE_SIZE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn array_segments_type(&self) -> SparseIndexVector {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SparseIndexVector>(
                        DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE,
                        Some(SparseIndexVector::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn array_segments(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        DimensionMetadata::VT_ARRAY_SEGMENTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn array_indices_type(&self) -> SparseIndexVector {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<SparseIndexVector>(
                        DimensionMetadata::VT_ARRAY_INDICES_TYPE,
                        Some(SparseIndexVector::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn array_indices(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        DimensionMetadata::VT_ARRAY_INDICES,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn array_segments_as_int_32_vector(&self) -> Option<Int32Vector<'a>> {
            if self.array_segments_type() == SparseIndexVector::Int32Vector {
                self.array_segments().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Int32Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_segments_as_uint_16_vector(&self) -> Option<Uint16Vector<'a>> {
            if self.array_segments_type() == SparseIndexVector::Uint16Vector {
                self.array_segments().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Uint16Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_segments_as_uint_8_vector(&self) -> Option<Uint8Vector<'a>> {
            if self.array_segments_type() == SparseIndexVector::Uint8Vector {
                self.array_segments().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Uint8Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_indices_as_int_32_vector(&self) -> Option<Int32Vector<'a>> {
            if self.array_indices_type() == SparseIndexVector::Int32Vector {
                self.array_indices().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Int32Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_indices_as_uint_16_vector(&self) -> Option<Uint16Vector<'a>> {
            if self.array_indices_type() == SparseIndexVector::Uint16Vector {
                self.array_indices().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Uint16Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn array_indices_as_uint_8_vector(&self) -> Option<Uint8Vector<'a>> {
            if self.array_indices_type() == SparseIndexVector::Uint8Vector {
                self.array_indices().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Uint8Vector::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for DimensionMetadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<DimensionType>("format", Self::VT_FORMAT, false)?
                .visit_field::<i32>("dense_size", Self::VT_DENSE_SIZE, false)?
                .visit_union::<SparseIndexVector, _>(
                    "array_segments_type",
                    Self::VT_ARRAY_SEGMENTS_TYPE,
                    "array_segments",
                    Self::VT_ARRAY_SEGMENTS,
                    false,
                    |key, v, pos| match key {
                        SparseIndexVector::Int32Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Int32Vector>>(
                                "SparseIndexVector::Int32Vector",
                                pos,
                            ),
                        SparseIndexVector::Uint16Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Uint16Vector>>(
                                "SparseIndexVector::Uint16Vector",
                                pos,
                            ),
                        SparseIndexVector::Uint8Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Uint8Vector>>(
                                "SparseIndexVector::Uint8Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .visit_union::<SparseIndexVector, _>(
                    "array_indices_type",
                    Self::VT_ARRAY_INDICES_TYPE,
                    "array_indices",
                    Self::VT_ARRAY_INDICES,
                    false,
                    |key, v, pos| match key {
                        SparseIndexVector::Int32Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Int32Vector>>(
                                "SparseIndexVector::Int32Vector",
                                pos,
                            ),
                        SparseIndexVector::Uint16Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Uint16Vector>>(
                                "SparseIndexVector::Uint16Vector",
                                pos,
                            ),
                        SparseIndexVector::Uint8Vector => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<Uint8Vector>>(
                                "SparseIndexVector::Uint8Vector",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DimensionMetadataArgs {
        pub format: DimensionType,
        pub dense_size: i32,
        pub array_segments_type: SparseIndexVector,
        pub array_segments: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub array_indices_type: SparseIndexVector,
        pub array_indices: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for DimensionMetadataArgs {
        #[inline]
        fn default() -> Self {
            DimensionMetadataArgs {
                format: DimensionType::DENSE,
                dense_size: 0,
                array_segments_type: SparseIndexVector::NONE,
                array_segments: None,
                array_indices_type: SparseIndexVector::NONE,
                array_indices: None,
            }
        }
    }

    pub struct DimensionMetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DimensionMetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_format(&mut self, format: DimensionType) {
            self.fbb_.push_slot::<DimensionType>(
                DimensionMetadata::VT_FORMAT,
                format,
                DimensionType::DENSE,
            );
        }
        #[inline]
        pub fn add_dense_size(&mut self, dense_size: i32) {
            self.fbb_
                .push_slot::<i32>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
        }
        #[inline]
        pub fn add_array_segments_type(&mut self, array_segments_type: SparseIndexVector) {
            self.fbb_.push_slot::<SparseIndexVector>(
                DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE,
                array_segments_type,
                SparseIndexVector::NONE,
            );
        }
        #[inline]
        pub fn add_array_segments(
            &mut self,
            array_segments: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DimensionMetadata::VT_ARRAY_SEGMENTS,
                array_segments,
            );
        }
        #[inline]
        pub fn add_array_indices_type(&mut self, array_indices_type: SparseIndexVector) {
            self.fbb_.push_slot::<SparseIndexVector>(
                DimensionMetadata::VT_ARRAY_INDICES_TYPE,
                array_indices_type,
                SparseIndexVector::NONE,
            );
        }
        #[inline]
        pub fn add_array_indices(
            &mut self,
            array_indices: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                DimensionMetadata::VT_ARRAY_INDICES,
                array_indices,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DimensionMetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DimensionMetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DimensionMetadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DimensionMetadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DimensionMetadata");
            ds.field("format", &self.format());
            ds.field("dense_size", &self.dense_size());
            ds.field("array_segments_type", &self.array_segments_type());
            match self.array_segments_type() {
                SparseIndexVector::Int32Vector => {
                    if let Some(x) = self.array_segments_as_int_32_vector() {
                        ds.field("array_segments", &x)
                    } else {
                        ds.field(
                            "array_segments",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                SparseIndexVector::Uint16Vector => {
                    if let Some(x) = self.array_segments_as_uint_16_vector() {
                        ds.field("array_segments", &x)
                    } else {
                        ds.field(
                            "array_segments",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                SparseIndexVector::Uint8Vector => {
                    if let Some(x) = self.array_segments_as_uint_8_vector() {
                        ds.field("array_segments", &x)
                    } else {
                        ds.field(
                            "array_segments",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("array_segments", &x)
                }
            };
            ds.field("array_indices_type", &self.array_indices_type());
            match self.array_indices_type() {
                SparseIndexVector::Int32Vector => {
                    if let Some(x) = self.array_indices_as_int_32_vector() {
                        ds.field("array_indices", &x)
                    } else {
                        ds.field(
                            "array_indices",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                SparseIndexVector::Uint16Vector => {
                    if let Some(x) = self.array_indices_as_uint_16_vector() {
                        ds.field("array_indices", &x)
                    } else {
                        ds.field(
                            "array_indices",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                SparseIndexVector::Uint8Vector => {
                    if let Some(x) = self.array_indices_as_uint_8_vector() {
                        ds.field("array_indices", &x)
                    } else {
                        ds.field(
                            "array_indices",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("array_indices", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum SparsityParametersOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SparsityParameters<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SparsityParameters<'a> {
        type Inner = SparsityParameters<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SparsityParameters<'a> {
        pub const VT_TRAVERSAL_ORDER: flatbuffers::VOffsetT = 4;
        pub const VT_BLOCK_MAP: flatbuffers::VOffsetT = 6;
        pub const VT_DIM_METADATA: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SparsityParameters { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SparsityParametersArgs<'args>,
        ) -> flatbuffers::WIPOffset<SparsityParameters<'bldr>> {
            let mut builder = SparsityParametersBuilder::new(_fbb);
            if let Some(x) = args.dim_metadata {
                builder.add_dim_metadata(x);
            }
            if let Some(x) = args.block_map {
                builder.add_block_map(x);
            }
            if let Some(x) = args.traversal_order {
                builder.add_traversal_order(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn traversal_order(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        SparsityParameters::VT_TRAVERSAL_ORDER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn block_map(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        SparsityParameters::VT_BLOCK_MAP,
                        None,
                    )
            }
        }
        #[inline]
        pub fn dim_metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata>>,
                >>(SparsityParameters::VT_DIM_METADATA, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SparsityParameters<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "traversal_order",
                    Self::VT_TRAVERSAL_ORDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "block_map",
                    Self::VT_BLOCK_MAP,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DimensionMetadata>>,
                >>("dim_metadata", Self::VT_DIM_METADATA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SparsityParametersArgs<'a> {
        pub traversal_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub block_map: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub dim_metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DimensionMetadata<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SparsityParametersArgs<'a> {
        #[inline]
        fn default() -> Self {
            SparsityParametersArgs {
                traversal_order: None,
                block_map: None,
                dim_metadata: None,
            }
        }
    }

    pub struct SparsityParametersBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SparsityParametersBuilder<'a, 'b> {
        #[inline]
        pub fn add_traversal_order(
            &mut self,
            traversal_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SparsityParameters::VT_TRAVERSAL_ORDER,
                traversal_order,
            );
        }
        #[inline]
        pub fn add_block_map(
            &mut self,
            block_map: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SparsityParameters::VT_BLOCK_MAP,
                block_map,
            );
        }
        #[inline]
        pub fn add_dim_metadata(
            &mut self,
            dim_metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DimensionMetadata<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SparsityParameters::VT_DIM_METADATA,
                dim_metadata,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SparsityParametersBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SparsityParametersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SparsityParameters<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SparsityParameters<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SparsityParameters");
            ds.field("traversal_order", &self.traversal_order());
            ds.field("block_map", &self.block_map());
            ds.field("dim_metadata", &self.dim_metadata());
            ds.finish()
        }
    }
    pub enum VariantSubTypeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VariantSubType<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VariantSubType<'a> {
        type Inner = VariantSubType<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VariantSubType<'a> {
        pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_HAS_RANK: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VariantSubType { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VariantSubTypeArgs<'args>,
        ) -> flatbuffers::WIPOffset<VariantSubType<'bldr>> {
            let mut builder = VariantSubTypeBuilder::new(_fbb);
            if let Some(x) = args.shape {
                builder.add_shape(x);
            }
            builder.add_has_rank(args.has_rank);
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        VariantSubType::VT_SHAPE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn type_(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(VariantSubType::VT_TYPE_, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
        #[inline]
        pub fn has_rank(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(VariantSubType::VT_HAS_RANK, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for VariantSubType<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "shape",
                    Self::VT_SHAPE,
                    false,
                )?
                .visit_field::<TensorType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<bool>("has_rank", Self::VT_HAS_RANK, false)?
                .finish();
            Ok(())
        }
    }
    pub struct VariantSubTypeArgs<'a> {
        pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub type_: TensorType,
        pub has_rank: bool,
    }
    impl<'a> Default for VariantSubTypeArgs<'a> {
        #[inline]
        fn default() -> Self {
            VariantSubTypeArgs {
                shape: None,
                type_: TensorType::FLOAT32,
                has_rank: false,
            }
        }
    }

    pub struct VariantSubTypeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VariantSubTypeBuilder<'a, 'b> {
        #[inline]
        pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(VariantSubType::VT_SHAPE, shape);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: TensorType) {
            self.fbb_
                .push_slot::<TensorType>(VariantSubType::VT_TYPE_, type_, TensorType::FLOAT32);
        }
        #[inline]
        pub fn add_has_rank(&mut self, has_rank: bool) {
            self.fbb_
                .push_slot::<bool>(VariantSubType::VT_HAS_RANK, has_rank, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VariantSubTypeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VariantSubTypeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VariantSubType<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VariantSubType<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VariantSubType");
            ds.field("shape", &self.shape());
            ds.field("type_", &self.type_());
            ds.field("has_rank", &self.has_rank());
            ds.finish()
        }
    }
    pub enum TensorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Tensor<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
        type Inner = Tensor<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Tensor<'a> {
        pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_BUFFER: flatbuffers::VOffsetT = 8;
        pub const VT_NAME: flatbuffers::VOffsetT = 10;
        pub const VT_QUANTIZATION: flatbuffers::VOffsetT = 12;
        pub const VT_IS_VARIABLE: flatbuffers::VOffsetT = 14;
        pub const VT_SPARSITY: flatbuffers::VOffsetT = 16;
        pub const VT_SHAPE_SIGNATURE: flatbuffers::VOffsetT = 18;
        pub const VT_HAS_RANK: flatbuffers::VOffsetT = 20;
        pub const VT_VARIANT_TENSORS: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Tensor { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TensorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
            let mut builder = TensorBuilder::new(_fbb);
            if let Some(x) = args.variant_tensors {
                builder.add_variant_tensors(x);
            }
            if let Some(x) = args.shape_signature {
                builder.add_shape_signature(x);
            }
            if let Some(x) = args.sparsity {
                builder.add_sparsity(x);
            }
            if let Some(x) = args.quantization {
                builder.add_quantization(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_buffer(args.buffer);
            if let Some(x) = args.shape {
                builder.add_shape(x);
            }
            builder.add_has_rank(args.has_rank);
            builder.add_is_variable(args.is_variable);
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Tensor::VT_SHAPE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn type_(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(Tensor::VT_TYPE_, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
        #[inline]
        pub fn buffer(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Tensor::VT_BUFFER, Some(0)).unwrap() }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Tensor::VT_NAME, None)
            }
        }
        #[inline]
        pub fn quantization(&self) -> Option<QuantizationParameters<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<QuantizationParameters>>(
                        Tensor::VT_QUANTIZATION,
                        None,
                    )
            }
        }
        #[inline]
        pub fn is_variable(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Tensor::VT_IS_VARIABLE, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn sparsity(&self) -> Option<SparsityParameters<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<SparsityParameters>>(
                        Tensor::VT_SPARSITY,
                        None,
                    )
            }
        }
        #[inline]
        pub fn shape_signature(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Tensor::VT_SHAPE_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn has_rank(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(Tensor::VT_HAS_RANK, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn variant_tensors(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType>>,
                >>(Tensor::VT_VARIANT_TENSORS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Tensor<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "shape",
                    Self::VT_SHAPE,
                    false,
                )?
                .visit_field::<TensorType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<QuantizationParameters>>(
                    "quantization",
                    Self::VT_QUANTIZATION,
                    false,
                )?
                .visit_field::<bool>("is_variable", Self::VT_IS_VARIABLE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<SparsityParameters>>(
                    "sparsity",
                    Self::VT_SPARSITY,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "shape_signature",
                    Self::VT_SHAPE_SIGNATURE,
                    false,
                )?
                .visit_field::<bool>("has_rank", Self::VT_HAS_RANK, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VariantSubType>>,
                >>("variant_tensors", Self::VT_VARIANT_TENSORS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TensorArgs<'a> {
        pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub type_: TensorType,
        pub buffer: u32,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub quantization: Option<flatbuffers::WIPOffset<QuantizationParameters<'a>>>,
        pub is_variable: bool,
        pub sparsity: Option<flatbuffers::WIPOffset<SparsityParameters<'a>>>,
        pub shape_signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub has_rank: bool,
        pub variant_tensors: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariantSubType<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TensorArgs<'a> {
        #[inline]
        fn default() -> Self {
            TensorArgs {
                shape: None,
                type_: TensorType::FLOAT32,
                buffer: 0,
                name: None,
                quantization: None,
                is_variable: false,
                sparsity: None,
                shape_signature: None,
                has_rank: false,
                variant_tensors: None,
            }
        }
    }

    pub struct TensorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
        #[inline]
        pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);
        }
        #[inline]
        pub fn add_type_(&mut self, type_: TensorType) {
            self.fbb_
                .push_slot::<TensorType>(Tensor::VT_TYPE_, type_, TensorType::FLOAT32);
        }
        #[inline]
        pub fn add_buffer(&mut self, buffer: u32) {
            self.fbb_.push_slot::<u32>(Tensor::VT_BUFFER, buffer, 0);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_NAME, name);
        }
        #[inline]
        pub fn add_quantization(
            &mut self,
            quantization: flatbuffers::WIPOffset<QuantizationParameters<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<QuantizationParameters>>(
                    Tensor::VT_QUANTIZATION,
                    quantization,
                );
        }
        #[inline]
        pub fn add_is_variable(&mut self, is_variable: bool) {
            self.fbb_
                .push_slot::<bool>(Tensor::VT_IS_VARIABLE, is_variable, false);
        }
        #[inline]
        pub fn add_sparsity(&mut self, sparsity: flatbuffers::WIPOffset<SparsityParameters<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<SparsityParameters>>(
                    Tensor::VT_SPARSITY,
                    sparsity,
                );
        }
        #[inline]
        pub fn add_shape_signature(
            &mut self,
            shape_signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Tensor::VT_SHAPE_SIGNATURE,
                shape_signature,
            );
        }
        #[inline]
        pub fn add_has_rank(&mut self, has_rank: bool) {
            self.fbb_
                .push_slot::<bool>(Tensor::VT_HAS_RANK, has_rank, false);
        }
        #[inline]
        pub fn add_variant_tensors(
            &mut self,
            variant_tensors: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<VariantSubType<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Tensor::VT_VARIANT_TENSORS,
                variant_tensors,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TensorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Tensor<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Tensor");
            ds.field("shape", &self.shape());
            ds.field("type_", &self.type_());
            ds.field("buffer", &self.buffer());
            ds.field("name", &self.name());
            ds.field("quantization", &self.quantization());
            ds.field("is_variable", &self.is_variable());
            ds.field("sparsity", &self.sparsity());
            ds.field("shape_signature", &self.shape_signature());
            ds.field("has_rank", &self.has_rank());
            ds.field("variant_tensors", &self.variant_tensors());
            ds.finish()
        }
    }
    pub enum Conv2DOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Conv2DOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Conv2DOptions<'a> {
        type Inner = Conv2DOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Conv2DOptions<'a> {
        pub const VT_PADDING: flatbuffers::VOffsetT = 4;
        pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
        pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 10;
        pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 12;
        pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Conv2DOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Conv2DOptionsArgs,
        ) -> flatbuffers::WIPOffset<Conv2DOptions<'bldr>> {
            let mut builder = Conv2DOptionsBuilder::new(_fbb);
            builder.add_dilation_h_factor(args.dilation_h_factor);
            builder.add_dilation_w_factor(args.dilation_w_factor);
            builder.add_stride_h(args.stride_h);
            builder.add_stride_w(args.stride_w);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_padding(args.padding);
            builder.finish()
        }

        #[inline]
        pub fn padding(&self) -> Padding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Padding>(Conv2DOptions::VT_PADDING, Some(Padding::SAME))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_w(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv2DOptions::VT_STRIDE_W, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_h(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv2DOptions::VT_STRIDE_H, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_w_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, Some(1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_h_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, Some(1))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Conv2DOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
                .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
                .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
                .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
                .finish();
            Ok(())
        }
    }
    pub struct Conv2DOptionsArgs {
        pub padding: Padding,
        pub stride_w: i32,
        pub stride_h: i32,
        pub fused_activation_function: ActivationFunctionType,
        pub dilation_w_factor: i32,
        pub dilation_h_factor: i32,
    }
    impl<'a> Default for Conv2DOptionsArgs {
        #[inline]
        fn default() -> Self {
            Conv2DOptionsArgs {
                padding: Padding::SAME,
                stride_w: 0,
                stride_h: 0,
                fused_activation_function: ActivationFunctionType::NONE,
                dilation_w_factor: 1,
                dilation_h_factor: 1,
            }
        }
    }

    pub struct Conv2DOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Conv2DOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_padding(&mut self, padding: Padding) {
            self.fbb_
                .push_slot::<Padding>(Conv2DOptions::VT_PADDING, padding, Padding::SAME);
        }
        #[inline]
        pub fn add_stride_w(&mut self, stride_w: i32) {
            self.fbb_
                .push_slot::<i32>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
        }
        #[inline]
        pub fn add_stride_h(&mut self, stride_h: i32) {
            self.fbb_
                .push_slot::<i32>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
            self.fbb_
                .push_slot::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
        }
        #[inline]
        pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
            self.fbb_
                .push_slot::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> Conv2DOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Conv2DOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Conv2DOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Conv2DOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Conv2DOptions");
            ds.field("padding", &self.padding());
            ds.field("stride_w", &self.stride_w());
            ds.field("stride_h", &self.stride_h());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("dilation_w_factor", &self.dilation_w_factor());
            ds.field("dilation_h_factor", &self.dilation_h_factor());
            ds.finish()
        }
    }
    pub enum Conv3DOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Conv3DOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Conv3DOptions<'a> {
        type Inner = Conv3DOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Conv3DOptions<'a> {
        pub const VT_PADDING: flatbuffers::VOffsetT = 4;
        pub const VT_STRIDE_D: flatbuffers::VOffsetT = 6;
        pub const VT_STRIDE_W: flatbuffers::VOffsetT = 8;
        pub const VT_STRIDE_H: flatbuffers::VOffsetT = 10;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 12;
        pub const VT_DILATION_D_FACTOR: flatbuffers::VOffsetT = 14;
        pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 16;
        pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Conv3DOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Conv3DOptionsArgs,
        ) -> flatbuffers::WIPOffset<Conv3DOptions<'bldr>> {
            let mut builder = Conv3DOptionsBuilder::new(_fbb);
            builder.add_dilation_h_factor(args.dilation_h_factor);
            builder.add_dilation_w_factor(args.dilation_w_factor);
            builder.add_dilation_d_factor(args.dilation_d_factor);
            builder.add_stride_h(args.stride_h);
            builder.add_stride_w(args.stride_w);
            builder.add_stride_d(args.stride_d);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_padding(args.padding);
            builder.finish()
        }

        #[inline]
        pub fn padding(&self) -> Padding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Padding>(Conv3DOptions::VT_PADDING, Some(Padding::SAME))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_d(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_STRIDE_D, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_w(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_STRIDE_W, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_h(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_STRIDE_H, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_d_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_DILATION_D_FACTOR, Some(1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_w_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_DILATION_W_FACTOR, Some(1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_h_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Conv3DOptions::VT_DILATION_H_FACTOR, Some(1))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Conv3DOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
                .visit_field::<i32>("stride_d", Self::VT_STRIDE_D, false)?
                .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
                .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<i32>("dilation_d_factor", Self::VT_DILATION_D_FACTOR, false)?
                .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
                .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
                .finish();
            Ok(())
        }
    }
    pub struct Conv3DOptionsArgs {
        pub padding: Padding,
        pub stride_d: i32,
        pub stride_w: i32,
        pub stride_h: i32,
        pub fused_activation_function: ActivationFunctionType,
        pub dilation_d_factor: i32,
        pub dilation_w_factor: i32,
        pub dilation_h_factor: i32,
    }
    impl<'a> Default for Conv3DOptionsArgs {
        #[inline]
        fn default() -> Self {
            Conv3DOptionsArgs {
                padding: Padding::SAME,
                stride_d: 0,
                stride_w: 0,
                stride_h: 0,
                fused_activation_function: ActivationFunctionType::NONE,
                dilation_d_factor: 1,
                dilation_w_factor: 1,
                dilation_h_factor: 1,
            }
        }
    }

    pub struct Conv3DOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Conv3DOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_padding(&mut self, padding: Padding) {
            self.fbb_
                .push_slot::<Padding>(Conv3DOptions::VT_PADDING, padding, Padding::SAME);
        }
        #[inline]
        pub fn add_stride_d(&mut self, stride_d: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
        }
        #[inline]
        pub fn add_stride_w(&mut self, stride_w: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
        }
        #[inline]
        pub fn add_stride_h(&mut self, stride_h: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_dilation_d_factor(&mut self, dilation_d_factor: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
        }
        #[inline]
        pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
        }
        #[inline]
        pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
            self.fbb_
                .push_slot::<i32>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> Conv3DOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Conv3DOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Conv3DOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Conv3DOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Conv3DOptions");
            ds.field("padding", &self.padding());
            ds.field("stride_d", &self.stride_d());
            ds.field("stride_w", &self.stride_w());
            ds.field("stride_h", &self.stride_h());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("dilation_d_factor", &self.dilation_d_factor());
            ds.field("dilation_w_factor", &self.dilation_w_factor());
            ds.field("dilation_h_factor", &self.dilation_h_factor());
            ds.finish()
        }
    }
    pub enum Pool2DOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Pool2DOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Pool2DOptions<'a> {
        type Inner = Pool2DOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Pool2DOptions<'a> {
        pub const VT_PADDING: flatbuffers::VOffsetT = 4;
        pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
        pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
        pub const VT_FILTER_WIDTH: flatbuffers::VOffsetT = 10;
        pub const VT_FILTER_HEIGHT: flatbuffers::VOffsetT = 12;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Pool2DOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args Pool2DOptionsArgs,
        ) -> flatbuffers::WIPOffset<Pool2DOptions<'bldr>> {
            let mut builder = Pool2DOptionsBuilder::new(_fbb);
            builder.add_filter_height(args.filter_height);
            builder.add_filter_width(args.filter_width);
            builder.add_stride_h(args.stride_h);
            builder.add_stride_w(args.stride_w);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_padding(args.padding);
            builder.finish()
        }

        #[inline]
        pub fn padding(&self) -> Padding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Padding>(Pool2DOptions::VT_PADDING, Some(Padding::SAME))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_w(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Pool2DOptions::VT_STRIDE_W, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_h(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Pool2DOptions::VT_STRIDE_H, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn filter_width(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Pool2DOptions::VT_FILTER_WIDTH, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn filter_height(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for Pool2DOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
                .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
                .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
                .visit_field::<i32>("filter_width", Self::VT_FILTER_WIDTH, false)?
                .visit_field::<i32>("filter_height", Self::VT_FILTER_HEIGHT, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct Pool2DOptionsArgs {
        pub padding: Padding,
        pub stride_w: i32,
        pub stride_h: i32,
        pub filter_width: i32,
        pub filter_height: i32,
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for Pool2DOptionsArgs {
        #[inline]
        fn default() -> Self {
            Pool2DOptionsArgs {
                padding: Padding::SAME,
                stride_w: 0,
                stride_h: 0,
                filter_width: 0,
                filter_height: 0,
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct Pool2DOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Pool2DOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_padding(&mut self, padding: Padding) {
            self.fbb_
                .push_slot::<Padding>(Pool2DOptions::VT_PADDING, padding, Padding::SAME);
        }
        #[inline]
        pub fn add_stride_w(&mut self, stride_w: i32) {
            self.fbb_
                .push_slot::<i32>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
        }
        #[inline]
        pub fn add_stride_h(&mut self, stride_h: i32) {
            self.fbb_
                .push_slot::<i32>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
        }
        #[inline]
        pub fn add_filter_width(&mut self, filter_width: i32) {
            self.fbb_
                .push_slot::<i32>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
        }
        #[inline]
        pub fn add_filter_height(&mut self, filter_height: i32) {
            self.fbb_
                .push_slot::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> Pool2DOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Pool2DOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Pool2DOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Pool2DOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Pool2DOptions");
            ds.field("padding", &self.padding());
            ds.field("stride_w", &self.stride_w());
            ds.field("stride_h", &self.stride_h());
            ds.field("filter_width", &self.filter_width());
            ds.field("filter_height", &self.filter_height());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum DepthwiseConv2DOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DepthwiseConv2DOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DepthwiseConv2DOptions<'a> {
        type Inner = DepthwiseConv2DOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DepthwiseConv2DOptions<'a> {
        pub const VT_PADDING: flatbuffers::VOffsetT = 4;
        pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
        pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
        pub const VT_DEPTH_MULTIPLIER: flatbuffers::VOffsetT = 10;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 12;
        pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 14;
        pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DepthwiseConv2DOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DepthwiseConv2DOptionsArgs,
        ) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'bldr>> {
            let mut builder = DepthwiseConv2DOptionsBuilder::new(_fbb);
            builder.add_dilation_h_factor(args.dilation_h_factor);
            builder.add_dilation_w_factor(args.dilation_w_factor);
            builder.add_depth_multiplier(args.depth_multiplier);
            builder.add_stride_h(args.stride_h);
            builder.add_stride_w(args.stride_w);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_padding(args.padding);
            builder.finish()
        }

        #[inline]
        pub fn padding(&self) -> Padding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Padding>(DepthwiseConv2DOptions::VT_PADDING, Some(Padding::SAME))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_w(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_h(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn depth_multiplier(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_w_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, Some(1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn dilation_h_factor(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, Some(1))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DepthwiseConv2DOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
                .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
                .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
                .visit_field::<i32>("depth_multiplier", Self::VT_DEPTH_MULTIPLIER, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
                .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DepthwiseConv2DOptionsArgs {
        pub padding: Padding,
        pub stride_w: i32,
        pub stride_h: i32,
        pub depth_multiplier: i32,
        pub fused_activation_function: ActivationFunctionType,
        pub dilation_w_factor: i32,
        pub dilation_h_factor: i32,
    }
    impl<'a> Default for DepthwiseConv2DOptionsArgs {
        #[inline]
        fn default() -> Self {
            DepthwiseConv2DOptionsArgs {
                padding: Padding::SAME,
                stride_w: 0,
                stride_h: 0,
                depth_multiplier: 0,
                fused_activation_function: ActivationFunctionType::NONE,
                dilation_w_factor: 1,
                dilation_h_factor: 1,
            }
        }
    }

    pub struct DepthwiseConv2DOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DepthwiseConv2DOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_padding(&mut self, padding: Padding) {
            self.fbb_.push_slot::<Padding>(
                DepthwiseConv2DOptions::VT_PADDING,
                padding,
                Padding::SAME,
            );
        }
        #[inline]
        pub fn add_stride_w(&mut self, stride_w: i32) {
            self.fbb_
                .push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
        }
        #[inline]
        pub fn add_stride_h(&mut self, stride_h: i32) {
            self.fbb_
                .push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
        }
        #[inline]
        pub fn add_depth_multiplier(&mut self, depth_multiplier: i32) {
            self.fbb_.push_slot::<i32>(
                DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER,
                depth_multiplier,
                0,
            );
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
            self.fbb_.push_slot::<i32>(
                DepthwiseConv2DOptions::VT_DILATION_W_FACTOR,
                dilation_w_factor,
                1,
            );
        }
        #[inline]
        pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
            self.fbb_.push_slot::<i32>(
                DepthwiseConv2DOptions::VT_DILATION_H_FACTOR,
                dilation_h_factor,
                1,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DepthwiseConv2DOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DepthwiseConv2DOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DepthwiseConv2DOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DepthwiseConv2DOptions");
            ds.field("padding", &self.padding());
            ds.field("stride_w", &self.stride_w());
            ds.field("stride_h", &self.stride_h());
            ds.field("depth_multiplier", &self.depth_multiplier());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("dilation_w_factor", &self.dilation_w_factor());
            ds.field("dilation_h_factor", &self.dilation_h_factor());
            ds.finish()
        }
    }
    pub enum ConcatEmbeddingsOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ConcatEmbeddingsOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConcatEmbeddingsOptions<'a> {
        type Inner = ConcatEmbeddingsOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ConcatEmbeddingsOptions<'a> {
        pub const VT_NUM_CHANNELS: flatbuffers::VOffsetT = 4;
        pub const VT_NUM_COLUMNS_PER_CHANNEL: flatbuffers::VOffsetT = 6;
        pub const VT_EMBEDDING_DIM_PER_CHANNEL: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConcatEmbeddingsOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConcatEmbeddingsOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'bldr>> {
            let mut builder = ConcatEmbeddingsOptionsBuilder::new(_fbb);
            if let Some(x) = args.embedding_dim_per_channel {
                builder.add_embedding_dim_per_channel(x);
            }
            if let Some(x) = args.num_columns_per_channel {
                builder.add_num_columns_per_channel(x);
            }
            builder.add_num_channels(args.num_channels);
            builder.finish()
        }

        #[inline]
        pub fn num_channels(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn num_columns_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL,
                        None,
                    )
            }
        }
        #[inline]
        pub fn embedding_dim_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for ConcatEmbeddingsOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("num_channels", Self::VT_NUM_CHANNELS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "num_columns_per_channel",
                    Self::VT_NUM_COLUMNS_PER_CHANNEL,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "embedding_dim_per_channel",
                    Self::VT_EMBEDDING_DIM_PER_CHANNEL,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ConcatEmbeddingsOptionsArgs<'a> {
        pub num_channels: i32,
        pub num_columns_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub embedding_dim_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    }
    impl<'a> Default for ConcatEmbeddingsOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConcatEmbeddingsOptionsArgs {
                num_channels: 0,
                num_columns_per_channel: None,
                embedding_dim_per_channel: None,
            }
        }
    }

    pub struct ConcatEmbeddingsOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_num_channels(&mut self, num_channels: i32) {
            self.fbb_
                .push_slot::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
        }
        #[inline]
        pub fn add_num_columns_per_channel(
            &mut self,
            num_columns_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL,
                num_columns_per_channel,
            );
        }
        #[inline]
        pub fn add_embedding_dim_per_channel(
            &mut self,
            embedding_dim_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL,
                embedding_dim_per_channel,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConcatEmbeddingsOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ConcatEmbeddingsOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ConcatEmbeddingsOptions");
            ds.field("num_channels", &self.num_channels());
            ds.field("num_columns_per_channel", &self.num_columns_per_channel());
            ds.field(
                "embedding_dim_per_channel",
                &self.embedding_dim_per_channel(),
            );
            ds.finish()
        }
    }
    pub enum LSHProjectionOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LSHProjectionOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LSHProjectionOptions<'a> {
        type Inner = LSHProjectionOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LSHProjectionOptions<'a> {
        pub const VT_TYPE_: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LSHProjectionOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LSHProjectionOptionsArgs,
        ) -> flatbuffers::WIPOffset<LSHProjectionOptions<'bldr>> {
            let mut builder = LSHProjectionOptionsBuilder::new(_fbb);
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn type_(&self) -> LSHProjectionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<LSHProjectionType>(
                        LSHProjectionOptions::VT_TYPE_,
                        Some(LSHProjectionType::UNKNOWN),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for LSHProjectionOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<LSHProjectionType>("type_", Self::VT_TYPE_, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LSHProjectionOptionsArgs {
        pub type_: LSHProjectionType,
    }
    impl<'a> Default for LSHProjectionOptionsArgs {
        #[inline]
        fn default() -> Self {
            LSHProjectionOptionsArgs {
                type_: LSHProjectionType::UNKNOWN,
            }
        }
    }

    pub struct LSHProjectionOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LSHProjectionOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_type_(&mut self, type_: LSHProjectionType) {
            self.fbb_.push_slot::<LSHProjectionType>(
                LSHProjectionOptions::VT_TYPE_,
                type_,
                LSHProjectionType::UNKNOWN,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LSHProjectionOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LSHProjectionOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LSHProjectionOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LSHProjectionOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LSHProjectionOptions");
            ds.field("type_", &self.type_());
            ds.finish()
        }
    }
    pub enum SVDFOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SVDFOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SVDFOptions<'a> {
        type Inner = SVDFOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SVDFOptions<'a> {
        pub const VT_RANK: flatbuffers::VOffsetT = 4;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SVDFOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SVDFOptionsArgs,
        ) -> flatbuffers::WIPOffset<SVDFOptions<'bldr>> {
            let mut builder = SVDFOptionsBuilder::new(_fbb);
            builder.add_rank(args.rank);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn rank(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(SVDFOptions::VT_RANK, Some(0)).unwrap() }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SVDFOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("rank", Self::VT_RANK, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SVDFOptionsArgs {
        pub rank: i32,
        pub fused_activation_function: ActivationFunctionType,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for SVDFOptionsArgs {
        #[inline]
        fn default() -> Self {
            SVDFOptionsArgs {
                rank: 0,
                fused_activation_function: ActivationFunctionType::NONE,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct SVDFOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SVDFOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_rank(&mut self, rank: i32) {
            self.fbb_.push_slot::<i32>(SVDFOptions::VT_RANK, rank, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SVDFOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SVDFOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SVDFOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SVDFOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SVDFOptions");
            ds.field("rank", &self.rank());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum RNNOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RNNOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RNNOptions<'a> {
        type Inner = RNNOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RNNOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RNNOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RNNOptionsArgs,
        ) -> flatbuffers::WIPOffset<RNNOptions<'bldr>> {
            let mut builder = RNNOptionsBuilder::new(_fbb);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RNNOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct RNNOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for RNNOptionsArgs {
        #[inline]
        fn default() -> Self {
            RNNOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct RNNOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RNNOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                RNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RNNOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RNNOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RNNOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RNNOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RNNOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum SequenceRNNOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SequenceRNNOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SequenceRNNOptions<'a> {
        type Inner = SequenceRNNOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SequenceRNNOptions<'a> {
        pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SequenceRNNOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SequenceRNNOptionsArgs,
        ) -> flatbuffers::WIPOffset<SequenceRNNOptions<'bldr>> {
            let mut builder = SequenceRNNOptionsBuilder::new(_fbb);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_time_major(args.time_major);
            builder.finish()
        }

        #[inline]
        pub fn time_major(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SequenceRNNOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SequenceRNNOptionsArgs {
        pub time_major: bool,
        pub fused_activation_function: ActivationFunctionType,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for SequenceRNNOptionsArgs {
        #[inline]
        fn default() -> Self {
            SequenceRNNOptionsArgs {
                time_major: false,
                fused_activation_function: ActivationFunctionType::NONE,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct SequenceRNNOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SequenceRNNOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_time_major(&mut self, time_major: bool) {
            self.fbb_
                .push_slot::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, time_major, false);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SequenceRNNOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SequenceRNNOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SequenceRNNOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SequenceRNNOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SequenceRNNOptions");
            ds.field("time_major", &self.time_major());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum BidirectionalSequenceRNNOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BidirectionalSequenceRNNOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceRNNOptions<'a> {
        type Inner = BidirectionalSequenceRNNOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BidirectionalSequenceRNNOptions<'a> {
        pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
        pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 8;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BidirectionalSequenceRNNOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BidirectionalSequenceRNNOptionsArgs,
        ) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'bldr>> {
            let mut builder = BidirectionalSequenceRNNOptionsBuilder::new(_fbb);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_merge_outputs(args.merge_outputs);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_time_major(args.time_major);
            builder.finish()
        }

        #[inline]
        pub fn time_major(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn merge_outputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BidirectionalSequenceRNNOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BidirectionalSequenceRNNOptionsArgs {
        pub time_major: bool,
        pub fused_activation_function: ActivationFunctionType,
        pub merge_outputs: bool,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for BidirectionalSequenceRNNOptionsArgs {
        #[inline]
        fn default() -> Self {
            BidirectionalSequenceRNNOptionsArgs {
                time_major: false,
                fused_activation_function: ActivationFunctionType::NONE,
                merge_outputs: false,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct BidirectionalSequenceRNNOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_time_major(&mut self, time_major: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceRNNOptions::VT_TIME_MAJOR,
                time_major,
                false,
            );
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS,
                merge_outputs,
                false,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BidirectionalSequenceRNNOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BidirectionalSequenceRNNOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BidirectionalSequenceRNNOptions");
            ds.field("time_major", &self.time_major());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("merge_outputs", &self.merge_outputs());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum FullyConnectedOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FullyConnectedOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptions<'a> {
        type Inner = FullyConnectedOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FullyConnectedOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_WEIGHTS_FORMAT: flatbuffers::VOffsetT = 6;
        pub const VT_KEEP_NUM_DIMS: flatbuffers::VOffsetT = 8;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FullyConnectedOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FullyConnectedOptionsArgs,
        ) -> flatbuffers::WIPOffset<FullyConnectedOptions<'bldr>> {
            let mut builder = FullyConnectedOptionsBuilder::new(_fbb);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_keep_num_dims(args.keep_num_dims);
            builder.add_weights_format(args.weights_format);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn weights_format(&self) -> FullyConnectedOptionsWeightsFormat {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<FullyConnectedOptionsWeightsFormat>(
                        FullyConnectedOptions::VT_WEIGHTS_FORMAT,
                        Some(FullyConnectedOptionsWeightsFormat::DEFAULT),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn keep_num_dims(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for FullyConnectedOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<FullyConnectedOptionsWeightsFormat>(
                    "weights_format",
                    Self::VT_WEIGHTS_FORMAT,
                    false,
                )?
                .visit_field::<bool>("keep_num_dims", Self::VT_KEEP_NUM_DIMS, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct FullyConnectedOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub weights_format: FullyConnectedOptionsWeightsFormat,
        pub keep_num_dims: bool,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for FullyConnectedOptionsArgs {
        #[inline]
        fn default() -> Self {
            FullyConnectedOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                weights_format: FullyConnectedOptionsWeightsFormat::DEFAULT,
                keep_num_dims: false,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct FullyConnectedOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FullyConnectedOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_weights_format(&mut self, weights_format: FullyConnectedOptionsWeightsFormat) {
            self.fbb_.push_slot::<FullyConnectedOptionsWeightsFormat>(
                FullyConnectedOptions::VT_WEIGHTS_FORMAT,
                weights_format,
                FullyConnectedOptionsWeightsFormat::DEFAULT,
            );
        }
        #[inline]
        pub fn add_keep_num_dims(&mut self, keep_num_dims: bool) {
            self.fbb_.push_slot::<bool>(
                FullyConnectedOptions::VT_KEEP_NUM_DIMS,
                keep_num_dims,
                false,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FullyConnectedOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FullyConnectedOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FullyConnectedOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FullyConnectedOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FullyConnectedOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("weights_format", &self.weights_format());
            ds.field("keep_num_dims", &self.keep_num_dims());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum SoftmaxOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SoftmaxOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SoftmaxOptions<'a> {
        type Inner = SoftmaxOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SoftmaxOptions<'a> {
        pub const VT_BETA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SoftmaxOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SoftmaxOptionsArgs,
        ) -> flatbuffers::WIPOffset<SoftmaxOptions<'bldr>> {
            let mut builder = SoftmaxOptionsBuilder::new(_fbb);
            builder.add_beta(args.beta);
            builder.finish()
        }

        #[inline]
        pub fn beta(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(SoftmaxOptions::VT_BETA, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SoftmaxOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f32>("beta", Self::VT_BETA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SoftmaxOptionsArgs {
        pub beta: f32,
    }
    impl<'a> Default for SoftmaxOptionsArgs {
        #[inline]
        fn default() -> Self {
            SoftmaxOptionsArgs { beta: 0.0 }
        }
    }

    pub struct SoftmaxOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SoftmaxOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_beta(&mut self, beta: f32) {
            self.fbb_
                .push_slot::<f32>(SoftmaxOptions::VT_BETA, beta, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SoftmaxOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SoftmaxOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SoftmaxOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SoftmaxOptions");
            ds.field("beta", &self.beta());
            ds.finish()
        }
    }
    pub enum ConcatenationOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ConcatenationOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ConcatenationOptions<'a> {
        type Inner = ConcatenationOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ConcatenationOptions<'a> {
        pub const VT_AXIS: flatbuffers::VOffsetT = 4;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ConcatenationOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConcatenationOptionsArgs,
        ) -> flatbuffers::WIPOffset<ConcatenationOptions<'bldr>> {
            let mut builder = ConcatenationOptionsBuilder::new(_fbb);
            builder.add_axis(args.axis);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn axis(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ConcatenationOptions::VT_AXIS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ConcatenationOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("axis", Self::VT_AXIS, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ConcatenationOptionsArgs {
        pub axis: i32,
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for ConcatenationOptionsArgs {
        #[inline]
        fn default() -> Self {
            ConcatenationOptionsArgs {
                axis: 0,
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct ConcatenationOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConcatenationOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_axis(&mut self, axis: i32) {
            self.fbb_
                .push_slot::<i32>(ConcatenationOptions::VT_AXIS, axis, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ConcatenationOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConcatenationOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ConcatenationOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ConcatenationOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ConcatenationOptions");
            ds.field("axis", &self.axis());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum AddOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddOptions<'a> {
        type Inner = AddOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_POT_SCALE_INT16: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AddOptionsArgs,
        ) -> flatbuffers::WIPOffset<AddOptions<'bldr>> {
            let mut builder = AddOptionsBuilder::new(_fbb);
            builder.add_pot_scale_int16(args.pot_scale_int16);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn pot_scale_int16(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(AddOptions::VT_POT_SCALE_INT16, Some(true))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AddOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>("pot_scale_int16", Self::VT_POT_SCALE_INT16, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AddOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub pot_scale_int16: bool,
    }
    impl<'a> Default for AddOptionsArgs {
        #[inline]
        fn default() -> Self {
            AddOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                pot_scale_int16: true,
            }
        }
    }

    pub struct AddOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AddOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                AddOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_pot_scale_int16(&mut self, pot_scale_int16: bool) {
            self.fbb_
                .push_slot::<bool>(AddOptions::VT_POT_SCALE_INT16, pot_scale_int16, true);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AddOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("pot_scale_int16", &self.pot_scale_int16());
            ds.finish()
        }
    }
    pub enum MulOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MulOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MulOptions<'a> {
        type Inner = MulOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MulOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MulOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MulOptionsArgs,
        ) -> flatbuffers::WIPOffset<MulOptions<'bldr>> {
            let mut builder = MulOptionsBuilder::new(_fbb);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for MulOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MulOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for MulOptionsArgs {
        #[inline]
        fn default() -> Self {
            MulOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct MulOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MulOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                MulOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MulOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MulOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MulOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MulOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MulOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum L2NormOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct L2NormOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for L2NormOptions<'a> {
        type Inner = L2NormOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> L2NormOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            L2NormOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args L2NormOptionsArgs,
        ) -> flatbuffers::WIPOffset<L2NormOptions<'bldr>> {
            let mut builder = L2NormOptionsBuilder::new(_fbb);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for L2NormOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct L2NormOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for L2NormOptionsArgs {
        #[inline]
        fn default() -> Self {
            L2NormOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct L2NormOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> L2NormOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> L2NormOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            L2NormOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<L2NormOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for L2NormOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("L2NormOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum LocalResponseNormalizationOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LocalResponseNormalizationOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LocalResponseNormalizationOptions<'a> {
        type Inner = LocalResponseNormalizationOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LocalResponseNormalizationOptions<'a> {
        pub const VT_RADIUS: flatbuffers::VOffsetT = 4;
        pub const VT_BIAS: flatbuffers::VOffsetT = 6;
        pub const VT_ALPHA: flatbuffers::VOffsetT = 8;
        pub const VT_BETA: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LocalResponseNormalizationOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LocalResponseNormalizationOptionsArgs,
        ) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'bldr>> {
            let mut builder = LocalResponseNormalizationOptionsBuilder::new(_fbb);
            builder.add_beta(args.beta);
            builder.add_alpha(args.alpha);
            builder.add_bias(args.bias);
            builder.add_radius(args.radius);
            builder.finish()
        }

        #[inline]
        pub fn radius(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn bias(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LocalResponseNormalizationOptions::VT_BIAS, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn alpha(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn beta(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LocalResponseNormalizationOptions::VT_BETA, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for LocalResponseNormalizationOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("radius", Self::VT_RADIUS, false)?
                .visit_field::<f32>("bias", Self::VT_BIAS, false)?
                .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
                .visit_field::<f32>("beta", Self::VT_BETA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LocalResponseNormalizationOptionsArgs {
        pub radius: i32,
        pub bias: f32,
        pub alpha: f32,
        pub beta: f32,
    }
    impl<'a> Default for LocalResponseNormalizationOptionsArgs {
        #[inline]
        fn default() -> Self {
            LocalResponseNormalizationOptionsArgs {
                radius: 0,
                bias: 0.0,
                alpha: 0.0,
                beta: 0.0,
            }
        }
    }

    pub struct LocalResponseNormalizationOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_radius(&mut self, radius: i32) {
            self.fbb_
                .push_slot::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
        }
        #[inline]
        pub fn add_bias(&mut self, bias: f32) {
            self.fbb_
                .push_slot::<f32>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0);
        }
        #[inline]
        pub fn add_alpha(&mut self, alpha: f32) {
            self.fbb_
                .push_slot::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0);
        }
        #[inline]
        pub fn add_beta(&mut self, beta: f32) {
            self.fbb_
                .push_slot::<f32>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LocalResponseNormalizationOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LocalResponseNormalizationOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LocalResponseNormalizationOptions");
            ds.field("radius", &self.radius());
            ds.field("bias", &self.bias());
            ds.field("alpha", &self.alpha());
            ds.field("beta", &self.beta());
            ds.finish()
        }
    }
    pub enum LSTMOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LSTMOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LSTMOptions<'a> {
        type Inner = LSTMOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LSTMOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
        pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
        pub const VT_KERNEL_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LSTMOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LSTMOptionsArgs,
        ) -> flatbuffers::WIPOffset<LSTMOptions<'bldr>> {
            let mut builder = LSTMOptionsBuilder::new(_fbb);
            builder.add_proj_clip(args.proj_clip);
            builder.add_cell_clip(args.cell_clip);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_kernel_type(args.kernel_type);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn cell_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LSTMOptions::VT_CELL_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn proj_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LSTMOptions::VT_PROJ_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn kernel_type(&self) -> LSTMKernelType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<LSTMKernelType>(LSTMOptions::VT_KERNEL_TYPE, Some(LSTMKernelType::FULL))
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for LSTMOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
                .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
                .visit_field::<LSTMKernelType>("kernel_type", Self::VT_KERNEL_TYPE, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct LSTMOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub cell_clip: f32,
        pub proj_clip: f32,
        pub kernel_type: LSTMKernelType,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for LSTMOptionsArgs {
        #[inline]
        fn default() -> Self {
            LSTMOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                cell_clip: 0.0,
                proj_clip: 0.0,
                kernel_type: LSTMKernelType::FULL,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct LSTMOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LSTMOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_cell_clip(&mut self, cell_clip: f32) {
            self.fbb_
                .push_slot::<f32>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
        }
        #[inline]
        pub fn add_proj_clip(&mut self, proj_clip: f32) {
            self.fbb_
                .push_slot::<f32>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
        }
        #[inline]
        pub fn add_kernel_type(&mut self, kernel_type: LSTMKernelType) {
            self.fbb_.push_slot::<LSTMKernelType>(
                LSTMOptions::VT_KERNEL_TYPE,
                kernel_type,
                LSTMKernelType::FULL,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSTMOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LSTMOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LSTMOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LSTMOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LSTMOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("cell_clip", &self.cell_clip());
            ds.field("proj_clip", &self.proj_clip());
            ds.field("kernel_type", &self.kernel_type());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum UnidirectionalSequenceLSTMOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnidirectionalSequenceLSTMOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnidirectionalSequenceLSTMOptions<'a> {
        type Inner = UnidirectionalSequenceLSTMOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnidirectionalSequenceLSTMOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
        pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
        pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 10;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 12;
        pub const VT_DIAGONAL_RECURRENT_TENSORS: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnidirectionalSequenceLSTMOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnidirectionalSequenceLSTMOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'bldr>> {
            let mut builder = UnidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
            builder.add_proj_clip(args.proj_clip);
            builder.add_cell_clip(args.cell_clip);
            builder.add_diagonal_recurrent_tensors(args.diagonal_recurrent_tensors);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_time_major(args.time_major);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn cell_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn proj_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn time_major(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                        Some(false),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn diagonal_recurrent_tensors(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UnidirectionalSequenceLSTMOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
                .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
                .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .visit_field::<bool>(
                    "diagonal_recurrent_tensors",
                    Self::VT_DIAGONAL_RECURRENT_TENSORS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UnidirectionalSequenceLSTMOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub cell_clip: f32,
        pub proj_clip: f32,
        pub time_major: bool,
        pub asymmetric_quantize_inputs: bool,
        pub diagonal_recurrent_tensors: bool,
    }
    impl<'a> Default for UnidirectionalSequenceLSTMOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnidirectionalSequenceLSTMOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                cell_clip: 0.0,
                proj_clip: 0.0,
                time_major: false,
                asymmetric_quantize_inputs: false,
                diagonal_recurrent_tensors: false,
            }
        }
    }

    pub struct UnidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_cell_clip(&mut self, cell_clip: f32) {
            self.fbb_.push_slot::<f32>(
                UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP,
                cell_clip,
                0.0,
            );
        }
        #[inline]
        pub fn add_proj_clip(&mut self, proj_clip: f32) {
            self.fbb_.push_slot::<f32>(
                UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP,
                proj_clip,
                0.0,
            );
        }
        #[inline]
        pub fn add_time_major(&mut self, time_major: bool) {
            self.fbb_.push_slot::<bool>(
                UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                time_major,
                false,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn add_diagonal_recurrent_tensors(&mut self, diagonal_recurrent_tensors: bool) {
            self.fbb_.push_slot::<bool>(
                UnidirectionalSequenceLSTMOptions::VT_DIAGONAL_RECURRENT_TENSORS,
                diagonal_recurrent_tensors,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnidirectionalSequenceLSTMOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnidirectionalSequenceLSTMOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnidirectionalSequenceLSTMOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("cell_clip", &self.cell_clip());
            ds.field("proj_clip", &self.proj_clip());
            ds.field("time_major", &self.time_major());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.field(
                "diagonal_recurrent_tensors",
                &self.diagonal_recurrent_tensors(),
            );
            ds.finish()
        }
    }
    pub enum BidirectionalSequenceLSTMOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BidirectionalSequenceLSTMOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceLSTMOptions<'a> {
        type Inner = BidirectionalSequenceLSTMOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BidirectionalSequenceLSTMOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
        pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
        pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 10;
        pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 12;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BidirectionalSequenceLSTMOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BidirectionalSequenceLSTMOptionsArgs,
        ) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'bldr>> {
            let mut builder = BidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
            builder.add_proj_clip(args.proj_clip);
            builder.add_cell_clip(args.cell_clip);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_time_major(args.time_major);
            builder.add_merge_outputs(args.merge_outputs);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn cell_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn proj_clip(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn merge_outputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn time_major(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, Some(true))
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BidirectionalSequenceLSTMOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
                .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
                .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
                .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BidirectionalSequenceLSTMOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub cell_clip: f32,
        pub proj_clip: f32,
        pub merge_outputs: bool,
        pub time_major: bool,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for BidirectionalSequenceLSTMOptionsArgs {
        #[inline]
        fn default() -> Self {
            BidirectionalSequenceLSTMOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                cell_clip: 0.0,
                proj_clip: 0.0,
                merge_outputs: false,
                time_major: true,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct BidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_cell_clip(&mut self, cell_clip: f32) {
            self.fbb_.push_slot::<f32>(
                BidirectionalSequenceLSTMOptions::VT_CELL_CLIP,
                cell_clip,
                0.0,
            );
        }
        #[inline]
        pub fn add_proj_clip(&mut self, proj_clip: f32) {
            self.fbb_.push_slot::<f32>(
                BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP,
                proj_clip,
                0.0,
            );
        }
        #[inline]
        pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS,
                merge_outputs,
                false,
            );
        }
        #[inline]
        pub fn add_time_major(&mut self, time_major: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR,
                time_major,
                true,
            );
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BidirectionalSequenceLSTMOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BidirectionalSequenceLSTMOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BidirectionalSequenceLSTMOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("cell_clip", &self.cell_clip());
            ds.field("proj_clip", &self.proj_clip());
            ds.field("merge_outputs", &self.merge_outputs());
            ds.field("time_major", &self.time_major());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum ResizeBilinearOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ResizeBilinearOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ResizeBilinearOptions<'a> {
        type Inner = ResizeBilinearOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ResizeBilinearOptions<'a> {
        pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 8;
        pub const VT_HALF_PIXEL_CENTERS: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ResizeBilinearOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ResizeBilinearOptionsArgs,
        ) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'bldr>> {
            let mut builder = ResizeBilinearOptionsBuilder::new(_fbb);
            builder.add_half_pixel_centers(args.half_pixel_centers);
            builder.add_align_corners(args.align_corners);
            builder.finish()
        }

        #[inline]
        pub fn align_corners(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ResizeBilinearOptions::VT_ALIGN_CORNERS, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn half_pixel_centers(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ResizeBilinearOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
                .visit_field::<bool>("half_pixel_centers", Self::VT_HALF_PIXEL_CENTERS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ResizeBilinearOptionsArgs {
        pub align_corners: bool,
        pub half_pixel_centers: bool,
    }
    impl<'a> Default for ResizeBilinearOptionsArgs {
        #[inline]
        fn default() -> Self {
            ResizeBilinearOptionsArgs {
                align_corners: false,
                half_pixel_centers: false,
            }
        }
    }

    pub struct ResizeBilinearOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ResizeBilinearOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_align_corners(&mut self, align_corners: bool) {
            self.fbb_.push_slot::<bool>(
                ResizeBilinearOptions::VT_ALIGN_CORNERS,
                align_corners,
                false,
            );
        }
        #[inline]
        pub fn add_half_pixel_centers(&mut self, half_pixel_centers: bool) {
            self.fbb_.push_slot::<bool>(
                ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS,
                half_pixel_centers,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ResizeBilinearOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ResizeBilinearOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ResizeBilinearOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ResizeBilinearOptions");
            ds.field("align_corners", &self.align_corners());
            ds.field("half_pixel_centers", &self.half_pixel_centers());
            ds.finish()
        }
    }
    pub enum ResizeNearestNeighborOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ResizeNearestNeighborOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ResizeNearestNeighborOptions<'a> {
        type Inner = ResizeNearestNeighborOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ResizeNearestNeighborOptions<'a> {
        pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 4;
        pub const VT_HALF_PIXEL_CENTERS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ResizeNearestNeighborOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ResizeNearestNeighborOptionsArgs,
        ) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'bldr>> {
            let mut builder = ResizeNearestNeighborOptionsBuilder::new(_fbb);
            builder.add_half_pixel_centers(args.half_pixel_centers);
            builder.add_align_corners(args.align_corners);
            builder.finish()
        }

        #[inline]
        pub fn align_corners(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn half_pixel_centers(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ResizeNearestNeighborOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
                .visit_field::<bool>("half_pixel_centers", Self::VT_HALF_PIXEL_CENTERS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ResizeNearestNeighborOptionsArgs {
        pub align_corners: bool,
        pub half_pixel_centers: bool,
    }
    impl<'a> Default for ResizeNearestNeighborOptionsArgs {
        #[inline]
        fn default() -> Self {
            ResizeNearestNeighborOptionsArgs {
                align_corners: false,
                half_pixel_centers: false,
            }
        }
    }

    pub struct ResizeNearestNeighborOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_align_corners(&mut self, align_corners: bool) {
            self.fbb_.push_slot::<bool>(
                ResizeNearestNeighborOptions::VT_ALIGN_CORNERS,
                align_corners,
                false,
            );
        }
        #[inline]
        pub fn add_half_pixel_centers(&mut self, half_pixel_centers: bool) {
            self.fbb_.push_slot::<bool>(
                ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS,
                half_pixel_centers,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ResizeNearestNeighborOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ResizeNearestNeighborOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ResizeNearestNeighborOptions");
            ds.field("align_corners", &self.align_corners());
            ds.field("half_pixel_centers", &self.half_pixel_centers());
            ds.finish()
        }
    }
    pub enum CallOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CallOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallOptions<'a> {
        type Inner = CallOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CallOptions<'a> {
        pub const VT_SUBGRAPH: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallOptionsArgs,
        ) -> flatbuffers::WIPOffset<CallOptions<'bldr>> {
            let mut builder = CallOptionsBuilder::new(_fbb);
            builder.add_subgraph(args.subgraph);
            builder.finish()
        }

        #[inline]
        pub fn subgraph(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(CallOptions::VT_SUBGRAPH, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CallOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("subgraph", Self::VT_SUBGRAPH, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CallOptionsArgs {
        pub subgraph: u32,
    }
    impl<'a> Default for CallOptionsArgs {
        #[inline]
        fn default() -> Self {
            CallOptionsArgs { subgraph: 0 }
        }
    }

    pub struct CallOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_subgraph(&mut self, subgraph: u32) {
            self.fbb_
                .push_slot::<u32>(CallOptions::VT_SUBGRAPH, subgraph, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CallOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CallOptions");
            ds.field("subgraph", &self.subgraph());
            ds.finish()
        }
    }
    pub enum PadOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PadOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PadOptions<'a> {
        type Inner = PadOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PadOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PadOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args PadOptionsArgs,
        ) -> flatbuffers::WIPOffset<PadOptions<'bldr>> {
            let mut builder = PadOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for PadOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct PadOptionsArgs {}
    impl<'a> Default for PadOptionsArgs {
        #[inline]
        fn default() -> Self {
            PadOptionsArgs {}
        }
    }

    pub struct PadOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PadOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PadOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PadOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PadOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PadOptions");
            ds.finish()
        }
    }
    pub enum PadV2OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PadV2Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PadV2Options<'a> {
        type Inner = PadV2Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PadV2Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PadV2Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args PadV2OptionsArgs,
        ) -> flatbuffers::WIPOffset<PadV2Options<'bldr>> {
            let mut builder = PadV2OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for PadV2Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct PadV2OptionsArgs {}
    impl<'a> Default for PadV2OptionsArgs {
        #[inline]
        fn default() -> Self {
            PadV2OptionsArgs {}
        }
    }

    pub struct PadV2OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PadV2OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> PadV2OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PadV2OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PadV2Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PadV2Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PadV2Options");
            ds.finish()
        }
    }
    pub enum ReshapeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReshapeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReshapeOptions<'a> {
        type Inner = ReshapeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReshapeOptions<'a> {
        pub const VT_NEW_SHAPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReshapeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReshapeOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<ReshapeOptions<'bldr>> {
            let mut builder = ReshapeOptionsBuilder::new(_fbb);
            if let Some(x) = args.new_shape {
                builder.add_new_shape(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn new_shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        ReshapeOptions::VT_NEW_SHAPE,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for ReshapeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "new_shape",
                    Self::VT_NEW_SHAPE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ReshapeOptionsArgs<'a> {
        pub new_shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    }
    impl<'a> Default for ReshapeOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            ReshapeOptionsArgs { new_shape: None }
        }
    }

    pub struct ReshapeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReshapeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_new_shape(
            &mut self,
            new_shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ReshapeOptions::VT_NEW_SHAPE,
                new_shape,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReshapeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReshapeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReshapeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReshapeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReshapeOptions");
            ds.field("new_shape", &self.new_shape());
            ds.finish()
        }
    }
    pub enum SpaceToBatchNDOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SpaceToBatchNDOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SpaceToBatchNDOptions<'a> {
        type Inner = SpaceToBatchNDOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SpaceToBatchNDOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SpaceToBatchNDOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SpaceToBatchNDOptionsArgs,
        ) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'bldr>> {
            let mut builder = SpaceToBatchNDOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SpaceToBatchNDOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SpaceToBatchNDOptionsArgs {}
    impl<'a> Default for SpaceToBatchNDOptionsArgs {
        #[inline]
        fn default() -> Self {
            SpaceToBatchNDOptionsArgs {}
        }
    }

    pub struct SpaceToBatchNDOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SpaceToBatchNDOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SpaceToBatchNDOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SpaceToBatchNDOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SpaceToBatchNDOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SpaceToBatchNDOptions");
            ds.finish()
        }
    }
    pub enum BatchToSpaceNDOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BatchToSpaceNDOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BatchToSpaceNDOptions<'a> {
        type Inner = BatchToSpaceNDOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BatchToSpaceNDOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BatchToSpaceNDOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args BatchToSpaceNDOptionsArgs,
        ) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'bldr>> {
            let mut builder = BatchToSpaceNDOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for BatchToSpaceNDOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct BatchToSpaceNDOptionsArgs {}
    impl<'a> Default for BatchToSpaceNDOptionsArgs {
        #[inline]
        fn default() -> Self {
            BatchToSpaceNDOptionsArgs {}
        }
    }

    pub struct BatchToSpaceNDOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BatchToSpaceNDOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BatchToSpaceNDOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BatchToSpaceNDOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BatchToSpaceNDOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BatchToSpaceNDOptions");
            ds.finish()
        }
    }
    pub enum SkipGramOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SkipGramOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SkipGramOptions<'a> {
        type Inner = SkipGramOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SkipGramOptions<'a> {
        pub const VT_NGRAM_SIZE: flatbuffers::VOffsetT = 4;
        pub const VT_MAX_SKIP_SIZE: flatbuffers::VOffsetT = 6;
        pub const VT_INCLUDE_ALL_NGRAMS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SkipGramOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SkipGramOptionsArgs,
        ) -> flatbuffers::WIPOffset<SkipGramOptions<'bldr>> {
            let mut builder = SkipGramOptionsBuilder::new(_fbb);
            builder.add_max_skip_size(args.max_skip_size);
            builder.add_ngram_size(args.ngram_size);
            builder.add_include_all_ngrams(args.include_all_ngrams);
            builder.finish()
        }

        #[inline]
        pub fn ngram_size(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SkipGramOptions::VT_NGRAM_SIZE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn max_skip_size(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn include_all_ngrams(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SkipGramOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("ngram_size", Self::VT_NGRAM_SIZE, false)?
                .visit_field::<i32>("max_skip_size", Self::VT_MAX_SKIP_SIZE, false)?
                .visit_field::<bool>("include_all_ngrams", Self::VT_INCLUDE_ALL_NGRAMS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SkipGramOptionsArgs {
        pub ngram_size: i32,
        pub max_skip_size: i32,
        pub include_all_ngrams: bool,
    }
    impl<'a> Default for SkipGramOptionsArgs {
        #[inline]
        fn default() -> Self {
            SkipGramOptionsArgs {
                ngram_size: 0,
                max_skip_size: 0,
                include_all_ngrams: false,
            }
        }
    }

    pub struct SkipGramOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SkipGramOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_ngram_size(&mut self, ngram_size: i32) {
            self.fbb_
                .push_slot::<i32>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
        }
        #[inline]
        pub fn add_max_skip_size(&mut self, max_skip_size: i32) {
            self.fbb_
                .push_slot::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
        }
        #[inline]
        pub fn add_include_all_ngrams(&mut self, include_all_ngrams: bool) {
            self.fbb_.push_slot::<bool>(
                SkipGramOptions::VT_INCLUDE_ALL_NGRAMS,
                include_all_ngrams,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SkipGramOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SkipGramOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SkipGramOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SkipGramOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SkipGramOptions");
            ds.field("ngram_size", &self.ngram_size());
            ds.field("max_skip_size", &self.max_skip_size());
            ds.field("include_all_ngrams", &self.include_all_ngrams());
            ds.finish()
        }
    }
    pub enum SpaceToDepthOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SpaceToDepthOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SpaceToDepthOptions<'a> {
        type Inner = SpaceToDepthOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SpaceToDepthOptions<'a> {
        pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SpaceToDepthOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SpaceToDepthOptionsArgs,
        ) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'bldr>> {
            let mut builder = SpaceToDepthOptionsBuilder::new(_fbb);
            builder.add_block_size(args.block_size);
            builder.finish()
        }

        #[inline]
        pub fn block_size(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SpaceToDepthOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SpaceToDepthOptionsArgs {
        pub block_size: i32,
    }
    impl<'a> Default for SpaceToDepthOptionsArgs {
        #[inline]
        fn default() -> Self {
            SpaceToDepthOptionsArgs { block_size: 0 }
        }
    }

    pub struct SpaceToDepthOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SpaceToDepthOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_block_size(&mut self, block_size: i32) {
            self.fbb_
                .push_slot::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SpaceToDepthOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SpaceToDepthOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SpaceToDepthOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SpaceToDepthOptions");
            ds.field("block_size", &self.block_size());
            ds.finish()
        }
    }
    pub enum DepthToSpaceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DepthToSpaceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DepthToSpaceOptions<'a> {
        type Inner = DepthToSpaceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DepthToSpaceOptions<'a> {
        pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DepthToSpaceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DepthToSpaceOptionsArgs,
        ) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'bldr>> {
            let mut builder = DepthToSpaceOptionsBuilder::new(_fbb);
            builder.add_block_size(args.block_size);
            builder.finish()
        }

        #[inline]
        pub fn block_size(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DepthToSpaceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct DepthToSpaceOptionsArgs {
        pub block_size: i32,
    }
    impl<'a> Default for DepthToSpaceOptionsArgs {
        #[inline]
        fn default() -> Self {
            DepthToSpaceOptionsArgs { block_size: 0 }
        }
    }

    pub struct DepthToSpaceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DepthToSpaceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_block_size(&mut self, block_size: i32) {
            self.fbb_
                .push_slot::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DepthToSpaceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DepthToSpaceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DepthToSpaceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DepthToSpaceOptions");
            ds.field("block_size", &self.block_size());
            ds.finish()
        }
    }
    pub enum SubOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SubOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SubOptions<'a> {
        type Inner = SubOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SubOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
        pub const VT_POT_SCALE_INT16: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SubOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubOptionsArgs,
        ) -> flatbuffers::WIPOffset<SubOptions<'bldr>> {
            let mut builder = SubOptionsBuilder::new(_fbb);
            builder.add_pot_scale_int16(args.pot_scale_int16);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn pot_scale_int16(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SubOptions::VT_POT_SCALE_INT16, Some(true))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SubOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .visit_field::<bool>("pot_scale_int16", Self::VT_POT_SCALE_INT16, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
        pub pot_scale_int16: bool,
    }
    impl<'a> Default for SubOptionsArgs {
        #[inline]
        fn default() -> Self {
            SubOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
                pot_scale_int16: true,
            }
        }
    }

    pub struct SubOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                SubOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn add_pot_scale_int16(&mut self, pot_scale_int16: bool) {
            self.fbb_
                .push_slot::<bool>(SubOptions::VT_POT_SCALE_INT16, pot_scale_int16, true);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SubOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SubOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SubOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.field("pot_scale_int16", &self.pot_scale_int16());
            ds.finish()
        }
    }
    pub enum DivOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DivOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DivOptions<'a> {
        type Inner = DivOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DivOptions<'a> {
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DivOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args DivOptionsArgs,
        ) -> flatbuffers::WIPOffset<DivOptions<'bldr>> {
            let mut builder = DivOptionsBuilder::new(_fbb);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.finish()
        }

        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for DivOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct DivOptionsArgs {
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for DivOptionsArgs {
        #[inline]
        fn default() -> Self {
            DivOptionsArgs {
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct DivOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DivOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                DivOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DivOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DivOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DivOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DivOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DivOptions");
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum TopKV2OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TopKV2Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TopKV2Options<'a> {
        type Inner = TopKV2Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TopKV2Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TopKV2Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args TopKV2OptionsArgs,
        ) -> flatbuffers::WIPOffset<TopKV2Options<'bldr>> {
            let mut builder = TopKV2OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for TopKV2Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct TopKV2OptionsArgs {}
    impl<'a> Default for TopKV2OptionsArgs {
        #[inline]
        fn default() -> Self {
            TopKV2OptionsArgs {}
        }
    }

    pub struct TopKV2OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TopKV2OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TopKV2OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TopKV2OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TopKV2Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TopKV2Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TopKV2Options");
            ds.finish()
        }
    }
    pub enum EmbeddingLookupSparseOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct EmbeddingLookupSparseOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for EmbeddingLookupSparseOptions<'a> {
        type Inner = EmbeddingLookupSparseOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> EmbeddingLookupSparseOptions<'a> {
        pub const VT_COMBINER: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            EmbeddingLookupSparseOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EmbeddingLookupSparseOptionsArgs,
        ) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'bldr>> {
            let mut builder = EmbeddingLookupSparseOptionsBuilder::new(_fbb);
            builder.add_combiner(args.combiner);
            builder.finish()
        }

        #[inline]
        pub fn combiner(&self) -> CombinerType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<CombinerType>(
                        EmbeddingLookupSparseOptions::VT_COMBINER,
                        Some(CombinerType::SUM),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for EmbeddingLookupSparseOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<CombinerType>("combiner", Self::VT_COMBINER, false)?
                .finish();
            Ok(())
        }
    }
    pub struct EmbeddingLookupSparseOptionsArgs {
        pub combiner: CombinerType,
    }
    impl<'a> Default for EmbeddingLookupSparseOptionsArgs {
        #[inline]
        fn default() -> Self {
            EmbeddingLookupSparseOptionsArgs {
                combiner: CombinerType::SUM,
            }
        }
    }

    pub struct EmbeddingLookupSparseOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_combiner(&mut self, combiner: CombinerType) {
            self.fbb_.push_slot::<CombinerType>(
                EmbeddingLookupSparseOptions::VT_COMBINER,
                combiner,
                CombinerType::SUM,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EmbeddingLookupSparseOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for EmbeddingLookupSparseOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("EmbeddingLookupSparseOptions");
            ds.field("combiner", &self.combiner());
            ds.finish()
        }
    }
    pub enum GatherOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GatherOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GatherOptions<'a> {
        type Inner = GatherOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GatherOptions<'a> {
        pub const VT_AXIS: flatbuffers::VOffsetT = 4;
        pub const VT_BATCH_DIMS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GatherOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args GatherOptionsArgs,
        ) -> flatbuffers::WIPOffset<GatherOptions<'bldr>> {
            let mut builder = GatherOptionsBuilder::new(_fbb);
            builder.add_batch_dims(args.batch_dims);
            builder.add_axis(args.axis);
            builder.finish()
        }

        #[inline]
        pub fn axis(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(GatherOptions::VT_AXIS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn batch_dims(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(GatherOptions::VT_BATCH_DIMS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for GatherOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("axis", Self::VT_AXIS, false)?
                .visit_field::<i32>("batch_dims", Self::VT_BATCH_DIMS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct GatherOptionsArgs {
        pub axis: i32,
        pub batch_dims: i32,
    }
    impl<'a> Default for GatherOptionsArgs {
        #[inline]
        fn default() -> Self {
            GatherOptionsArgs {
                axis: 0,
                batch_dims: 0,
            }
        }
    }

    pub struct GatherOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GatherOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_axis(&mut self, axis: i32) {
            self.fbb_.push_slot::<i32>(GatherOptions::VT_AXIS, axis, 0);
        }
        #[inline]
        pub fn add_batch_dims(&mut self, batch_dims: i32) {
            self.fbb_
                .push_slot::<i32>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GatherOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GatherOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GatherOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GatherOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GatherOptions");
            ds.field("axis", &self.axis());
            ds.field("batch_dims", &self.batch_dims());
            ds.finish()
        }
    }
    pub enum TransposeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransposeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransposeOptions<'a> {
        type Inner = TransposeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransposeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransposeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args TransposeOptionsArgs,
        ) -> flatbuffers::WIPOffset<TransposeOptions<'bldr>> {
            let mut builder = TransposeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for TransposeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct TransposeOptionsArgs {}
    impl<'a> Default for TransposeOptionsArgs {
        #[inline]
        fn default() -> Self {
            TransposeOptionsArgs {}
        }
    }

    pub struct TransposeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransposeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransposeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransposeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransposeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransposeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransposeOptions");
            ds.finish()
        }
    }
    pub enum ExpOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ExpOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpOptions<'a> {
        type Inner = ExpOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ExpOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ExpOptionsArgs,
        ) -> flatbuffers::WIPOffset<ExpOptions<'bldr>> {
            let mut builder = ExpOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ExpOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ExpOptionsArgs {}
    impl<'a> Default for ExpOptionsArgs {
        #[inline]
        fn default() -> Self {
            ExpOptionsArgs {}
        }
    }

    pub struct ExpOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ExpOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ExpOptions");
            ds.finish()
        }
    }
    pub enum CosOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CosOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CosOptions<'a> {
        type Inner = CosOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CosOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CosOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args CosOptionsArgs,
        ) -> flatbuffers::WIPOffset<CosOptions<'bldr>> {
            let mut builder = CosOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for CosOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct CosOptionsArgs {}
    impl<'a> Default for CosOptionsArgs {
        #[inline]
        fn default() -> Self {
            CosOptionsArgs {}
        }
    }

    pub struct CosOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CosOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CosOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CosOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CosOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CosOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CosOptions");
            ds.finish()
        }
    }
    pub enum ReducerOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReducerOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReducerOptions<'a> {
        type Inner = ReducerOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReducerOptions<'a> {
        pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReducerOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReducerOptionsArgs,
        ) -> flatbuffers::WIPOffset<ReducerOptions<'bldr>> {
            let mut builder = ReducerOptionsBuilder::new(_fbb);
            builder.add_keep_dims(args.keep_dims);
            builder.finish()
        }

        #[inline]
        pub fn keep_dims(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(ReducerOptions::VT_KEEP_DIMS, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ReducerOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ReducerOptionsArgs {
        pub keep_dims: bool,
    }
    impl<'a> Default for ReducerOptionsArgs {
        #[inline]
        fn default() -> Self {
            ReducerOptionsArgs { keep_dims: false }
        }
    }

    pub struct ReducerOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReducerOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_keep_dims(&mut self, keep_dims: bool) {
            self.fbb_
                .push_slot::<bool>(ReducerOptions::VT_KEEP_DIMS, keep_dims, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReducerOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReducerOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReducerOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReducerOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReducerOptions");
            ds.field("keep_dims", &self.keep_dims());
            ds.finish()
        }
    }
    pub enum SqueezeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SqueezeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SqueezeOptions<'a> {
        type Inner = SqueezeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SqueezeOptions<'a> {
        pub const VT_SQUEEZE_DIMS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SqueezeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SqueezeOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<SqueezeOptions<'bldr>> {
            let mut builder = SqueezeOptionsBuilder::new(_fbb);
            if let Some(x) = args.squeeze_dims {
                builder.add_squeeze_dims(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn squeeze_dims(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        SqueezeOptions::VT_SQUEEZE_DIMS,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for SqueezeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "squeeze_dims",
                    Self::VT_SQUEEZE_DIMS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SqueezeOptionsArgs<'a> {
        pub squeeze_dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    }
    impl<'a> Default for SqueezeOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            SqueezeOptionsArgs { squeeze_dims: None }
        }
    }

    pub struct SqueezeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SqueezeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_squeeze_dims(
            &mut self,
            squeeze_dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SqueezeOptions::VT_SQUEEZE_DIMS,
                squeeze_dims,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SqueezeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SqueezeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SqueezeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SqueezeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SqueezeOptions");
            ds.field("squeeze_dims", &self.squeeze_dims());
            ds.finish()
        }
    }
    pub enum SplitOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SplitOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SplitOptions<'a> {
        type Inner = SplitOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SplitOptions<'a> {
        pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SplitOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SplitOptionsArgs,
        ) -> flatbuffers::WIPOffset<SplitOptions<'bldr>> {
            let mut builder = SplitOptionsBuilder::new(_fbb);
            builder.add_num_splits(args.num_splits);
            builder.finish()
        }

        #[inline]
        pub fn num_splits(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SplitOptions::VT_NUM_SPLITS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SplitOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SplitOptionsArgs {
        pub num_splits: i32,
    }
    impl<'a> Default for SplitOptionsArgs {
        #[inline]
        fn default() -> Self {
            SplitOptionsArgs { num_splits: 0 }
        }
    }

    pub struct SplitOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SplitOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_num_splits(&mut self, num_splits: i32) {
            self.fbb_
                .push_slot::<i32>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SplitOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SplitOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SplitOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SplitOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SplitOptions");
            ds.field("num_splits", &self.num_splits());
            ds.finish()
        }
    }
    pub enum SplitVOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SplitVOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SplitVOptions<'a> {
        type Inner = SplitVOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SplitVOptions<'a> {
        pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SplitVOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SplitVOptionsArgs,
        ) -> flatbuffers::WIPOffset<SplitVOptions<'bldr>> {
            let mut builder = SplitVOptionsBuilder::new(_fbb);
            builder.add_num_splits(args.num_splits);
            builder.finish()
        }

        #[inline]
        pub fn num_splits(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(SplitVOptions::VT_NUM_SPLITS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SplitVOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SplitVOptionsArgs {
        pub num_splits: i32,
    }
    impl<'a> Default for SplitVOptionsArgs {
        #[inline]
        fn default() -> Self {
            SplitVOptionsArgs { num_splits: 0 }
        }
    }

    pub struct SplitVOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SplitVOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_num_splits(&mut self, num_splits: i32) {
            self.fbb_
                .push_slot::<i32>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SplitVOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SplitVOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SplitVOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SplitVOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SplitVOptions");
            ds.field("num_splits", &self.num_splits());
            ds.finish()
        }
    }
    pub enum StridedSliceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StridedSliceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StridedSliceOptions<'a> {
        type Inner = StridedSliceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> StridedSliceOptions<'a> {
        pub const VT_BEGIN_MASK: flatbuffers::VOffsetT = 4;
        pub const VT_END_MASK: flatbuffers::VOffsetT = 6;
        pub const VT_ELLIPSIS_MASK: flatbuffers::VOffsetT = 8;
        pub const VT_NEW_AXIS_MASK: flatbuffers::VOffsetT = 10;
        pub const VT_SHRINK_AXIS_MASK: flatbuffers::VOffsetT = 12;
        pub const VT_OFFSET: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StridedSliceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StridedSliceOptionsArgs,
        ) -> flatbuffers::WIPOffset<StridedSliceOptions<'bldr>> {
            let mut builder = StridedSliceOptionsBuilder::new(_fbb);
            builder.add_shrink_axis_mask(args.shrink_axis_mask);
            builder.add_new_axis_mask(args.new_axis_mask);
            builder.add_ellipsis_mask(args.ellipsis_mask);
            builder.add_end_mask(args.end_mask);
            builder.add_begin_mask(args.begin_mask);
            builder.add_offset(args.offset);
            builder.finish()
        }

        #[inline]
        pub fn begin_mask(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(StridedSliceOptions::VT_BEGIN_MASK, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn end_mask(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(StridedSliceOptions::VT_END_MASK, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn ellipsis_mask(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn new_axis_mask(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn shrink_axis_mask(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn offset(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(StridedSliceOptions::VT_OFFSET, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for StridedSliceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("begin_mask", Self::VT_BEGIN_MASK, false)?
                .visit_field::<i32>("end_mask", Self::VT_END_MASK, false)?
                .visit_field::<i32>("ellipsis_mask", Self::VT_ELLIPSIS_MASK, false)?
                .visit_field::<i32>("new_axis_mask", Self::VT_NEW_AXIS_MASK, false)?
                .visit_field::<i32>("shrink_axis_mask", Self::VT_SHRINK_AXIS_MASK, false)?
                .visit_field::<bool>("offset", Self::VT_OFFSET, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StridedSliceOptionsArgs {
        pub begin_mask: i32,
        pub end_mask: i32,
        pub ellipsis_mask: i32,
        pub new_axis_mask: i32,
        pub shrink_axis_mask: i32,
        pub offset: bool,
    }
    impl<'a> Default for StridedSliceOptionsArgs {
        #[inline]
        fn default() -> Self {
            StridedSliceOptionsArgs {
                begin_mask: 0,
                end_mask: 0,
                ellipsis_mask: 0,
                new_axis_mask: 0,
                shrink_axis_mask: 0,
                offset: false,
            }
        }
    }

    pub struct StridedSliceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StridedSliceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_begin_mask(&mut self, begin_mask: i32) {
            self.fbb_
                .push_slot::<i32>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
        }
        #[inline]
        pub fn add_end_mask(&mut self, end_mask: i32) {
            self.fbb_
                .push_slot::<i32>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
        }
        #[inline]
        pub fn add_ellipsis_mask(&mut self, ellipsis_mask: i32) {
            self.fbb_
                .push_slot::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
        }
        #[inline]
        pub fn add_new_axis_mask(&mut self, new_axis_mask: i32) {
            self.fbb_
                .push_slot::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
        }
        #[inline]
        pub fn add_shrink_axis_mask(&mut self, shrink_axis_mask: i32) {
            self.fbb_.push_slot::<i32>(
                StridedSliceOptions::VT_SHRINK_AXIS_MASK,
                shrink_axis_mask,
                0,
            );
        }
        #[inline]
        pub fn add_offset(&mut self, offset: bool) {
            self.fbb_
                .push_slot::<bool>(StridedSliceOptions::VT_OFFSET, offset, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> StridedSliceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StridedSliceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StridedSliceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for StridedSliceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("StridedSliceOptions");
            ds.field("begin_mask", &self.begin_mask());
            ds.field("end_mask", &self.end_mask());
            ds.field("ellipsis_mask", &self.ellipsis_mask());
            ds.field("new_axis_mask", &self.new_axis_mask());
            ds.field("shrink_axis_mask", &self.shrink_axis_mask());
            ds.field("offset", &self.offset());
            ds.finish()
        }
    }
    pub enum LogSoftmaxOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogSoftmaxOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogSoftmaxOptions<'a> {
        type Inner = LogSoftmaxOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LogSoftmaxOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogSoftmaxOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LogSoftmaxOptionsArgs,
        ) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'bldr>> {
            let mut builder = LogSoftmaxOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LogSoftmaxOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LogSoftmaxOptionsArgs {}
    impl<'a> Default for LogSoftmaxOptionsArgs {
        #[inline]
        fn default() -> Self {
            LogSoftmaxOptionsArgs {}
        }
    }

    pub struct LogSoftmaxOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogSoftmaxOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogSoftmaxOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogSoftmaxOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LogSoftmaxOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LogSoftmaxOptions");
            ds.finish()
        }
    }
    pub enum CastOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CastOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CastOptions<'a> {
        type Inner = CastOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CastOptions<'a> {
        pub const VT_IN_DATA_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_OUT_DATA_TYPE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CastOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CastOptionsArgs,
        ) -> flatbuffers::WIPOffset<CastOptions<'bldr>> {
            let mut builder = CastOptionsBuilder::new(_fbb);
            builder.add_out_data_type(args.out_data_type);
            builder.add_in_data_type(args.in_data_type);
            builder.finish()
        }

        #[inline]
        pub fn in_data_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(CastOptions::VT_IN_DATA_TYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
        #[inline]
        pub fn out_data_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(CastOptions::VT_OUT_DATA_TYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CastOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<TensorType>("in_data_type", Self::VT_IN_DATA_TYPE, false)?
                .visit_field::<TensorType>("out_data_type", Self::VT_OUT_DATA_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CastOptionsArgs {
        pub in_data_type: TensorType,
        pub out_data_type: TensorType,
    }
    impl<'a> Default for CastOptionsArgs {
        #[inline]
        fn default() -> Self {
            CastOptionsArgs {
                in_data_type: TensorType::FLOAT32,
                out_data_type: TensorType::FLOAT32,
            }
        }
    }

    pub struct CastOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CastOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_in_data_type(&mut self, in_data_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                CastOptions::VT_IN_DATA_TYPE,
                in_data_type,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn add_out_data_type(&mut self, out_data_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                CastOptions::VT_OUT_DATA_TYPE,
                out_data_type,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CastOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CastOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CastOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CastOptions");
            ds.field("in_data_type", &self.in_data_type());
            ds.field("out_data_type", &self.out_data_type());
            ds.finish()
        }
    }
    pub enum DequantizeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DequantizeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DequantizeOptions<'a> {
        type Inner = DequantizeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DequantizeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DequantizeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args DequantizeOptionsArgs,
        ) -> flatbuffers::WIPOffset<DequantizeOptions<'bldr>> {
            let mut builder = DequantizeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for DequantizeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct DequantizeOptionsArgs {}
    impl<'a> Default for DequantizeOptionsArgs {
        #[inline]
        fn default() -> Self {
            DequantizeOptionsArgs {}
        }
    }

    pub struct DequantizeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DequantizeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DequantizeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DequantizeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DequantizeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DequantizeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DequantizeOptions");
            ds.finish()
        }
    }
    pub enum MaximumMinimumOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MaximumMinimumOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MaximumMinimumOptions<'a> {
        type Inner = MaximumMinimumOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MaximumMinimumOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MaximumMinimumOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args MaximumMinimumOptionsArgs,
        ) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'bldr>> {
            let mut builder = MaximumMinimumOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for MaximumMinimumOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct MaximumMinimumOptionsArgs {}
    impl<'a> Default for MaximumMinimumOptionsArgs {
        #[inline]
        fn default() -> Self {
            MaximumMinimumOptionsArgs {}
        }
    }

    pub struct MaximumMinimumOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MaximumMinimumOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MaximumMinimumOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MaximumMinimumOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MaximumMinimumOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MaximumMinimumOptions");
            ds.finish()
        }
    }
    pub enum TileOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TileOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TileOptions<'a> {
        type Inner = TileOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TileOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TileOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args TileOptionsArgs,
        ) -> flatbuffers::WIPOffset<TileOptions<'bldr>> {
            let mut builder = TileOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for TileOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct TileOptionsArgs {}
    impl<'a> Default for TileOptionsArgs {
        #[inline]
        fn default() -> Self {
            TileOptionsArgs {}
        }
    }

    pub struct TileOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TileOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TileOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TileOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TileOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TileOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TileOptions");
            ds.finish()
        }
    }
    pub enum ArgMaxOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArgMaxOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArgMaxOptions<'a> {
        type Inner = ArgMaxOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ArgMaxOptions<'a> {
        pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArgMaxOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArgMaxOptionsArgs,
        ) -> flatbuffers::WIPOffset<ArgMaxOptions<'bldr>> {
            let mut builder = ArgMaxOptionsBuilder::new(_fbb);
            builder.add_output_type(args.output_type);
            builder.finish()
        }

        #[inline]
        pub fn output_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(ArgMaxOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArgMaxOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ArgMaxOptionsArgs {
        pub output_type: TensorType,
    }
    impl<'a> Default for ArgMaxOptionsArgs {
        #[inline]
        fn default() -> Self {
            ArgMaxOptionsArgs {
                output_type: TensorType::FLOAT32,
            }
        }
    }

    pub struct ArgMaxOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArgMaxOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_output_type(&mut self, output_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                ArgMaxOptions::VT_OUTPUT_TYPE,
                output_type,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArgMaxOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArgMaxOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArgMaxOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArgMaxOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArgMaxOptions");
            ds.field("output_type", &self.output_type());
            ds.finish()
        }
    }
    pub enum ArgMinOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ArgMinOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ArgMinOptions<'a> {
        type Inner = ArgMinOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ArgMinOptions<'a> {
        pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ArgMinOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ArgMinOptionsArgs,
        ) -> flatbuffers::WIPOffset<ArgMinOptions<'bldr>> {
            let mut builder = ArgMinOptionsBuilder::new(_fbb);
            builder.add_output_type(args.output_type);
            builder.finish()
        }

        #[inline]
        pub fn output_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(ArgMinOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ArgMinOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ArgMinOptionsArgs {
        pub output_type: TensorType,
    }
    impl<'a> Default for ArgMinOptionsArgs {
        #[inline]
        fn default() -> Self {
            ArgMinOptionsArgs {
                output_type: TensorType::FLOAT32,
            }
        }
    }

    pub struct ArgMinOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ArgMinOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_output_type(&mut self, output_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                ArgMinOptions::VT_OUTPUT_TYPE,
                output_type,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ArgMinOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ArgMinOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ArgMinOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ArgMinOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ArgMinOptions");
            ds.field("output_type", &self.output_type());
            ds.finish()
        }
    }
    pub enum GreaterOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GreaterOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GreaterOptions<'a> {
        type Inner = GreaterOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GreaterOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GreaterOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args GreaterOptionsArgs,
        ) -> flatbuffers::WIPOffset<GreaterOptions<'bldr>> {
            let mut builder = GreaterOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GreaterOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GreaterOptionsArgs {}
    impl<'a> Default for GreaterOptionsArgs {
        #[inline]
        fn default() -> Self {
            GreaterOptionsArgs {}
        }
    }

    pub struct GreaterOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GreaterOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GreaterOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GreaterOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GreaterOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GreaterOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GreaterOptions");
            ds.finish()
        }
    }
    pub enum GreaterEqualOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GreaterEqualOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GreaterEqualOptions<'a> {
        type Inner = GreaterEqualOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GreaterEqualOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GreaterEqualOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args GreaterEqualOptionsArgs,
        ) -> flatbuffers::WIPOffset<GreaterEqualOptions<'bldr>> {
            let mut builder = GreaterEqualOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GreaterEqualOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GreaterEqualOptionsArgs {}
    impl<'a> Default for GreaterEqualOptionsArgs {
        #[inline]
        fn default() -> Self {
            GreaterEqualOptionsArgs {}
        }
    }

    pub struct GreaterEqualOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GreaterEqualOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GreaterEqualOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GreaterEqualOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GreaterEqualOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GreaterEqualOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GreaterEqualOptions");
            ds.finish()
        }
    }
    pub enum LessOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LessOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LessOptions<'a> {
        type Inner = LessOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LessOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LessOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LessOptionsArgs,
        ) -> flatbuffers::WIPOffset<LessOptions<'bldr>> {
            let mut builder = LessOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LessOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LessOptionsArgs {}
    impl<'a> Default for LessOptionsArgs {
        #[inline]
        fn default() -> Self {
            LessOptionsArgs {}
        }
    }

    pub struct LessOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LessOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LessOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LessOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LessOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LessOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LessOptions");
            ds.finish()
        }
    }
    pub enum LessEqualOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LessEqualOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LessEqualOptions<'a> {
        type Inner = LessEqualOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LessEqualOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LessEqualOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LessEqualOptionsArgs,
        ) -> flatbuffers::WIPOffset<LessEqualOptions<'bldr>> {
            let mut builder = LessEqualOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LessEqualOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LessEqualOptionsArgs {}
    impl<'a> Default for LessEqualOptionsArgs {
        #[inline]
        fn default() -> Self {
            LessEqualOptionsArgs {}
        }
    }

    pub struct LessEqualOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LessEqualOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LessEqualOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LessEqualOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LessEqualOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LessEqualOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LessEqualOptions");
            ds.finish()
        }
    }
    pub enum NegOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NegOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NegOptions<'a> {
        type Inner = NegOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NegOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NegOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args NegOptionsArgs,
        ) -> flatbuffers::WIPOffset<NegOptions<'bldr>> {
            let mut builder = NegOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for NegOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct NegOptionsArgs {}
    impl<'a> Default for NegOptionsArgs {
        #[inline]
        fn default() -> Self {
            NegOptionsArgs {}
        }
    }

    pub struct NegOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NegOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NegOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NegOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NegOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NegOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NegOptions");
            ds.finish()
        }
    }
    pub enum SelectOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SelectOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SelectOptions<'a> {
        type Inner = SelectOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SelectOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SelectOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SelectOptionsArgs,
        ) -> flatbuffers::WIPOffset<SelectOptions<'bldr>> {
            let mut builder = SelectOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SelectOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SelectOptionsArgs {}
    impl<'a> Default for SelectOptionsArgs {
        #[inline]
        fn default() -> Self {
            SelectOptionsArgs {}
        }
    }

    pub struct SelectOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SelectOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SelectOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SelectOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SelectOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SelectOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SelectOptions");
            ds.finish()
        }
    }
    pub enum SliceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SliceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SliceOptions<'a> {
        type Inner = SliceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SliceOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SliceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SliceOptionsArgs,
        ) -> flatbuffers::WIPOffset<SliceOptions<'bldr>> {
            let mut builder = SliceOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SliceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SliceOptionsArgs {}
    impl<'a> Default for SliceOptionsArgs {
        #[inline]
        fn default() -> Self {
            SliceOptionsArgs {}
        }
    }

    pub struct SliceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SliceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SliceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SliceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SliceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SliceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SliceOptions");
            ds.finish()
        }
    }
    pub enum TransposeConvOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TransposeConvOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TransposeConvOptions<'a> {
        type Inner = TransposeConvOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TransposeConvOptions<'a> {
        pub const VT_PADDING: flatbuffers::VOffsetT = 4;
        pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
        pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
        pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TransposeConvOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TransposeConvOptionsArgs,
        ) -> flatbuffers::WIPOffset<TransposeConvOptions<'bldr>> {
            let mut builder = TransposeConvOptionsBuilder::new(_fbb);
            builder.add_stride_h(args.stride_h);
            builder.add_stride_w(args.stride_w);
            builder.add_fused_activation_function(args.fused_activation_function);
            builder.add_padding(args.padding);
            builder.finish()
        }

        #[inline]
        pub fn padding(&self) -> Padding {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Padding>(TransposeConvOptions::VT_PADDING, Some(Padding::SAME))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_w(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(TransposeConvOptions::VT_STRIDE_W, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn stride_h(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(TransposeConvOptions::VT_STRIDE_H, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn fused_activation_function(&self) -> ActivationFunctionType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ActivationFunctionType>(
                        TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION,
                        Some(ActivationFunctionType::NONE),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TransposeConvOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
                .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
                .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
                .visit_field::<ActivationFunctionType>(
                    "fused_activation_function",
                    Self::VT_FUSED_ACTIVATION_FUNCTION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransposeConvOptionsArgs {
        pub padding: Padding,
        pub stride_w: i32,
        pub stride_h: i32,
        pub fused_activation_function: ActivationFunctionType,
    }
    impl<'a> Default for TransposeConvOptionsArgs {
        #[inline]
        fn default() -> Self {
            TransposeConvOptionsArgs {
                padding: Padding::SAME,
                stride_w: 0,
                stride_h: 0,
                fused_activation_function: ActivationFunctionType::NONE,
            }
        }
    }

    pub struct TransposeConvOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TransposeConvOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_padding(&mut self, padding: Padding) {
            self.fbb_.push_slot::<Padding>(
                TransposeConvOptions::VT_PADDING,
                padding,
                Padding::SAME,
            );
        }
        #[inline]
        pub fn add_stride_w(&mut self, stride_w: i32) {
            self.fbb_
                .push_slot::<i32>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
        }
        #[inline]
        pub fn add_stride_h(&mut self, stride_h: i32) {
            self.fbb_
                .push_slot::<i32>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
        }
        #[inline]
        pub fn add_fused_activation_function(
            &mut self,
            fused_activation_function: ActivationFunctionType,
        ) {
            self.fbb_.push_slot::<ActivationFunctionType>(
                TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION,
                fused_activation_function,
                ActivationFunctionType::NONE,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TransposeConvOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TransposeConvOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TransposeConvOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TransposeConvOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TransposeConvOptions");
            ds.field("padding", &self.padding());
            ds.field("stride_w", &self.stride_w());
            ds.field("stride_h", &self.stride_h());
            ds.field(
                "fused_activation_function",
                &self.fused_activation_function(),
            );
            ds.finish()
        }
    }
    pub enum ExpandDimsOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ExpandDimsOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ExpandDimsOptions<'a> {
        type Inner = ExpandDimsOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ExpandDimsOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ExpandDimsOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ExpandDimsOptionsArgs,
        ) -> flatbuffers::WIPOffset<ExpandDimsOptions<'bldr>> {
            let mut builder = ExpandDimsOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ExpandDimsOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ExpandDimsOptionsArgs {}
    impl<'a> Default for ExpandDimsOptionsArgs {
        #[inline]
        fn default() -> Self {
            ExpandDimsOptionsArgs {}
        }
    }

    pub struct ExpandDimsOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ExpandDimsOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ExpandDimsOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ExpandDimsOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ExpandDimsOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ExpandDimsOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ExpandDimsOptions");
            ds.finish()
        }
    }
    pub enum SparseToDenseOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SparseToDenseOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SparseToDenseOptions<'a> {
        type Inner = SparseToDenseOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SparseToDenseOptions<'a> {
        pub const VT_VALIDATE_INDICES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SparseToDenseOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SparseToDenseOptionsArgs,
        ) -> flatbuffers::WIPOffset<SparseToDenseOptions<'bldr>> {
            let mut builder = SparseToDenseOptionsBuilder::new(_fbb);
            builder.add_validate_indices(args.validate_indices);
            builder.finish()
        }

        #[inline]
        pub fn validate_indices(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(SparseToDenseOptions::VT_VALIDATE_INDICES, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SparseToDenseOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("validate_indices", Self::VT_VALIDATE_INDICES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SparseToDenseOptionsArgs {
        pub validate_indices: bool,
    }
    impl<'a> Default for SparseToDenseOptionsArgs {
        #[inline]
        fn default() -> Self {
            SparseToDenseOptionsArgs {
                validate_indices: false,
            }
        }
    }

    pub struct SparseToDenseOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SparseToDenseOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_validate_indices(&mut self, validate_indices: bool) {
            self.fbb_.push_slot::<bool>(
                SparseToDenseOptions::VT_VALIDATE_INDICES,
                validate_indices,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SparseToDenseOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SparseToDenseOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SparseToDenseOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SparseToDenseOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SparseToDenseOptions");
            ds.field("validate_indices", &self.validate_indices());
            ds.finish()
        }
    }
    pub enum EqualOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct EqualOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for EqualOptions<'a> {
        type Inner = EqualOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> EqualOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            EqualOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args EqualOptionsArgs,
        ) -> flatbuffers::WIPOffset<EqualOptions<'bldr>> {
            let mut builder = EqualOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for EqualOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct EqualOptionsArgs {}
    impl<'a> Default for EqualOptionsArgs {
        #[inline]
        fn default() -> Self {
            EqualOptionsArgs {}
        }
    }

    pub struct EqualOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EqualOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> EqualOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EqualOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<EqualOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for EqualOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("EqualOptions");
            ds.finish()
        }
    }
    pub enum NotEqualOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NotEqualOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NotEqualOptions<'a> {
        type Inner = NotEqualOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NotEqualOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NotEqualOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args NotEqualOptionsArgs,
        ) -> flatbuffers::WIPOffset<NotEqualOptions<'bldr>> {
            let mut builder = NotEqualOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for NotEqualOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct NotEqualOptionsArgs {}
    impl<'a> Default for NotEqualOptionsArgs {
        #[inline]
        fn default() -> Self {
            NotEqualOptionsArgs {}
        }
    }

    pub struct NotEqualOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NotEqualOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NotEqualOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NotEqualOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NotEqualOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NotEqualOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NotEqualOptions");
            ds.finish()
        }
    }
    pub enum ShapeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ShapeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ShapeOptions<'a> {
        type Inner = ShapeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ShapeOptions<'a> {
        pub const VT_OUT_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ShapeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ShapeOptionsArgs,
        ) -> flatbuffers::WIPOffset<ShapeOptions<'bldr>> {
            let mut builder = ShapeOptionsBuilder::new(_fbb);
            builder.add_out_type(args.out_type);
            builder.finish()
        }

        #[inline]
        pub fn out_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(ShapeOptions::VT_OUT_TYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ShapeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<TensorType>("out_type", Self::VT_OUT_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ShapeOptionsArgs {
        pub out_type: TensorType,
    }
    impl<'a> Default for ShapeOptionsArgs {
        #[inline]
        fn default() -> Self {
            ShapeOptionsArgs {
                out_type: TensorType::FLOAT32,
            }
        }
    }

    pub struct ShapeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ShapeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_out_type(&mut self, out_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                ShapeOptions::VT_OUT_TYPE,
                out_type,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ShapeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ShapeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ShapeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ShapeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ShapeOptions");
            ds.field("out_type", &self.out_type());
            ds.finish()
        }
    }
    pub enum RankOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RankOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RankOptions<'a> {
        type Inner = RankOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RankOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RankOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args RankOptionsArgs,
        ) -> flatbuffers::WIPOffset<RankOptions<'bldr>> {
            let mut builder = RankOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for RankOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct RankOptionsArgs {}
    impl<'a> Default for RankOptionsArgs {
        #[inline]
        fn default() -> Self {
            RankOptionsArgs {}
        }
    }

    pub struct RankOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RankOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RankOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RankOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RankOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RankOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RankOptions");
            ds.finish()
        }
    }
    pub enum PowOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PowOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PowOptions<'a> {
        type Inner = PowOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PowOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PowOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args PowOptionsArgs,
        ) -> flatbuffers::WIPOffset<PowOptions<'bldr>> {
            let mut builder = PowOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for PowOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct PowOptionsArgs {}
    impl<'a> Default for PowOptionsArgs {
        #[inline]
        fn default() -> Self {
            PowOptionsArgs {}
        }
    }

    pub struct PowOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PowOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PowOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PowOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PowOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PowOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PowOptions");
            ds.finish()
        }
    }
    pub enum FakeQuantOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FakeQuantOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FakeQuantOptions<'a> {
        type Inner = FakeQuantOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FakeQuantOptions<'a> {
        pub const VT_MIN: flatbuffers::VOffsetT = 4;
        pub const VT_MAX: flatbuffers::VOffsetT = 6;
        pub const VT_NUM_BITS: flatbuffers::VOffsetT = 8;
        pub const VT_NARROW_RANGE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FakeQuantOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args FakeQuantOptionsArgs,
        ) -> flatbuffers::WIPOffset<FakeQuantOptions<'bldr>> {
            let mut builder = FakeQuantOptionsBuilder::new(_fbb);
            builder.add_num_bits(args.num_bits);
            builder.add_max(args.max);
            builder.add_min(args.min);
            builder.add_narrow_range(args.narrow_range);
            builder.finish()
        }

        #[inline]
        pub fn min(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(FakeQuantOptions::VT_MIN, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn max(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(FakeQuantOptions::VT_MAX, Some(0.0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn num_bits(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(FakeQuantOptions::VT_NUM_BITS, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn narrow_range(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(FakeQuantOptions::VT_NARROW_RANGE, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for FakeQuantOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f32>("min", Self::VT_MIN, false)?
                .visit_field::<f32>("max", Self::VT_MAX, false)?
                .visit_field::<i32>("num_bits", Self::VT_NUM_BITS, false)?
                .visit_field::<bool>("narrow_range", Self::VT_NARROW_RANGE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct FakeQuantOptionsArgs {
        pub min: f32,
        pub max: f32,
        pub num_bits: i32,
        pub narrow_range: bool,
    }
    impl<'a> Default for FakeQuantOptionsArgs {
        #[inline]
        fn default() -> Self {
            FakeQuantOptionsArgs {
                min: 0.0,
                max: 0.0,
                num_bits: 0,
                narrow_range: false,
            }
        }
    }

    pub struct FakeQuantOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FakeQuantOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_min(&mut self, min: f32) {
            self.fbb_
                .push_slot::<f32>(FakeQuantOptions::VT_MIN, min, 0.0);
        }
        #[inline]
        pub fn add_max(&mut self, max: f32) {
            self.fbb_
                .push_slot::<f32>(FakeQuantOptions::VT_MAX, max, 0.0);
        }
        #[inline]
        pub fn add_num_bits(&mut self, num_bits: i32) {
            self.fbb_
                .push_slot::<i32>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
        }
        #[inline]
        pub fn add_narrow_range(&mut self, narrow_range: bool) {
            self.fbb_
                .push_slot::<bool>(FakeQuantOptions::VT_NARROW_RANGE, narrow_range, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FakeQuantOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FakeQuantOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FakeQuantOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FakeQuantOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FakeQuantOptions");
            ds.field("min", &self.min());
            ds.field("max", &self.max());
            ds.field("num_bits", &self.num_bits());
            ds.field("narrow_range", &self.narrow_range());
            ds.finish()
        }
    }
    pub enum PackOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct PackOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for PackOptions<'a> {
        type Inner = PackOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> PackOptions<'a> {
        pub const VT_VALUES_COUNT: flatbuffers::VOffsetT = 4;
        pub const VT_AXIS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            PackOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PackOptionsArgs,
        ) -> flatbuffers::WIPOffset<PackOptions<'bldr>> {
            let mut builder = PackOptionsBuilder::new(_fbb);
            builder.add_axis(args.axis);
            builder.add_values_count(args.values_count);
            builder.finish()
        }

        #[inline]
        pub fn values_count(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(PackOptions::VT_VALUES_COUNT, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn axis(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(PackOptions::VT_AXIS, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for PackOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("values_count", Self::VT_VALUES_COUNT, false)?
                .visit_field::<i32>("axis", Self::VT_AXIS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct PackOptionsArgs {
        pub values_count: i32,
        pub axis: i32,
    }
    impl<'a> Default for PackOptionsArgs {
        #[inline]
        fn default() -> Self {
            PackOptionsArgs {
                values_count: 0,
                axis: 0,
            }
        }
    }

    pub struct PackOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PackOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_values_count(&mut self, values_count: i32) {
            self.fbb_
                .push_slot::<i32>(PackOptions::VT_VALUES_COUNT, values_count, 0);
        }
        #[inline]
        pub fn add_axis(&mut self, axis: i32) {
            self.fbb_.push_slot::<i32>(PackOptions::VT_AXIS, axis, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PackOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<PackOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for PackOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("PackOptions");
            ds.field("values_count", &self.values_count());
            ds.field("axis", &self.axis());
            ds.finish()
        }
    }
    pub enum LogicalOrOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogicalOrOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalOrOptions<'a> {
        type Inner = LogicalOrOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LogicalOrOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalOrOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LogicalOrOptionsArgs,
        ) -> flatbuffers::WIPOffset<LogicalOrOptions<'bldr>> {
            let mut builder = LogicalOrOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LogicalOrOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LogicalOrOptionsArgs {}
    impl<'a> Default for LogicalOrOptionsArgs {
        #[inline]
        fn default() -> Self {
            LogicalOrOptionsArgs {}
        }
    }

    pub struct LogicalOrOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalOrOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalOrOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalOrOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalOrOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LogicalOrOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LogicalOrOptions");
            ds.finish()
        }
    }
    pub enum OneHotOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OneHotOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OneHotOptions<'a> {
        type Inner = OneHotOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> OneHotOptions<'a> {
        pub const VT_AXIS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OneHotOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OneHotOptionsArgs,
        ) -> flatbuffers::WIPOffset<OneHotOptions<'bldr>> {
            let mut builder = OneHotOptionsBuilder::new(_fbb);
            builder.add_axis(args.axis);
            builder.finish()
        }

        #[inline]
        pub fn axis(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(OneHotOptions::VT_AXIS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for OneHotOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("axis", Self::VT_AXIS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct OneHotOptionsArgs {
        pub axis: i32,
    }
    impl<'a> Default for OneHotOptionsArgs {
        #[inline]
        fn default() -> Self {
            OneHotOptionsArgs { axis: 0 }
        }
    }

    pub struct OneHotOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OneHotOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_axis(&mut self, axis: i32) {
            self.fbb_.push_slot::<i32>(OneHotOptions::VT_AXIS, axis, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OneHotOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OneHotOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OneHotOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for OneHotOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("OneHotOptions");
            ds.field("axis", &self.axis());
            ds.finish()
        }
    }
    pub enum AbsOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AbsOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AbsOptions<'a> {
        type Inner = AbsOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AbsOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AbsOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args AbsOptionsArgs,
        ) -> flatbuffers::WIPOffset<AbsOptions<'bldr>> {
            let mut builder = AbsOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for AbsOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct AbsOptionsArgs {}
    impl<'a> Default for AbsOptionsArgs {
        #[inline]
        fn default() -> Self {
            AbsOptionsArgs {}
        }
    }

    pub struct AbsOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AbsOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AbsOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AbsOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AbsOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AbsOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AbsOptions");
            ds.finish()
        }
    }
    pub enum HardSwishOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HardSwishOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HardSwishOptions<'a> {
        type Inner = HardSwishOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HardSwishOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HardSwishOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args HardSwishOptionsArgs,
        ) -> flatbuffers::WIPOffset<HardSwishOptions<'bldr>> {
            let mut builder = HardSwishOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for HardSwishOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct HardSwishOptionsArgs {}
    impl<'a> Default for HardSwishOptionsArgs {
        #[inline]
        fn default() -> Self {
            HardSwishOptionsArgs {}
        }
    }

    pub struct HardSwishOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HardSwishOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HardSwishOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HardSwishOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HardSwishOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HardSwishOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HardSwishOptions");
            ds.finish()
        }
    }
    pub enum LogicalAndOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogicalAndOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalAndOptions<'a> {
        type Inner = LogicalAndOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LogicalAndOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalAndOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LogicalAndOptionsArgs,
        ) -> flatbuffers::WIPOffset<LogicalAndOptions<'bldr>> {
            let mut builder = LogicalAndOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LogicalAndOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LogicalAndOptionsArgs {}
    impl<'a> Default for LogicalAndOptionsArgs {
        #[inline]
        fn default() -> Self {
            LogicalAndOptionsArgs {}
        }
    }

    pub struct LogicalAndOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalAndOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalAndOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalAndOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalAndOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LogicalAndOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LogicalAndOptions");
            ds.finish()
        }
    }
    pub enum LogicalNotOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LogicalNotOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LogicalNotOptions<'a> {
        type Inner = LogicalNotOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LogicalNotOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LogicalNotOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args LogicalNotOptionsArgs,
        ) -> flatbuffers::WIPOffset<LogicalNotOptions<'bldr>> {
            let mut builder = LogicalNotOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for LogicalNotOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct LogicalNotOptionsArgs {}
    impl<'a> Default for LogicalNotOptionsArgs {
        #[inline]
        fn default() -> Self {
            LogicalNotOptionsArgs {}
        }
    }

    pub struct LogicalNotOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LogicalNotOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LogicalNotOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LogicalNotOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LogicalNotOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LogicalNotOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LogicalNotOptions");
            ds.finish()
        }
    }
    pub enum UnpackOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnpackOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnpackOptions<'a> {
        type Inner = UnpackOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnpackOptions<'a> {
        pub const VT_NUM: flatbuffers::VOffsetT = 4;
        pub const VT_AXIS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnpackOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UnpackOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnpackOptions<'bldr>> {
            let mut builder = UnpackOptionsBuilder::new(_fbb);
            builder.add_axis(args.axis);
            builder.add_num(args.num);
            builder.finish()
        }

        #[inline]
        pub fn num(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(UnpackOptions::VT_NUM, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn axis(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(UnpackOptions::VT_AXIS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UnpackOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("num", Self::VT_NUM, false)?
                .visit_field::<i32>("axis", Self::VT_AXIS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UnpackOptionsArgs {
        pub num: i32,
        pub axis: i32,
    }
    impl<'a> Default for UnpackOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnpackOptionsArgs { num: 0, axis: 0 }
        }
    }

    pub struct UnpackOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnpackOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_num(&mut self, num: i32) {
            self.fbb_.push_slot::<i32>(UnpackOptions::VT_NUM, num, 0);
        }
        #[inline]
        pub fn add_axis(&mut self, axis: i32) {
            self.fbb_.push_slot::<i32>(UnpackOptions::VT_AXIS, axis, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnpackOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnpackOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnpackOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnpackOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnpackOptions");
            ds.field("num", &self.num());
            ds.field("axis", &self.axis());
            ds.finish()
        }
    }
    pub enum FloorDivOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FloorDivOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloorDivOptions<'a> {
        type Inner = FloorDivOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FloorDivOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloorDivOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args FloorDivOptionsArgs,
        ) -> flatbuffers::WIPOffset<FloorDivOptions<'bldr>> {
            let mut builder = FloorDivOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for FloorDivOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct FloorDivOptionsArgs {}
    impl<'a> Default for FloorDivOptionsArgs {
        #[inline]
        fn default() -> Self {
            FloorDivOptionsArgs {}
        }
    }

    pub struct FloorDivOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloorDivOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloorDivOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloorDivOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloorDivOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FloorDivOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FloorDivOptions");
            ds.finish()
        }
    }
    pub enum SquareOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SquareOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SquareOptions<'a> {
        type Inner = SquareOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SquareOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SquareOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SquareOptionsArgs,
        ) -> flatbuffers::WIPOffset<SquareOptions<'bldr>> {
            let mut builder = SquareOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SquareOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SquareOptionsArgs {}
    impl<'a> Default for SquareOptionsArgs {
        #[inline]
        fn default() -> Self {
            SquareOptionsArgs {}
        }
    }

    pub struct SquareOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SquareOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SquareOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SquareOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SquareOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SquareOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SquareOptions");
            ds.finish()
        }
    }
    pub enum ZerosLikeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ZerosLikeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ZerosLikeOptions<'a> {
        type Inner = ZerosLikeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ZerosLikeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ZerosLikeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ZerosLikeOptionsArgs,
        ) -> flatbuffers::WIPOffset<ZerosLikeOptions<'bldr>> {
            let mut builder = ZerosLikeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ZerosLikeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ZerosLikeOptionsArgs {}
    impl<'a> Default for ZerosLikeOptionsArgs {
        #[inline]
        fn default() -> Self {
            ZerosLikeOptionsArgs {}
        }
    }

    pub struct ZerosLikeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ZerosLikeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ZerosLikeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ZerosLikeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ZerosLikeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ZerosLikeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ZerosLikeOptions");
            ds.finish()
        }
    }
    pub enum FillOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FillOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FillOptions<'a> {
        type Inner = FillOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FillOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FillOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args FillOptionsArgs,
        ) -> flatbuffers::WIPOffset<FillOptions<'bldr>> {
            let mut builder = FillOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for FillOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct FillOptionsArgs {}
    impl<'a> Default for FillOptionsArgs {
        #[inline]
        fn default() -> Self {
            FillOptionsArgs {}
        }
    }

    pub struct FillOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FillOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FillOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FillOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FillOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FillOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FillOptions");
            ds.finish()
        }
    }
    pub enum FloorModOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FloorModOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FloorModOptions<'a> {
        type Inner = FloorModOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FloorModOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FloorModOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args FloorModOptionsArgs,
        ) -> flatbuffers::WIPOffset<FloorModOptions<'bldr>> {
            let mut builder = FloorModOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for FloorModOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct FloorModOptionsArgs {}
    impl<'a> Default for FloorModOptionsArgs {
        #[inline]
        fn default() -> Self {
            FloorModOptionsArgs {}
        }
    }

    pub struct FloorModOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FloorModOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FloorModOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FloorModOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FloorModOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FloorModOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FloorModOptions");
            ds.finish()
        }
    }
    pub enum RangeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RangeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RangeOptions<'a> {
        type Inner = RangeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RangeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RangeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args RangeOptionsArgs,
        ) -> flatbuffers::WIPOffset<RangeOptions<'bldr>> {
            let mut builder = RangeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for RangeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct RangeOptionsArgs {}
    impl<'a> Default for RangeOptionsArgs {
        #[inline]
        fn default() -> Self {
            RangeOptionsArgs {}
        }
    }

    pub struct RangeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RangeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RangeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RangeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RangeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RangeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RangeOptions");
            ds.finish()
        }
    }
    pub enum LeakyReluOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct LeakyReluOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LeakyReluOptions<'a> {
        type Inner = LeakyReluOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> LeakyReluOptions<'a> {
        pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LeakyReluOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LeakyReluOptionsArgs,
        ) -> flatbuffers::WIPOffset<LeakyReluOptions<'bldr>> {
            let mut builder = LeakyReluOptionsBuilder::new(_fbb);
            builder.add_alpha(args.alpha);
            builder.finish()
        }

        #[inline]
        pub fn alpha(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(LeakyReluOptions::VT_ALPHA, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for LeakyReluOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct LeakyReluOptionsArgs {
        pub alpha: f32,
    }
    impl<'a> Default for LeakyReluOptionsArgs {
        #[inline]
        fn default() -> Self {
            LeakyReluOptionsArgs { alpha: 0.0 }
        }
    }

    pub struct LeakyReluOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LeakyReluOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_alpha(&mut self, alpha: f32) {
            self.fbb_
                .push_slot::<f32>(LeakyReluOptions::VT_ALPHA, alpha, 0.0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> LeakyReluOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LeakyReluOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for LeakyReluOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("LeakyReluOptions");
            ds.field("alpha", &self.alpha());
            ds.finish()
        }
    }
    pub enum SquaredDifferenceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SquaredDifferenceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SquaredDifferenceOptions<'a> {
        type Inner = SquaredDifferenceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SquaredDifferenceOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SquaredDifferenceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SquaredDifferenceOptionsArgs,
        ) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'bldr>> {
            let mut builder = SquaredDifferenceOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SquaredDifferenceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SquaredDifferenceOptionsArgs {}
    impl<'a> Default for SquaredDifferenceOptionsArgs {
        #[inline]
        fn default() -> Self {
            SquaredDifferenceOptionsArgs {}
        }
    }

    pub struct SquaredDifferenceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SquaredDifferenceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SquaredDifferenceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SquaredDifferenceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SquaredDifferenceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SquaredDifferenceOptions");
            ds.finish()
        }
    }
    pub enum MirrorPadOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MirrorPadOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MirrorPadOptions<'a> {
        type Inner = MirrorPadOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MirrorPadOptions<'a> {
        pub const VT_MODE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MirrorPadOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MirrorPadOptionsArgs,
        ) -> flatbuffers::WIPOffset<MirrorPadOptions<'bldr>> {
            let mut builder = MirrorPadOptionsBuilder::new(_fbb);
            builder.add_mode(args.mode);
            builder.finish()
        }

        #[inline]
        pub fn mode(&self) -> MirrorPadMode {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<MirrorPadMode>(MirrorPadOptions::VT_MODE, Some(MirrorPadMode::REFLECT))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for MirrorPadOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<MirrorPadMode>("mode", Self::VT_MODE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MirrorPadOptionsArgs {
        pub mode: MirrorPadMode,
    }
    impl<'a> Default for MirrorPadOptionsArgs {
        #[inline]
        fn default() -> Self {
            MirrorPadOptionsArgs {
                mode: MirrorPadMode::REFLECT,
            }
        }
    }

    pub struct MirrorPadOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MirrorPadOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_mode(&mut self, mode: MirrorPadMode) {
            self.fbb_.push_slot::<MirrorPadMode>(
                MirrorPadOptions::VT_MODE,
                mode,
                MirrorPadMode::REFLECT,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MirrorPadOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MirrorPadOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MirrorPadOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MirrorPadOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MirrorPadOptions");
            ds.field("mode", &self.mode());
            ds.finish()
        }
    }
    pub enum UniqueOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UniqueOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UniqueOptions<'a> {
        type Inner = UniqueOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UniqueOptions<'a> {
        pub const VT_IDX_OUT_TYPE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UniqueOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args UniqueOptionsArgs,
        ) -> flatbuffers::WIPOffset<UniqueOptions<'bldr>> {
            let mut builder = UniqueOptionsBuilder::new(_fbb);
            builder.add_idx_out_type(args.idx_out_type);
            builder.finish()
        }

        #[inline]
        pub fn idx_out_type(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(UniqueOptions::VT_IDX_OUT_TYPE, Some(TensorType::INT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for UniqueOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<TensorType>("idx_out_type", Self::VT_IDX_OUT_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct UniqueOptionsArgs {
        pub idx_out_type: TensorType,
    }
    impl<'a> Default for UniqueOptionsArgs {
        #[inline]
        fn default() -> Self {
            UniqueOptionsArgs {
                idx_out_type: TensorType::INT32,
            }
        }
    }

    pub struct UniqueOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UniqueOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_idx_out_type(&mut self, idx_out_type: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                UniqueOptions::VT_IDX_OUT_TYPE,
                idx_out_type,
                TensorType::INT32,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UniqueOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UniqueOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UniqueOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UniqueOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UniqueOptions");
            ds.field("idx_out_type", &self.idx_out_type());
            ds.finish()
        }
    }
    pub enum ReverseV2OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReverseV2Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReverseV2Options<'a> {
        type Inner = ReverseV2Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReverseV2Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReverseV2Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ReverseV2OptionsArgs,
        ) -> flatbuffers::WIPOffset<ReverseV2Options<'bldr>> {
            let mut builder = ReverseV2OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ReverseV2Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ReverseV2OptionsArgs {}
    impl<'a> Default for ReverseV2OptionsArgs {
        #[inline]
        fn default() -> Self {
            ReverseV2OptionsArgs {}
        }
    }

    pub struct ReverseV2OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReverseV2OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReverseV2OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReverseV2OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReverseV2Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReverseV2Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReverseV2Options");
            ds.finish()
        }
    }
    pub enum AddNOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AddNOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AddNOptions<'a> {
        type Inner = AddNOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AddNOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AddNOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args AddNOptionsArgs,
        ) -> flatbuffers::WIPOffset<AddNOptions<'bldr>> {
            let mut builder = AddNOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for AddNOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct AddNOptionsArgs {}
    impl<'a> Default for AddNOptionsArgs {
        #[inline]
        fn default() -> Self {
            AddNOptionsArgs {}
        }
    }

    pub struct AddNOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AddNOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddNOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AddNOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AddNOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AddNOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AddNOptions");
            ds.finish()
        }
    }
    pub enum GatherNdOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GatherNdOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GatherNdOptions<'a> {
        type Inner = GatherNdOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GatherNdOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GatherNdOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args GatherNdOptionsArgs,
        ) -> flatbuffers::WIPOffset<GatherNdOptions<'bldr>> {
            let mut builder = GatherNdOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for GatherNdOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct GatherNdOptionsArgs {}
    impl<'a> Default for GatherNdOptionsArgs {
        #[inline]
        fn default() -> Self {
            GatherNdOptionsArgs {}
        }
    }

    pub struct GatherNdOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GatherNdOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> GatherNdOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GatherNdOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GatherNdOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GatherNdOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GatherNdOptions");
            ds.finish()
        }
    }
    pub enum WhereOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WhereOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WhereOptions<'a> {
        type Inner = WhereOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> WhereOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WhereOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args WhereOptionsArgs,
        ) -> flatbuffers::WIPOffset<WhereOptions<'bldr>> {
            let mut builder = WhereOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for WhereOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct WhereOptionsArgs {}
    impl<'a> Default for WhereOptionsArgs {
        #[inline]
        fn default() -> Self {
            WhereOptionsArgs {}
        }
    }

    pub struct WhereOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WhereOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WhereOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WhereOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WhereOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for WhereOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("WhereOptions");
            ds.finish()
        }
    }
    pub enum ReverseSequenceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReverseSequenceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReverseSequenceOptions<'a> {
        type Inner = ReverseSequenceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReverseSequenceOptions<'a> {
        pub const VT_SEQ_DIM: flatbuffers::VOffsetT = 4;
        pub const VT_BATCH_DIM: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReverseSequenceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ReverseSequenceOptionsArgs,
        ) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'bldr>> {
            let mut builder = ReverseSequenceOptionsBuilder::new(_fbb);
            builder.add_batch_dim(args.batch_dim);
            builder.add_seq_dim(args.seq_dim);
            builder.finish()
        }

        #[inline]
        pub fn seq_dim(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn batch_dim(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ReverseSequenceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("seq_dim", Self::VT_SEQ_DIM, false)?
                .visit_field::<i32>("batch_dim", Self::VT_BATCH_DIM, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ReverseSequenceOptionsArgs {
        pub seq_dim: i32,
        pub batch_dim: i32,
    }
    impl<'a> Default for ReverseSequenceOptionsArgs {
        #[inline]
        fn default() -> Self {
            ReverseSequenceOptionsArgs {
                seq_dim: 0,
                batch_dim: 0,
            }
        }
    }

    pub struct ReverseSequenceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReverseSequenceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_seq_dim(&mut self, seq_dim: i32) {
            self.fbb_
                .push_slot::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
        }
        #[inline]
        pub fn add_batch_dim(&mut self, batch_dim: i32) {
            self.fbb_
                .push_slot::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReverseSequenceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReverseSequenceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReverseSequenceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReverseSequenceOptions");
            ds.field("seq_dim", &self.seq_dim());
            ds.field("batch_dim", &self.batch_dim());
            ds.finish()
        }
    }
    pub enum MatrixDiagOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MatrixDiagOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MatrixDiagOptions<'a> {
        type Inner = MatrixDiagOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MatrixDiagOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MatrixDiagOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args MatrixDiagOptionsArgs,
        ) -> flatbuffers::WIPOffset<MatrixDiagOptions<'bldr>> {
            let mut builder = MatrixDiagOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for MatrixDiagOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct MatrixDiagOptionsArgs {}
    impl<'a> Default for MatrixDiagOptionsArgs {
        #[inline]
        fn default() -> Self {
            MatrixDiagOptionsArgs {}
        }
    }

    pub struct MatrixDiagOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MatrixDiagOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MatrixDiagOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MatrixDiagOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MatrixDiagOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MatrixDiagOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MatrixDiagOptions");
            ds.finish()
        }
    }
    pub enum QuantizeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct QuantizeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for QuantizeOptions<'a> {
        type Inner = QuantizeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> QuantizeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            QuantizeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args QuantizeOptionsArgs,
        ) -> flatbuffers::WIPOffset<QuantizeOptions<'bldr>> {
            let mut builder = QuantizeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for QuantizeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct QuantizeOptionsArgs {}
    impl<'a> Default for QuantizeOptionsArgs {
        #[inline]
        fn default() -> Self {
            QuantizeOptionsArgs {}
        }
    }

    pub struct QuantizeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> QuantizeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> QuantizeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            QuantizeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<QuantizeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for QuantizeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("QuantizeOptions");
            ds.finish()
        }
    }
    pub enum MatrixSetDiagOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MatrixSetDiagOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MatrixSetDiagOptions<'a> {
        type Inner = MatrixSetDiagOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MatrixSetDiagOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MatrixSetDiagOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args MatrixSetDiagOptionsArgs,
        ) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'bldr>> {
            let mut builder = MatrixSetDiagOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for MatrixSetDiagOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct MatrixSetDiagOptionsArgs {}
    impl<'a> Default for MatrixSetDiagOptionsArgs {
        #[inline]
        fn default() -> Self {
            MatrixSetDiagOptionsArgs {}
        }
    }

    pub struct MatrixSetDiagOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MatrixSetDiagOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> MatrixSetDiagOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MatrixSetDiagOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MatrixSetDiagOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MatrixSetDiagOptions");
            ds.finish()
        }
    }
    pub enum IfOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct IfOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for IfOptions<'a> {
        type Inner = IfOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> IfOptions<'a> {
        pub const VT_THEN_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_ELSE_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            IfOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args IfOptionsArgs,
        ) -> flatbuffers::WIPOffset<IfOptions<'bldr>> {
            let mut builder = IfOptionsBuilder::new(_fbb);
            builder.add_else_subgraph_index(args.else_subgraph_index);
            builder.add_then_subgraph_index(args.then_subgraph_index);
            builder.finish()
        }

        #[inline]
        pub fn then_subgraph_index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn else_subgraph_index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for IfOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("then_subgraph_index", Self::VT_THEN_SUBGRAPH_INDEX, false)?
                .visit_field::<i32>("else_subgraph_index", Self::VT_ELSE_SUBGRAPH_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct IfOptionsArgs {
        pub then_subgraph_index: i32,
        pub else_subgraph_index: i32,
    }
    impl<'a> Default for IfOptionsArgs {
        #[inline]
        fn default() -> Self {
            IfOptionsArgs {
                then_subgraph_index: 0,
                else_subgraph_index: 0,
            }
        }
    }

    pub struct IfOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> IfOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_then_subgraph_index(&mut self, then_subgraph_index: i32) {
            self.fbb_
                .push_slot::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
        }
        #[inline]
        pub fn add_else_subgraph_index(&mut self, else_subgraph_index: i32) {
            self.fbb_
                .push_slot::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IfOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            IfOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<IfOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for IfOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("IfOptions");
            ds.field("then_subgraph_index", &self.then_subgraph_index());
            ds.field("else_subgraph_index", &self.else_subgraph_index());
            ds.finish()
        }
    }
    pub enum CallOnceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CallOnceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CallOnceOptions<'a> {
        type Inner = CallOnceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CallOnceOptions<'a> {
        pub const VT_INIT_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CallOnceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CallOnceOptionsArgs,
        ) -> flatbuffers::WIPOffset<CallOnceOptions<'bldr>> {
            let mut builder = CallOnceOptionsBuilder::new(_fbb);
            builder.add_init_subgraph_index(args.init_subgraph_index);
            builder.finish()
        }

        #[inline]
        pub fn init_subgraph_index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CallOnceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("init_subgraph_index", Self::VT_INIT_SUBGRAPH_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CallOnceOptionsArgs {
        pub init_subgraph_index: i32,
    }
    impl<'a> Default for CallOnceOptionsArgs {
        #[inline]
        fn default() -> Self {
            CallOnceOptionsArgs {
                init_subgraph_index: 0,
            }
        }
    }

    pub struct CallOnceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CallOnceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_init_subgraph_index(&mut self, init_subgraph_index: i32) {
            self.fbb_.push_slot::<i32>(
                CallOnceOptions::VT_INIT_SUBGRAPH_INDEX,
                init_subgraph_index,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CallOnceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CallOnceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CallOnceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CallOnceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CallOnceOptions");
            ds.field("init_subgraph_index", &self.init_subgraph_index());
            ds.finish()
        }
    }
    pub enum WhileOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct WhileOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for WhileOptions<'a> {
        type Inner = WhileOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> WhileOptions<'a> {
        pub const VT_COND_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_BODY_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            WhileOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args WhileOptionsArgs,
        ) -> flatbuffers::WIPOffset<WhileOptions<'bldr>> {
            let mut builder = WhileOptionsBuilder::new(_fbb);
            builder.add_body_subgraph_index(args.body_subgraph_index);
            builder.add_cond_subgraph_index(args.cond_subgraph_index);
            builder.finish()
        }

        #[inline]
        pub fn cond_subgraph_index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(WhileOptions::VT_COND_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn body_subgraph_index(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for WhileOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("cond_subgraph_index", Self::VT_COND_SUBGRAPH_INDEX, false)?
                .visit_field::<i32>("body_subgraph_index", Self::VT_BODY_SUBGRAPH_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct WhileOptionsArgs {
        pub cond_subgraph_index: i32,
        pub body_subgraph_index: i32,
    }
    impl<'a> Default for WhileOptionsArgs {
        #[inline]
        fn default() -> Self {
            WhileOptionsArgs {
                cond_subgraph_index: 0,
                body_subgraph_index: 0,
            }
        }
    }

    pub struct WhileOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> WhileOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_cond_subgraph_index(&mut self, cond_subgraph_index: i32) {
            self.fbb_.push_slot::<i32>(
                WhileOptions::VT_COND_SUBGRAPH_INDEX,
                cond_subgraph_index,
                0,
            );
        }
        #[inline]
        pub fn add_body_subgraph_index(&mut self, body_subgraph_index: i32) {
            self.fbb_.push_slot::<i32>(
                WhileOptions::VT_BODY_SUBGRAPH_INDEX,
                body_subgraph_index,
                0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> WhileOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            WhileOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<WhileOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for WhileOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("WhileOptions");
            ds.field("cond_subgraph_index", &self.cond_subgraph_index());
            ds.field("body_subgraph_index", &self.body_subgraph_index());
            ds.finish()
        }
    }
    pub enum NonMaxSuppressionV4OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NonMaxSuppressionV4Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV4Options<'a> {
        type Inner = NonMaxSuppressionV4Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NonMaxSuppressionV4Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NonMaxSuppressionV4Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args NonMaxSuppressionV4OptionsArgs,
        ) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'bldr>> {
            let mut builder = NonMaxSuppressionV4OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for NonMaxSuppressionV4Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct NonMaxSuppressionV4OptionsArgs {}
    impl<'a> Default for NonMaxSuppressionV4OptionsArgs {
        #[inline]
        fn default() -> Self {
            NonMaxSuppressionV4OptionsArgs {}
        }
    }

    pub struct NonMaxSuppressionV4OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NonMaxSuppressionV4OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NonMaxSuppressionV4Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NonMaxSuppressionV4Options");
            ds.finish()
        }
    }
    pub enum NonMaxSuppressionV5OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NonMaxSuppressionV5Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV5Options<'a> {
        type Inner = NonMaxSuppressionV5Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NonMaxSuppressionV5Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NonMaxSuppressionV5Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args NonMaxSuppressionV5OptionsArgs,
        ) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'bldr>> {
            let mut builder = NonMaxSuppressionV5OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for NonMaxSuppressionV5Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct NonMaxSuppressionV5OptionsArgs {}
    impl<'a> Default for NonMaxSuppressionV5OptionsArgs {
        #[inline]
        fn default() -> Self {
            NonMaxSuppressionV5OptionsArgs {}
        }
    }

    pub struct NonMaxSuppressionV5OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NonMaxSuppressionV5OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NonMaxSuppressionV5Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NonMaxSuppressionV5Options");
            ds.finish()
        }
    }
    pub enum ScatterNdOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ScatterNdOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ScatterNdOptions<'a> {
        type Inner = ScatterNdOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ScatterNdOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ScatterNdOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ScatterNdOptionsArgs,
        ) -> flatbuffers::WIPOffset<ScatterNdOptions<'bldr>> {
            let mut builder = ScatterNdOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ScatterNdOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ScatterNdOptionsArgs {}
    impl<'a> Default for ScatterNdOptionsArgs {
        #[inline]
        fn default() -> Self {
            ScatterNdOptionsArgs {}
        }
    }

    pub struct ScatterNdOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ScatterNdOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ScatterNdOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ScatterNdOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ScatterNdOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ScatterNdOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ScatterNdOptions");
            ds.finish()
        }
    }
    pub enum SelectV2OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SelectV2Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SelectV2Options<'a> {
        type Inner = SelectV2Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SelectV2Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SelectV2Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SelectV2OptionsArgs,
        ) -> flatbuffers::WIPOffset<SelectV2Options<'bldr>> {
            let mut builder = SelectV2OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SelectV2Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SelectV2OptionsArgs {}
    impl<'a> Default for SelectV2OptionsArgs {
        #[inline]
        fn default() -> Self {
            SelectV2OptionsArgs {}
        }
    }

    pub struct SelectV2OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SelectV2OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SelectV2OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SelectV2OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SelectV2Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SelectV2Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SelectV2Options");
            ds.finish()
        }
    }
    pub enum DensifyOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DensifyOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DensifyOptions<'a> {
        type Inner = DensifyOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DensifyOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DensifyOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args DensifyOptionsArgs,
        ) -> flatbuffers::WIPOffset<DensifyOptions<'bldr>> {
            let mut builder = DensifyOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for DensifyOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct DensifyOptionsArgs {}
    impl<'a> Default for DensifyOptionsArgs {
        #[inline]
        fn default() -> Self {
            DensifyOptionsArgs {}
        }
    }

    pub struct DensifyOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DensifyOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DensifyOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DensifyOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DensifyOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DensifyOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DensifyOptions");
            ds.finish()
        }
    }
    pub enum SegmentSumOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SegmentSumOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SegmentSumOptions<'a> {
        type Inner = SegmentSumOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SegmentSumOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SegmentSumOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SegmentSumOptionsArgs,
        ) -> flatbuffers::WIPOffset<SegmentSumOptions<'bldr>> {
            let mut builder = SegmentSumOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SegmentSumOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SegmentSumOptionsArgs {}
    impl<'a> Default for SegmentSumOptionsArgs {
        #[inline]
        fn default() -> Self {
            SegmentSumOptionsArgs {}
        }
    }

    pub struct SegmentSumOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SegmentSumOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SegmentSumOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SegmentSumOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SegmentSumOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SegmentSumOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SegmentSumOptions");
            ds.finish()
        }
    }
    pub enum BatchMatMulOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BatchMatMulOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BatchMatMulOptions<'a> {
        type Inner = BatchMatMulOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BatchMatMulOptions<'a> {
        pub const VT_ADJ_X: flatbuffers::VOffsetT = 4;
        pub const VT_ADJ_Y: flatbuffers::VOffsetT = 6;
        pub const VT_ASYMMETRIC_QUANTIZE_INPUTS: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BatchMatMulOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BatchMatMulOptionsArgs,
        ) -> flatbuffers::WIPOffset<BatchMatMulOptions<'bldr>> {
            let mut builder = BatchMatMulOptionsBuilder::new(_fbb);
            builder.add_asymmetric_quantize_inputs(args.asymmetric_quantize_inputs);
            builder.add_adj_y(args.adj_y);
            builder.add_adj_x(args.adj_x);
            builder.finish()
        }

        #[inline]
        pub fn adj_x(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(BatchMatMulOptions::VT_ADJ_X, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn adj_y(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(BatchMatMulOptions::VT_ADJ_Y, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn asymmetric_quantize_inputs(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(
                        BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                        Some(false),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BatchMatMulOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("adj_x", Self::VT_ADJ_X, false)?
                .visit_field::<bool>("adj_y", Self::VT_ADJ_Y, false)?
                .visit_field::<bool>(
                    "asymmetric_quantize_inputs",
                    Self::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BatchMatMulOptionsArgs {
        pub adj_x: bool,
        pub adj_y: bool,
        pub asymmetric_quantize_inputs: bool,
    }
    impl<'a> Default for BatchMatMulOptionsArgs {
        #[inline]
        fn default() -> Self {
            BatchMatMulOptionsArgs {
                adj_x: false,
                adj_y: false,
                asymmetric_quantize_inputs: false,
            }
        }
    }

    pub struct BatchMatMulOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BatchMatMulOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_adj_x(&mut self, adj_x: bool) {
            self.fbb_
                .push_slot::<bool>(BatchMatMulOptions::VT_ADJ_X, adj_x, false);
        }
        #[inline]
        pub fn add_adj_y(&mut self, adj_y: bool) {
            self.fbb_
                .push_slot::<bool>(BatchMatMulOptions::VT_ADJ_Y, adj_y, false);
        }
        #[inline]
        pub fn add_asymmetric_quantize_inputs(&mut self, asymmetric_quantize_inputs: bool) {
            self.fbb_.push_slot::<bool>(
                BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS,
                asymmetric_quantize_inputs,
                false,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BatchMatMulOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BatchMatMulOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BatchMatMulOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BatchMatMulOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BatchMatMulOptions");
            ds.field("adj_x", &self.adj_x());
            ds.field("adj_y", &self.adj_y());
            ds.field(
                "asymmetric_quantize_inputs",
                &self.asymmetric_quantize_inputs(),
            );
            ds.finish()
        }
    }
    pub enum CumsumOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CumsumOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CumsumOptions<'a> {
        type Inner = CumsumOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CumsumOptions<'a> {
        pub const VT_EXCLUSIVE: flatbuffers::VOffsetT = 4;
        pub const VT_REVERSE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CumsumOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CumsumOptionsArgs,
        ) -> flatbuffers::WIPOffset<CumsumOptions<'bldr>> {
            let mut builder = CumsumOptionsBuilder::new(_fbb);
            builder.add_reverse(args.reverse);
            builder.add_exclusive(args.exclusive);
            builder.finish()
        }

        #[inline]
        pub fn exclusive(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(CumsumOptions::VT_EXCLUSIVE, Some(false))
                    .unwrap()
            }
        }
        #[inline]
        pub fn reverse(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(CumsumOptions::VT_REVERSE, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for CumsumOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("exclusive", Self::VT_EXCLUSIVE, false)?
                .visit_field::<bool>("reverse", Self::VT_REVERSE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct CumsumOptionsArgs {
        pub exclusive: bool,
        pub reverse: bool,
    }
    impl<'a> Default for CumsumOptionsArgs {
        #[inline]
        fn default() -> Self {
            CumsumOptionsArgs {
                exclusive: false,
                reverse: false,
            }
        }
    }

    pub struct CumsumOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CumsumOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_exclusive(&mut self, exclusive: bool) {
            self.fbb_
                .push_slot::<bool>(CumsumOptions::VT_EXCLUSIVE, exclusive, false);
        }
        #[inline]
        pub fn add_reverse(&mut self, reverse: bool) {
            self.fbb_
                .push_slot::<bool>(CumsumOptions::VT_REVERSE, reverse, false);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CumsumOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CumsumOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CumsumOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CumsumOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CumsumOptions");
            ds.field("exclusive", &self.exclusive());
            ds.field("reverse", &self.reverse());
            ds.finish()
        }
    }
    pub enum BroadcastToOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BroadcastToOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BroadcastToOptions<'a> {
        type Inner = BroadcastToOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BroadcastToOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BroadcastToOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args BroadcastToOptionsArgs,
        ) -> flatbuffers::WIPOffset<BroadcastToOptions<'bldr>> {
            let mut builder = BroadcastToOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for BroadcastToOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct BroadcastToOptionsArgs {}
    impl<'a> Default for BroadcastToOptionsArgs {
        #[inline]
        fn default() -> Self {
            BroadcastToOptionsArgs {}
        }
    }

    pub struct BroadcastToOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BroadcastToOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BroadcastToOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BroadcastToOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BroadcastToOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BroadcastToOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BroadcastToOptions");
            ds.finish()
        }
    }
    pub enum Rfft2dOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Rfft2dOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Rfft2dOptions<'a> {
        type Inner = Rfft2dOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Rfft2dOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Rfft2dOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args Rfft2dOptionsArgs,
        ) -> flatbuffers::WIPOffset<Rfft2dOptions<'bldr>> {
            let mut builder = Rfft2dOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for Rfft2dOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct Rfft2dOptionsArgs {}
    impl<'a> Default for Rfft2dOptionsArgs {
        #[inline]
        fn default() -> Self {
            Rfft2dOptionsArgs {}
        }
    }

    pub struct Rfft2dOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> Rfft2dOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> Rfft2dOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            Rfft2dOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Rfft2dOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Rfft2dOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Rfft2dOptions");
            ds.finish()
        }
    }
    pub enum HashtableOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HashtableOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HashtableOptions<'a> {
        type Inner = HashtableOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HashtableOptions<'a> {
        pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
        pub const VT_KEY_DTYPE: flatbuffers::VOffsetT = 6;
        pub const VT_VALUE_DTYPE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HashtableOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args HashtableOptionsArgs,
        ) -> flatbuffers::WIPOffset<HashtableOptions<'bldr>> {
            let mut builder = HashtableOptionsBuilder::new(_fbb);
            builder.add_table_id(args.table_id);
            builder.add_value_dtype(args.value_dtype);
            builder.add_key_dtype(args.key_dtype);
            builder.finish()
        }

        #[inline]
        pub fn table_id(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(HashtableOptions::VT_TABLE_ID, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn key_dtype(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(HashtableOptions::VT_KEY_DTYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
        #[inline]
        pub fn value_dtype(&self) -> TensorType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TensorType>(HashtableOptions::VT_VALUE_DTYPE, Some(TensorType::FLOAT32))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for HashtableOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("table_id", Self::VT_TABLE_ID, false)?
                .visit_field::<TensorType>("key_dtype", Self::VT_KEY_DTYPE, false)?
                .visit_field::<TensorType>("value_dtype", Self::VT_VALUE_DTYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct HashtableOptionsArgs {
        pub table_id: i32,
        pub key_dtype: TensorType,
        pub value_dtype: TensorType,
    }
    impl<'a> Default for HashtableOptionsArgs {
        #[inline]
        fn default() -> Self {
            HashtableOptionsArgs {
                table_id: 0,
                key_dtype: TensorType::FLOAT32,
                value_dtype: TensorType::FLOAT32,
            }
        }
    }

    pub struct HashtableOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HashtableOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_table_id(&mut self, table_id: i32) {
            self.fbb_
                .push_slot::<i32>(HashtableOptions::VT_TABLE_ID, table_id, 0);
        }
        #[inline]
        pub fn add_key_dtype(&mut self, key_dtype: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                HashtableOptions::VT_KEY_DTYPE,
                key_dtype,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn add_value_dtype(&mut self, value_dtype: TensorType) {
            self.fbb_.push_slot::<TensorType>(
                HashtableOptions::VT_VALUE_DTYPE,
                value_dtype,
                TensorType::FLOAT32,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HashtableOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HashtableOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HashtableOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HashtableOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HashtableOptions");
            ds.field("table_id", &self.table_id());
            ds.field("key_dtype", &self.key_dtype());
            ds.field("value_dtype", &self.value_dtype());
            ds.finish()
        }
    }
    pub enum HashtableFindOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HashtableFindOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HashtableFindOptions<'a> {
        type Inner = HashtableFindOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HashtableFindOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HashtableFindOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args HashtableFindOptionsArgs,
        ) -> flatbuffers::WIPOffset<HashtableFindOptions<'bldr>> {
            let mut builder = HashtableFindOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for HashtableFindOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct HashtableFindOptionsArgs {}
    impl<'a> Default for HashtableFindOptionsArgs {
        #[inline]
        fn default() -> Self {
            HashtableFindOptionsArgs {}
        }
    }

    pub struct HashtableFindOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HashtableFindOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HashtableFindOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HashtableFindOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HashtableFindOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HashtableFindOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HashtableFindOptions");
            ds.finish()
        }
    }
    pub enum HashtableImportOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HashtableImportOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HashtableImportOptions<'a> {
        type Inner = HashtableImportOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HashtableImportOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HashtableImportOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args HashtableImportOptionsArgs,
        ) -> flatbuffers::WIPOffset<HashtableImportOptions<'bldr>> {
            let mut builder = HashtableImportOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for HashtableImportOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct HashtableImportOptionsArgs {}
    impl<'a> Default for HashtableImportOptionsArgs {
        #[inline]
        fn default() -> Self {
            HashtableImportOptionsArgs {}
        }
    }

    pub struct HashtableImportOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HashtableImportOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HashtableImportOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HashtableImportOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HashtableImportOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HashtableImportOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HashtableImportOptions");
            ds.finish()
        }
    }
    pub enum HashtableSizeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct HashtableSizeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for HashtableSizeOptions<'a> {
        type Inner = HashtableSizeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> HashtableSizeOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            HashtableSizeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args HashtableSizeOptionsArgs,
        ) -> flatbuffers::WIPOffset<HashtableSizeOptions<'bldr>> {
            let mut builder = HashtableSizeOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for HashtableSizeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct HashtableSizeOptionsArgs {}
    impl<'a> Default for HashtableSizeOptionsArgs {
        #[inline]
        fn default() -> Self {
            HashtableSizeOptionsArgs {}
        }
    }

    pub struct HashtableSizeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> HashtableSizeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> HashtableSizeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            HashtableSizeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<HashtableSizeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for HashtableSizeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("HashtableSizeOptions");
            ds.finish()
        }
    }
    pub enum VarHandleOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct VarHandleOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for VarHandleOptions<'a> {
        type Inner = VarHandleOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> VarHandleOptions<'a> {
        pub const VT_CONTAINER: flatbuffers::VOffsetT = 4;
        pub const VT_SHARED_NAME: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            VarHandleOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VarHandleOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<VarHandleOptions<'bldr>> {
            let mut builder = VarHandleOptionsBuilder::new(_fbb);
            if let Some(x) = args.shared_name {
                builder.add_shared_name(x);
            }
            if let Some(x) = args.container {
                builder.add_container(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn container(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(VarHandleOptions::VT_CONTAINER, None)
            }
        }
        #[inline]
        pub fn shared_name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    VarHandleOptions::VT_SHARED_NAME,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for VarHandleOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "container",
                    Self::VT_CONTAINER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "shared_name",
                    Self::VT_SHARED_NAME,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct VarHandleOptionsArgs<'a> {
        pub container: Option<flatbuffers::WIPOffset<&'a str>>,
        pub shared_name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for VarHandleOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            VarHandleOptionsArgs {
                container: None,
                shared_name: None,
            }
        }
    }

    pub struct VarHandleOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VarHandleOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_container(&mut self, container: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VarHandleOptions::VT_CONTAINER,
                container,
            );
        }
        #[inline]
        pub fn add_shared_name(&mut self, shared_name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                VarHandleOptions::VT_SHARED_NAME,
                shared_name,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> VarHandleOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VarHandleOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<VarHandleOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for VarHandleOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("VarHandleOptions");
            ds.field("container", &self.container());
            ds.field("shared_name", &self.shared_name());
            ds.finish()
        }
    }
    pub enum ReadVariableOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ReadVariableOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ReadVariableOptions<'a> {
        type Inner = ReadVariableOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ReadVariableOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ReadVariableOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ReadVariableOptionsArgs,
        ) -> flatbuffers::WIPOffset<ReadVariableOptions<'bldr>> {
            let mut builder = ReadVariableOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ReadVariableOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ReadVariableOptionsArgs {}
    impl<'a> Default for ReadVariableOptionsArgs {
        #[inline]
        fn default() -> Self {
            ReadVariableOptionsArgs {}
        }
    }

    pub struct ReadVariableOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ReadVariableOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ReadVariableOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ReadVariableOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ReadVariableOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ReadVariableOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ReadVariableOptions");
            ds.finish()
        }
    }
    pub enum AssignVariableOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssignVariableOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssignVariableOptions<'a> {
        type Inner = AssignVariableOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AssignVariableOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssignVariableOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args AssignVariableOptionsArgs,
        ) -> flatbuffers::WIPOffset<AssignVariableOptions<'bldr>> {
            let mut builder = AssignVariableOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for AssignVariableOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct AssignVariableOptionsArgs {}
    impl<'a> Default for AssignVariableOptionsArgs {
        #[inline]
        fn default() -> Self {
            AssignVariableOptionsArgs {}
        }
    }

    pub struct AssignVariableOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AssignVariableOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AssignVariableOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AssignVariableOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssignVariableOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssignVariableOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssignVariableOptions");
            ds.finish()
        }
    }
    pub enum RandomOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RandomOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RandomOptions<'a> {
        type Inner = RandomOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RandomOptions<'a> {
        pub const VT_SEED: flatbuffers::VOffsetT = 4;
        pub const VT_SEED2: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RandomOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RandomOptionsArgs,
        ) -> flatbuffers::WIPOffset<RandomOptions<'bldr>> {
            let mut builder = RandomOptionsBuilder::new(_fbb);
            builder.add_seed2(args.seed2);
            builder.add_seed(args.seed);
            builder.finish()
        }

        #[inline]
        pub fn seed(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(RandomOptions::VT_SEED, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn seed2(&self) -> i64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i64>(RandomOptions::VT_SEED2, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for RandomOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i64>("seed", Self::VT_SEED, false)?
                .visit_field::<i64>("seed2", Self::VT_SEED2, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RandomOptionsArgs {
        pub seed: i64,
        pub seed2: i64,
    }
    impl<'a> Default for RandomOptionsArgs {
        #[inline]
        fn default() -> Self {
            RandomOptionsArgs { seed: 0, seed2: 0 }
        }
    }

    pub struct RandomOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RandomOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_seed(&mut self, seed: i64) {
            self.fbb_.push_slot::<i64>(RandomOptions::VT_SEED, seed, 0);
        }
        #[inline]
        pub fn add_seed2(&mut self, seed2: i64) {
            self.fbb_
                .push_slot::<i64>(RandomOptions::VT_SEED2, seed2, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RandomOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RandomOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RandomOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RandomOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RandomOptions");
            ds.field("seed", &self.seed());
            ds.field("seed2", &self.seed2());
            ds.finish()
        }
    }
    pub enum BucketizeOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BucketizeOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BucketizeOptions<'a> {
        type Inner = BucketizeOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BucketizeOptions<'a> {
        pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BucketizeOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BucketizeOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<BucketizeOptions<'bldr>> {
            let mut builder = BucketizeOptionsBuilder::new(_fbb);
            if let Some(x) = args.boundaries {
                builder.add_boundaries(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        BucketizeOptions::VT_BOUNDARIES,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for BucketizeOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "boundaries",
                    Self::VT_BOUNDARIES,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BucketizeOptionsArgs<'a> {
        pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    }
    impl<'a> Default for BucketizeOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            BucketizeOptionsArgs { boundaries: None }
        }
    }

    pub struct BucketizeOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BucketizeOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_boundaries(
            &mut self,
            boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BucketizeOptions::VT_BOUNDARIES,
                boundaries,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BucketizeOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BucketizeOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BucketizeOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BucketizeOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BucketizeOptions");
            ds.field("boundaries", &self.boundaries());
            ds.finish()
        }
    }
    pub enum GeluOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct GeluOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for GeluOptions<'a> {
        type Inner = GeluOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> GeluOptions<'a> {
        pub const VT_APPROXIMATE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            GeluOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args GeluOptionsArgs,
        ) -> flatbuffers::WIPOffset<GeluOptions<'bldr>> {
            let mut builder = GeluOptionsBuilder::new(_fbb);
            builder.add_approximate(args.approximate);
            builder.finish()
        }

        #[inline]
        pub fn approximate(&self) -> bool {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<bool>(GeluOptions::VT_APPROXIMATE, Some(false))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for GeluOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<bool>("approximate", Self::VT_APPROXIMATE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct GeluOptionsArgs {
        pub approximate: bool,
    }
    impl<'a> Default for GeluOptionsArgs {
        #[inline]
        fn default() -> Self {
            GeluOptionsArgs { approximate: false }
        }
    }

    pub struct GeluOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> GeluOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_approximate(&mut self, approximate: bool) {
            self.fbb_
                .push_slot::<bool>(GeluOptions::VT_APPROXIMATE, approximate, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GeluOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            GeluOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<GeluOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for GeluOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("GeluOptions");
            ds.field("approximate", &self.approximate());
            ds.finish()
        }
    }
    pub enum DynamicUpdateSliceOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct DynamicUpdateSliceOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for DynamicUpdateSliceOptions<'a> {
        type Inner = DynamicUpdateSliceOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> DynamicUpdateSliceOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            DynamicUpdateSliceOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args DynamicUpdateSliceOptionsArgs,
        ) -> flatbuffers::WIPOffset<DynamicUpdateSliceOptions<'bldr>> {
            let mut builder = DynamicUpdateSliceOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for DynamicUpdateSliceOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct DynamicUpdateSliceOptionsArgs {}
    impl<'a> Default for DynamicUpdateSliceOptionsArgs {
        #[inline]
        fn default() -> Self {
            DynamicUpdateSliceOptionsArgs {}
        }
    }

    pub struct DynamicUpdateSliceOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> DynamicUpdateSliceOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> DynamicUpdateSliceOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            DynamicUpdateSliceOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<DynamicUpdateSliceOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for DynamicUpdateSliceOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("DynamicUpdateSliceOptions");
            ds.finish()
        }
    }
    pub enum UnsortedSegmentProdOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsortedSegmentProdOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentProdOptions<'a> {
        type Inner = UnsortedSegmentProdOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsortedSegmentProdOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsortedSegmentProdOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args UnsortedSegmentProdOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnsortedSegmentProdOptions<'bldr>> {
            let mut builder = UnsortedSegmentProdOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for UnsortedSegmentProdOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct UnsortedSegmentProdOptionsArgs {}
    impl<'a> Default for UnsortedSegmentProdOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnsortedSegmentProdOptionsArgs {}
        }
    }

    pub struct UnsortedSegmentProdOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsortedSegmentProdOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsortedSegmentProdOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsortedSegmentProdOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentProdOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsortedSegmentProdOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsortedSegmentProdOptions");
            ds.finish()
        }
    }
    pub enum UnsortedSegmentMaxOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsortedSegmentMaxOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentMaxOptions<'a> {
        type Inner = UnsortedSegmentMaxOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsortedSegmentMaxOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsortedSegmentMaxOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args UnsortedSegmentMaxOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnsortedSegmentMaxOptions<'bldr>> {
            let mut builder = UnsortedSegmentMaxOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for UnsortedSegmentMaxOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct UnsortedSegmentMaxOptionsArgs {}
    impl<'a> Default for UnsortedSegmentMaxOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnsortedSegmentMaxOptionsArgs {}
        }
    }

    pub struct UnsortedSegmentMaxOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsortedSegmentMaxOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsortedSegmentMaxOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsortedSegmentMaxOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentMaxOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsortedSegmentMaxOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsortedSegmentMaxOptions");
            ds.finish()
        }
    }
    pub enum UnsortedSegmentSumOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsortedSegmentSumOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentSumOptions<'a> {
        type Inner = UnsortedSegmentSumOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsortedSegmentSumOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsortedSegmentSumOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args UnsortedSegmentSumOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnsortedSegmentSumOptions<'bldr>> {
            let mut builder = UnsortedSegmentSumOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for UnsortedSegmentSumOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct UnsortedSegmentSumOptionsArgs {}
    impl<'a> Default for UnsortedSegmentSumOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnsortedSegmentSumOptionsArgs {}
        }
    }

    pub struct UnsortedSegmentSumOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsortedSegmentSumOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsortedSegmentSumOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsortedSegmentSumOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentSumOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsortedSegmentSumOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsortedSegmentSumOptions");
            ds.finish()
        }
    }
    pub enum ATan2OptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ATan2Options<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ATan2Options<'a> {
        type Inner = ATan2Options<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ATan2Options<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ATan2Options { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args ATan2OptionsArgs,
        ) -> flatbuffers::WIPOffset<ATan2Options<'bldr>> {
            let mut builder = ATan2OptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for ATan2Options<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct ATan2OptionsArgs {}
    impl<'a> Default for ATan2OptionsArgs {
        #[inline]
        fn default() -> Self {
            ATan2OptionsArgs {}
        }
    }

    pub struct ATan2OptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ATan2OptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ATan2OptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ATan2OptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ATan2Options<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ATan2Options<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ATan2Options");
            ds.finish()
        }
    }
    pub enum UnsortedSegmentMinOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnsortedSegmentMinOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnsortedSegmentMinOptions<'a> {
        type Inner = UnsortedSegmentMinOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnsortedSegmentMinOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnsortedSegmentMinOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args UnsortedSegmentMinOptionsArgs,
        ) -> flatbuffers::WIPOffset<UnsortedSegmentMinOptions<'bldr>> {
            let mut builder = UnsortedSegmentMinOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for UnsortedSegmentMinOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct UnsortedSegmentMinOptionsArgs {}
    impl<'a> Default for UnsortedSegmentMinOptionsArgs {
        #[inline]
        fn default() -> Self {
            UnsortedSegmentMinOptionsArgs {}
        }
    }

    pub struct UnsortedSegmentMinOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> UnsortedSegmentMinOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> UnsortedSegmentMinOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            UnsortedSegmentMinOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnsortedSegmentMinOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnsortedSegmentMinOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnsortedSegmentMinOptions");
            ds.finish()
        }
    }
    pub enum SignOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SignOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SignOptions<'a> {
        type Inner = SignOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SignOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SignOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args SignOptionsArgs,
        ) -> flatbuffers::WIPOffset<SignOptions<'bldr>> {
            let mut builder = SignOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for SignOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct SignOptionsArgs {}
    impl<'a> Default for SignOptionsArgs {
        #[inline]
        fn default() -> Self {
            SignOptionsArgs {}
        }
    }

    pub struct SignOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SignOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SignOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SignOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SignOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SignOptions");
            ds.finish()
        }
    }
    pub enum BitcastOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BitcastOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BitcastOptions<'a> {
        type Inner = BitcastOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BitcastOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BitcastOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args BitcastOptionsArgs,
        ) -> flatbuffers::WIPOffset<BitcastOptions<'bldr>> {
            let mut builder = BitcastOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for BitcastOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct BitcastOptionsArgs {}
    impl<'a> Default for BitcastOptionsArgs {
        #[inline]
        fn default() -> Self {
            BitcastOptionsArgs {}
        }
    }

    pub struct BitcastOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BitcastOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BitcastOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BitcastOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BitcastOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BitcastOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BitcastOptions");
            ds.finish()
        }
    }
    pub enum BitwiseXorOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BitwiseXorOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BitwiseXorOptions<'a> {
        type Inner = BitwiseXorOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BitwiseXorOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BitwiseXorOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args BitwiseXorOptionsArgs,
        ) -> flatbuffers::WIPOffset<BitwiseXorOptions<'bldr>> {
            let mut builder = BitwiseXorOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for BitwiseXorOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct BitwiseXorOptionsArgs {}
    impl<'a> Default for BitwiseXorOptionsArgs {
        #[inline]
        fn default() -> Self {
            BitwiseXorOptionsArgs {}
        }
    }

    pub struct BitwiseXorOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BitwiseXorOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BitwiseXorOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BitwiseXorOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BitwiseXorOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BitwiseXorOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BitwiseXorOptions");
            ds.finish()
        }
    }
    pub enum RightShiftOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RightShiftOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RightShiftOptions<'a> {
        type Inner = RightShiftOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RightShiftOptions<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RightShiftOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args RightShiftOptionsArgs,
        ) -> flatbuffers::WIPOffset<RightShiftOptions<'bldr>> {
            let mut builder = RightShiftOptionsBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for RightShiftOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct RightShiftOptionsArgs {}
    impl<'a> Default for RightShiftOptionsArgs {
        #[inline]
        fn default() -> Self {
            RightShiftOptionsArgs {}
        }
    }

    pub struct RightShiftOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RightShiftOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RightShiftOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RightShiftOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RightShiftOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RightShiftOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RightShiftOptions");
            ds.finish()
        }
    }
    pub enum OperatorCodeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct OperatorCode<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for OperatorCode<'a> {
        type Inner = OperatorCode<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> OperatorCode<'a> {
        pub const VT_DEPRECATED_BUILTIN_CODE: flatbuffers::VOffsetT = 4;
        pub const VT_CUSTOM_CODE: flatbuffers::VOffsetT = 6;
        pub const VT_VERSION: flatbuffers::VOffsetT = 8;
        pub const VT_BUILTIN_CODE: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            OperatorCode { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OperatorCodeArgs<'args>,
        ) -> flatbuffers::WIPOffset<OperatorCode<'bldr>> {
            let mut builder = OperatorCodeBuilder::new(_fbb);
            builder.add_builtin_code(args.builtin_code);
            builder.add_version(args.version);
            if let Some(x) = args.custom_code {
                builder.add_custom_code(x);
            }
            builder.add_deprecated_builtin_code(args.deprecated_builtin_code);
            builder.finish()
        }

        #[inline]
        pub fn deprecated_builtin_code(&self) -> i8 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i8>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn custom_code(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(OperatorCode::VT_CUSTOM_CODE, None)
            }
        }
        #[inline]
        pub fn version(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<i32>(OperatorCode::VT_VERSION, Some(1))
                    .unwrap()
            }
        }
        #[inline]
        pub fn builtin_code(&self) -> BuiltinOperator {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<BuiltinOperator>(
                        OperatorCode::VT_BUILTIN_CODE,
                        Some(BuiltinOperator::ADD),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for OperatorCode<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i8>(
                    "deprecated_builtin_code",
                    Self::VT_DEPRECATED_BUILTIN_CODE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "custom_code",
                    Self::VT_CUSTOM_CODE,
                    false,
                )?
                .visit_field::<i32>("version", Self::VT_VERSION, false)?
                .visit_field::<BuiltinOperator>("builtin_code", Self::VT_BUILTIN_CODE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct OperatorCodeArgs<'a> {
        pub deprecated_builtin_code: i8,
        pub custom_code: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: i32,
        pub builtin_code: BuiltinOperator,
    }
    impl<'a> Default for OperatorCodeArgs<'a> {
        #[inline]
        fn default() -> Self {
            OperatorCodeArgs {
                deprecated_builtin_code: 0,
                custom_code: None,
                version: 1,
                builtin_code: BuiltinOperator::ADD,
            }
        }
    }

    pub struct OperatorCodeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OperatorCodeBuilder<'a, 'b> {
        #[inline]
        pub fn add_deprecated_builtin_code(&mut self, deprecated_builtin_code: i8) {
            self.fbb_.push_slot::<i8>(
                OperatorCode::VT_DEPRECATED_BUILTIN_CODE,
                deprecated_builtin_code,
                0,
            );
        }
        #[inline]
        pub fn add_custom_code(&mut self, custom_code: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                OperatorCode::VT_CUSTOM_CODE,
                custom_code,
            );
        }
        #[inline]
        pub fn add_version(&mut self, version: i32) {
            self.fbb_
                .push_slot::<i32>(OperatorCode::VT_VERSION, version, 1);
        }
        #[inline]
        pub fn add_builtin_code(&mut self, builtin_code: BuiltinOperator) {
            self.fbb_.push_slot::<BuiltinOperator>(
                OperatorCode::VT_BUILTIN_CODE,
                builtin_code,
                BuiltinOperator::ADD,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> OperatorCodeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OperatorCodeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<OperatorCode<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for OperatorCode<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("OperatorCode");
            ds.field("deprecated_builtin_code", &self.deprecated_builtin_code());
            ds.field("custom_code", &self.custom_code());
            ds.field("version", &self.version());
            ds.field("builtin_code", &self.builtin_code());
            ds.finish()
        }
    }
    pub enum OperatorOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Operator<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Operator<'a> {
        type Inner = Operator<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Operator<'a> {
        pub const VT_OPCODE_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
        pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
        pub const VT_BUILTIN_OPTIONS_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_BUILTIN_OPTIONS: flatbuffers::VOffsetT = 12;
        pub const VT_CUSTOM_OPTIONS: flatbuffers::VOffsetT = 14;
        pub const VT_CUSTOM_OPTIONS_FORMAT: flatbuffers::VOffsetT = 16;
        pub const VT_MUTATING_VARIABLE_INPUTS: flatbuffers::VOffsetT = 18;
        pub const VT_INTERMEDIATES: flatbuffers::VOffsetT = 20;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Operator { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args OperatorArgs<'args>,
        ) -> flatbuffers::WIPOffset<Operator<'bldr>> {
            let mut builder = OperatorBuilder::new(_fbb);
            if let Some(x) = args.intermediates {
                builder.add_intermediates(x);
            }
            if let Some(x) = args.mutating_variable_inputs {
                builder.add_mutating_variable_inputs(x);
            }
            if let Some(x) = args.custom_options {
                builder.add_custom_options(x);
            }
            if let Some(x) = args.builtin_options {
                builder.add_builtin_options(x);
            }
            if let Some(x) = args.outputs {
                builder.add_outputs(x);
            }
            if let Some(x) = args.inputs {
                builder.add_inputs(x);
            }
            builder.add_opcode_index(args.opcode_index);
            builder.add_custom_options_format(args.custom_options_format);
            builder.add_builtin_options_type(args.builtin_options_type);
            builder.finish()
        }

        #[inline]
        pub fn opcode_index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(Operator::VT_OPCODE_INDEX, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Operator::VT_INPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Operator::VT_OUTPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn builtin_options_type(&self) -> BuiltinOptions {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<BuiltinOptions>(
                        Operator::VT_BUILTIN_OPTIONS_TYPE,
                        Some(BuiltinOptions::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn builtin_options(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Operator::VT_BUILTIN_OPTIONS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn custom_options(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Operator::VT_CUSTOM_OPTIONS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn custom_options_format(&self) -> CustomOptionsFormat {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<CustomOptionsFormat>(
                        Operator::VT_CUSTOM_OPTIONS_FORMAT,
                        Some(CustomOptionsFormat::FLEXBUFFERS),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn mutating_variable_inputs(&self) -> Option<flatbuffers::Vector<'a, bool>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(
                        Operator::VT_MUTATING_VARIABLE_INPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn intermediates(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Operator::VT_INTERMEDIATES,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_conv_2_doptions(&self) -> Option<Conv2DOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::Conv2DOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Conv2DOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_depthwise_conv_2_doptions(
            &self,
        ) -> Option<DepthwiseConv2DOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DepthwiseConv2DOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DepthwiseConv2DOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_concat_embeddings_options(
            &self,
        ) -> Option<ConcatEmbeddingsOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ConcatEmbeddingsOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ConcatEmbeddingsOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_lshprojection_options(&self) -> Option<LSHProjectionOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LSHProjectionOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LSHProjectionOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_pool_2_doptions(&self) -> Option<Pool2DOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::Pool2DOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Pool2DOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_svdfoptions(&self) -> Option<SVDFOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SVDFOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SVDFOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_rnnoptions(&self) -> Option<RNNOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::RNNOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RNNOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_fully_connected_options(
            &self,
        ) -> Option<FullyConnectedOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::FullyConnectedOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FullyConnectedOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_softmax_options(&self) -> Option<SoftmaxOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SoftmaxOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SoftmaxOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_concatenation_options(&self) -> Option<ConcatenationOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ConcatenationOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ConcatenationOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_add_options(&self) -> Option<AddOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::AddOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AddOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_l2_norm_options(&self) -> Option<L2NormOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::L2NormOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { L2NormOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_local_response_normalization_options(
            &self,
        ) -> Option<LocalResponseNormalizationOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LocalResponseNormalizationOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LocalResponseNormalizationOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_lstmoptions(&self) -> Option<LSTMOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LSTMOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LSTMOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_resize_bilinear_options(
            &self,
        ) -> Option<ResizeBilinearOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ResizeBilinearOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ResizeBilinearOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_call_options(&self) -> Option<CallOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::CallOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CallOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_reshape_options(&self) -> Option<ReshapeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ReshapeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ReshapeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_skip_gram_options(&self) -> Option<SkipGramOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SkipGramOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SkipGramOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_space_to_depth_options(&self) -> Option<SpaceToDepthOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SpaceToDepthOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SpaceToDepthOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_embedding_lookup_sparse_options(
            &self,
        ) -> Option<EmbeddingLookupSparseOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::EmbeddingLookupSparseOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { EmbeddingLookupSparseOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_mul_options(&self) -> Option<MulOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::MulOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MulOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_pad_options(&self) -> Option<PadOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::PadOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PadOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_gather_options(&self) -> Option<GatherOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::GatherOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GatherOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_batch_to_space_ndoptions(
            &self,
        ) -> Option<BatchToSpaceNDOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BatchToSpaceNDOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BatchToSpaceNDOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_space_to_batch_ndoptions(
            &self,
        ) -> Option<SpaceToBatchNDOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SpaceToBatchNDOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SpaceToBatchNDOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_transpose_options(&self) -> Option<TransposeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::TransposeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { TransposeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_reducer_options(&self) -> Option<ReducerOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ReducerOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ReducerOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_sub_options(&self) -> Option<SubOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SubOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SubOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_div_options(&self) -> Option<DivOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DivOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DivOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_squeeze_options(&self) -> Option<SqueezeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SqueezeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SqueezeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_sequence_rnnoptions(&self) -> Option<SequenceRNNOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SequenceRNNOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SequenceRNNOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_strided_slice_options(&self) -> Option<StridedSliceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::StridedSliceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { StridedSliceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_exp_options(&self) -> Option<ExpOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ExpOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ExpOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_top_kv2_options(&self) -> Option<TopKV2Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::TopKV2Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { TopKV2Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_split_options(&self) -> Option<SplitOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SplitOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SplitOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_log_softmax_options(&self) -> Option<LogSoftmaxOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LogSoftmaxOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LogSoftmaxOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_cast_options(&self) -> Option<CastOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::CastOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CastOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_dequantize_options(&self) -> Option<DequantizeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DequantizeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DequantizeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_maximum_minimum_options(
            &self,
        ) -> Option<MaximumMinimumOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::MaximumMinimumOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MaximumMinimumOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_arg_max_options(&self) -> Option<ArgMaxOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ArgMaxOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ArgMaxOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_less_options(&self) -> Option<LessOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LessOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LessOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_neg_options(&self) -> Option<NegOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::NegOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { NegOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_pad_v2_options(&self) -> Option<PadV2Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::PadV2Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PadV2Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_greater_options(&self) -> Option<GreaterOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::GreaterOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GreaterOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_greater_equal_options(&self) -> Option<GreaterEqualOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::GreaterEqualOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GreaterEqualOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_less_equal_options(&self) -> Option<LessEqualOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LessEqualOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LessEqualOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_select_options(&self) -> Option<SelectOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SelectOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SelectOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_slice_options(&self) -> Option<SliceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SliceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SliceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_transpose_conv_options(
            &self,
        ) -> Option<TransposeConvOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::TransposeConvOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { TransposeConvOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_sparse_to_dense_options(
            &self,
        ) -> Option<SparseToDenseOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SparseToDenseOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SparseToDenseOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_tile_options(&self) -> Option<TileOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::TileOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { TileOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_expand_dims_options(&self) -> Option<ExpandDimsOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ExpandDimsOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ExpandDimsOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_equal_options(&self) -> Option<EqualOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::EqualOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { EqualOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_not_equal_options(&self) -> Option<NotEqualOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::NotEqualOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { NotEqualOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_shape_options(&self) -> Option<ShapeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ShapeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ShapeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_pow_options(&self) -> Option<PowOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::PowOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PowOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_arg_min_options(&self) -> Option<ArgMinOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ArgMinOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ArgMinOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_fake_quant_options(&self) -> Option<FakeQuantOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::FakeQuantOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FakeQuantOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_pack_options(&self) -> Option<PackOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::PackOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { PackOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_logical_or_options(&self) -> Option<LogicalOrOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LogicalOrOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LogicalOrOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_one_hot_options(&self) -> Option<OneHotOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::OneHotOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { OneHotOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_logical_and_options(&self) -> Option<LogicalAndOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LogicalAndOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LogicalAndOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_logical_not_options(&self) -> Option<LogicalNotOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LogicalNotOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LogicalNotOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unpack_options(&self) -> Option<UnpackOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnpackOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnpackOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_floor_div_options(&self) -> Option<FloorDivOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::FloorDivOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FloorDivOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_square_options(&self) -> Option<SquareOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SquareOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SquareOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_zeros_like_options(&self) -> Option<ZerosLikeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ZerosLikeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ZerosLikeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_fill_options(&self) -> Option<FillOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::FillOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FillOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_bidirectional_sequence_lstmoptions(
            &self,
        ) -> Option<BidirectionalSequenceLSTMOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceLSTMOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BidirectionalSequenceLSTMOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_bidirectional_sequence_rnnoptions(
            &self,
        ) -> Option<BidirectionalSequenceRNNOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceRNNOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BidirectionalSequenceRNNOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unidirectional_sequence_lstmoptions(
            &self,
        ) -> Option<UnidirectionalSequenceLSTMOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnidirectionalSequenceLSTMOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnidirectionalSequenceLSTMOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_floor_mod_options(&self) -> Option<FloorModOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::FloorModOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FloorModOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_range_options(&self) -> Option<RangeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::RangeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RangeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_resize_nearest_neighbor_options(
            &self,
        ) -> Option<ResizeNearestNeighborOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ResizeNearestNeighborOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ResizeNearestNeighborOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_leaky_relu_options(&self) -> Option<LeakyReluOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::LeakyReluOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { LeakyReluOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_squared_difference_options(
            &self,
        ) -> Option<SquaredDifferenceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SquaredDifferenceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SquaredDifferenceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_mirror_pad_options(&self) -> Option<MirrorPadOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::MirrorPadOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MirrorPadOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_abs_options(&self) -> Option<AbsOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::AbsOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AbsOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_split_voptions(&self) -> Option<SplitVOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SplitVOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SplitVOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unique_options(&self) -> Option<UniqueOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UniqueOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UniqueOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_reverse_v2_options(&self) -> Option<ReverseV2Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ReverseV2Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ReverseV2Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_add_noptions(&self) -> Option<AddNOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::AddNOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AddNOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_gather_nd_options(&self) -> Option<GatherNdOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::GatherNdOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GatherNdOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_cos_options(&self) -> Option<CosOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::CosOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CosOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_where_options(&self) -> Option<WhereOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::WhereOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { WhereOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_rank_options(&self) -> Option<RankOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::RankOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RankOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_reverse_sequence_options(
            &self,
        ) -> Option<ReverseSequenceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ReverseSequenceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ReverseSequenceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_matrix_diag_options(&self) -> Option<MatrixDiagOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::MatrixDiagOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MatrixDiagOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_quantize_options(&self) -> Option<QuantizeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::QuantizeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { QuantizeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_matrix_set_diag_options(
            &self,
        ) -> Option<MatrixSetDiagOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::MatrixSetDiagOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MatrixSetDiagOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_hard_swish_options(&self) -> Option<HardSwishOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::HardSwishOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { HardSwishOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_if_options(&self) -> Option<IfOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::IfOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { IfOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_while_options(&self) -> Option<WhileOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::WhileOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { WhileOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_depth_to_space_options(&self) -> Option<DepthToSpaceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DepthToSpaceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DepthToSpaceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_non_max_suppression_v4_options(
            &self,
        ) -> Option<NonMaxSuppressionV4Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV4Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { NonMaxSuppressionV4Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_non_max_suppression_v5_options(
            &self,
        ) -> Option<NonMaxSuppressionV5Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV5Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { NonMaxSuppressionV5Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_scatter_nd_options(&self) -> Option<ScatterNdOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ScatterNdOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ScatterNdOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_select_v2_options(&self) -> Option<SelectV2Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SelectV2Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SelectV2Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_densify_options(&self) -> Option<DensifyOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DensifyOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DensifyOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_segment_sum_options(&self) -> Option<SegmentSumOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SegmentSumOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SegmentSumOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_batch_mat_mul_options(&self) -> Option<BatchMatMulOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BatchMatMulOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BatchMatMulOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_cumsum_options(&self) -> Option<CumsumOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::CumsumOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CumsumOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_call_once_options(&self) -> Option<CallOnceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::CallOnceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { CallOnceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_broadcast_to_options(&self) -> Option<BroadcastToOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BroadcastToOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BroadcastToOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_rfft_2d_options(&self) -> Option<Rfft2dOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::Rfft2dOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Rfft2dOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_conv_3_doptions(&self) -> Option<Conv3DOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::Conv3DOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { Conv3DOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_hashtable_options(&self) -> Option<HashtableOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::HashtableOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { HashtableOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_hashtable_find_options(
            &self,
        ) -> Option<HashtableFindOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::HashtableFindOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { HashtableFindOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_hashtable_import_options(
            &self,
        ) -> Option<HashtableImportOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::HashtableImportOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { HashtableImportOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_hashtable_size_options(
            &self,
        ) -> Option<HashtableSizeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::HashtableSizeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { HashtableSizeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_var_handle_options(&self) -> Option<VarHandleOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::VarHandleOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { VarHandleOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_read_variable_options(&self) -> Option<ReadVariableOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ReadVariableOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ReadVariableOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_assign_variable_options(
            &self,
        ) -> Option<AssignVariableOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::AssignVariableOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AssignVariableOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_random_options(&self) -> Option<RandomOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::RandomOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RandomOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_bucketize_options(&self) -> Option<BucketizeOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BucketizeOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BucketizeOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_gelu_options(&self) -> Option<GeluOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::GeluOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { GeluOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_dynamic_update_slice_options(
            &self,
        ) -> Option<DynamicUpdateSliceOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::DynamicUpdateSliceOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { DynamicUpdateSliceOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unsorted_segment_prod_options(
            &self,
        ) -> Option<UnsortedSegmentProdOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentProdOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnsortedSegmentProdOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unsorted_segment_max_options(
            &self,
        ) -> Option<UnsortedSegmentMaxOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentMaxOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnsortedSegmentMaxOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unsorted_segment_min_options(
            &self,
        ) -> Option<UnsortedSegmentMinOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentMinOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnsortedSegmentMinOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_unsorted_segment_sum_options(
            &self,
        ) -> Option<UnsortedSegmentSumOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::UnsortedSegmentSumOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnsortedSegmentSumOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_atan_2_options(&self) -> Option<ATan2Options<'a>> {
            if self.builtin_options_type() == BuiltinOptions::ATan2Options {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ATan2Options::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_sign_options(&self) -> Option<SignOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::SignOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SignOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_bitcast_options(&self) -> Option<BitcastOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BitcastOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BitcastOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_bitwise_xor_options(&self) -> Option<BitwiseXorOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::BitwiseXorOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BitwiseXorOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn builtin_options_as_right_shift_options(&self) -> Option<RightShiftOptions<'a>> {
            if self.builtin_options_type() == BuiltinOptions::RightShiftOptions {
                self.builtin_options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RightShiftOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Operator<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_field::<u32>("opcode_index", Self::VT_OPCODE_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_union::<BuiltinOptions, _>("builtin_options_type", Self::VT_BUILTIN_OPTIONS_TYPE, "builtin_options", Self::VT_BUILTIN_OPTIONS, false, |key, v, pos| {
        match key {
          BuiltinOptions::Conv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv2DOptions>>("BuiltinOptions::Conv2DOptions", pos),
          BuiltinOptions::DepthwiseConv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthwiseConv2DOptions>>("BuiltinOptions::DepthwiseConv2DOptions", pos),
          BuiltinOptions::ConcatEmbeddingsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatEmbeddingsOptions>>("BuiltinOptions::ConcatEmbeddingsOptions", pos),
          BuiltinOptions::LSHProjectionOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSHProjectionOptions>>("BuiltinOptions::LSHProjectionOptions", pos),
          BuiltinOptions::Pool2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Pool2DOptions>>("BuiltinOptions::Pool2DOptions", pos),
          BuiltinOptions::SVDFOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVDFOptions>>("BuiltinOptions::SVDFOptions", pos),
          BuiltinOptions::RNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RNNOptions>>("BuiltinOptions::RNNOptions", pos),
          BuiltinOptions::FullyConnectedOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FullyConnectedOptions>>("BuiltinOptions::FullyConnectedOptions", pos),
          BuiltinOptions::SoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxOptions>>("BuiltinOptions::SoftmaxOptions", pos),
          BuiltinOptions::ConcatenationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatenationOptions>>("BuiltinOptions::ConcatenationOptions", pos),
          BuiltinOptions::AddOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddOptions>>("BuiltinOptions::AddOptions", pos),
          BuiltinOptions::L2NormOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<L2NormOptions>>("BuiltinOptions::L2NormOptions", pos),
          BuiltinOptions::LocalResponseNormalizationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LocalResponseNormalizationOptions>>("BuiltinOptions::LocalResponseNormalizationOptions", pos),
          BuiltinOptions::LSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSTMOptions>>("BuiltinOptions::LSTMOptions", pos),
          BuiltinOptions::ResizeBilinearOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeBilinearOptions>>("BuiltinOptions::ResizeBilinearOptions", pos),
          BuiltinOptions::CallOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallOptions>>("BuiltinOptions::CallOptions", pos),
          BuiltinOptions::ReshapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReshapeOptions>>("BuiltinOptions::ReshapeOptions", pos),
          BuiltinOptions::SkipGramOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SkipGramOptions>>("BuiltinOptions::SkipGramOptions", pos),
          BuiltinOptions::SpaceToDepthOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToDepthOptions>>("BuiltinOptions::SpaceToDepthOptions", pos),
          BuiltinOptions::EmbeddingLookupSparseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EmbeddingLookupSparseOptions>>("BuiltinOptions::EmbeddingLookupSparseOptions", pos),
          BuiltinOptions::MulOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MulOptions>>("BuiltinOptions::MulOptions", pos),
          BuiltinOptions::PadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadOptions>>("BuiltinOptions::PadOptions", pos),
          BuiltinOptions::GatherOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherOptions>>("BuiltinOptions::GatherOptions", pos),
          BuiltinOptions::BatchToSpaceNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchToSpaceNDOptions>>("BuiltinOptions::BatchToSpaceNDOptions", pos),
          BuiltinOptions::SpaceToBatchNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToBatchNDOptions>>("BuiltinOptions::SpaceToBatchNDOptions", pos),
          BuiltinOptions::TransposeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeOptions>>("BuiltinOptions::TransposeOptions", pos),
          BuiltinOptions::ReducerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReducerOptions>>("BuiltinOptions::ReducerOptions", pos),
          BuiltinOptions::SubOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubOptions>>("BuiltinOptions::SubOptions", pos),
          BuiltinOptions::DivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DivOptions>>("BuiltinOptions::DivOptions", pos),
          BuiltinOptions::SqueezeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SqueezeOptions>>("BuiltinOptions::SqueezeOptions", pos),
          BuiltinOptions::SequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceRNNOptions>>("BuiltinOptions::SequenceRNNOptions", pos),
          BuiltinOptions::StridedSliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StridedSliceOptions>>("BuiltinOptions::StridedSliceOptions", pos),
          BuiltinOptions::ExpOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpOptions>>("BuiltinOptions::ExpOptions", pos),
          BuiltinOptions::TopKV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TopKV2Options>>("BuiltinOptions::TopKV2Options", pos),
          BuiltinOptions::SplitOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitOptions>>("BuiltinOptions::SplitOptions", pos),
          BuiltinOptions::LogSoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogSoftmaxOptions>>("BuiltinOptions::LogSoftmaxOptions", pos),
          BuiltinOptions::CastOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastOptions>>("BuiltinOptions::CastOptions", pos),
          BuiltinOptions::DequantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DequantizeOptions>>("BuiltinOptions::DequantizeOptions", pos),
          BuiltinOptions::MaximumMinimumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaximumMinimumOptions>>("BuiltinOptions::MaximumMinimumOptions", pos),
          BuiltinOptions::ArgMaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMaxOptions>>("BuiltinOptions::ArgMaxOptions", pos),
          BuiltinOptions::LessOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessOptions>>("BuiltinOptions::LessOptions", pos),
          BuiltinOptions::NegOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NegOptions>>("BuiltinOptions::NegOptions", pos),
          BuiltinOptions::PadV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadV2Options>>("BuiltinOptions::PadV2Options", pos),
          BuiltinOptions::GreaterOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterOptions>>("BuiltinOptions::GreaterOptions", pos),
          BuiltinOptions::GreaterEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterEqualOptions>>("BuiltinOptions::GreaterEqualOptions", pos),
          BuiltinOptions::LessEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessEqualOptions>>("BuiltinOptions::LessEqualOptions", pos),
          BuiltinOptions::SelectOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectOptions>>("BuiltinOptions::SelectOptions", pos),
          BuiltinOptions::SliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SliceOptions>>("BuiltinOptions::SliceOptions", pos),
          BuiltinOptions::TransposeConvOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeConvOptions>>("BuiltinOptions::TransposeConvOptions", pos),
          BuiltinOptions::SparseToDenseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseToDenseOptions>>("BuiltinOptions::SparseToDenseOptions", pos),
          BuiltinOptions::TileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TileOptions>>("BuiltinOptions::TileOptions", pos),
          BuiltinOptions::ExpandDimsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpandDimsOptions>>("BuiltinOptions::ExpandDimsOptions", pos),
          BuiltinOptions::EqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualOptions>>("BuiltinOptions::EqualOptions", pos),
          BuiltinOptions::NotEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NotEqualOptions>>("BuiltinOptions::NotEqualOptions", pos),
          BuiltinOptions::ShapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ShapeOptions>>("BuiltinOptions::ShapeOptions", pos),
          BuiltinOptions::PowOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PowOptions>>("BuiltinOptions::PowOptions", pos),
          BuiltinOptions::ArgMinOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMinOptions>>("BuiltinOptions::ArgMinOptions", pos),
          BuiltinOptions::FakeQuantOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FakeQuantOptions>>("BuiltinOptions::FakeQuantOptions", pos),
          BuiltinOptions::PackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PackOptions>>("BuiltinOptions::PackOptions", pos),
          BuiltinOptions::LogicalOrOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalOrOptions>>("BuiltinOptions::LogicalOrOptions", pos),
          BuiltinOptions::OneHotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OneHotOptions>>("BuiltinOptions::OneHotOptions", pos),
          BuiltinOptions::LogicalAndOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalAndOptions>>("BuiltinOptions::LogicalAndOptions", pos),
          BuiltinOptions::LogicalNotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalNotOptions>>("BuiltinOptions::LogicalNotOptions", pos),
          BuiltinOptions::UnpackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnpackOptions>>("BuiltinOptions::UnpackOptions", pos),
          BuiltinOptions::FloorDivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorDivOptions>>("BuiltinOptions::FloorDivOptions", pos),
          BuiltinOptions::SquareOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquareOptions>>("BuiltinOptions::SquareOptions", pos),
          BuiltinOptions::ZerosLikeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ZerosLikeOptions>>("BuiltinOptions::ZerosLikeOptions", pos),
          BuiltinOptions::FillOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FillOptions>>("BuiltinOptions::FillOptions", pos),
          BuiltinOptions::BidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceLSTMOptions>>("BuiltinOptions::BidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::BidirectionalSequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceRNNOptions>>("BuiltinOptions::BidirectionalSequenceRNNOptions", pos),
          BuiltinOptions::UnidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnidirectionalSequenceLSTMOptions>>("BuiltinOptions::UnidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::FloorModOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorModOptions>>("BuiltinOptions::FloorModOptions", pos),
          BuiltinOptions::RangeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RangeOptions>>("BuiltinOptions::RangeOptions", pos),
          BuiltinOptions::ResizeNearestNeighborOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeNearestNeighborOptions>>("BuiltinOptions::ResizeNearestNeighborOptions", pos),
          BuiltinOptions::LeakyReluOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluOptions>>("BuiltinOptions::LeakyReluOptions", pos),
          BuiltinOptions::SquaredDifferenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquaredDifferenceOptions>>("BuiltinOptions::SquaredDifferenceOptions", pos),
          BuiltinOptions::MirrorPadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MirrorPadOptions>>("BuiltinOptions::MirrorPadOptions", pos),
          BuiltinOptions::AbsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AbsOptions>>("BuiltinOptions::AbsOptions", pos),
          BuiltinOptions::SplitVOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitVOptions>>("BuiltinOptions::SplitVOptions", pos),
          BuiltinOptions::UniqueOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UniqueOptions>>("BuiltinOptions::UniqueOptions", pos),
          BuiltinOptions::ReverseV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseV2Options>>("BuiltinOptions::ReverseV2Options", pos),
          BuiltinOptions::AddNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddNOptions>>("BuiltinOptions::AddNOptions", pos),
          BuiltinOptions::GatherNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherNdOptions>>("BuiltinOptions::GatherNdOptions", pos),
          BuiltinOptions::CosOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CosOptions>>("BuiltinOptions::CosOptions", pos),
          BuiltinOptions::WhereOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhereOptions>>("BuiltinOptions::WhereOptions", pos),
          BuiltinOptions::RankOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RankOptions>>("BuiltinOptions::RankOptions", pos),
          BuiltinOptions::ReverseSequenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseSequenceOptions>>("BuiltinOptions::ReverseSequenceOptions", pos),
          BuiltinOptions::MatrixDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixDiagOptions>>("BuiltinOptions::MatrixDiagOptions", pos),
          BuiltinOptions::QuantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QuantizeOptions>>("BuiltinOptions::QuantizeOptions", pos),
          BuiltinOptions::MatrixSetDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixSetDiagOptions>>("BuiltinOptions::MatrixSetDiagOptions", pos),
          BuiltinOptions::HardSwishOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HardSwishOptions>>("BuiltinOptions::HardSwishOptions", pos),
          BuiltinOptions::IfOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IfOptions>>("BuiltinOptions::IfOptions", pos),
          BuiltinOptions::WhileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhileOptions>>("BuiltinOptions::WhileOptions", pos),
          BuiltinOptions::DepthToSpaceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthToSpaceOptions>>("BuiltinOptions::DepthToSpaceOptions", pos),
          BuiltinOptions::NonMaxSuppressionV4Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV4Options>>("BuiltinOptions::NonMaxSuppressionV4Options", pos),
          BuiltinOptions::NonMaxSuppressionV5Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV5Options>>("BuiltinOptions::NonMaxSuppressionV5Options", pos),
          BuiltinOptions::ScatterNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterNdOptions>>("BuiltinOptions::ScatterNdOptions", pos),
          BuiltinOptions::SelectV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectV2Options>>("BuiltinOptions::SelectV2Options", pos),
          BuiltinOptions::DensifyOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DensifyOptions>>("BuiltinOptions::DensifyOptions", pos),
          BuiltinOptions::SegmentSumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SegmentSumOptions>>("BuiltinOptions::SegmentSumOptions", pos),
          BuiltinOptions::BatchMatMulOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchMatMulOptions>>("BuiltinOptions::BatchMatMulOptions", pos),
          BuiltinOptions::CumsumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CumsumOptions>>("BuiltinOptions::CumsumOptions", pos),
          BuiltinOptions::CallOnceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallOnceOptions>>("BuiltinOptions::CallOnceOptions", pos),
          BuiltinOptions::BroadcastToOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BroadcastToOptions>>("BuiltinOptions::BroadcastToOptions", pos),
          BuiltinOptions::Rfft2dOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Rfft2dOptions>>("BuiltinOptions::Rfft2dOptions", pos),
          BuiltinOptions::Conv3DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv3DOptions>>("BuiltinOptions::Conv3DOptions", pos),
          BuiltinOptions::HashtableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableOptions>>("BuiltinOptions::HashtableOptions", pos),
          BuiltinOptions::HashtableFindOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableFindOptions>>("BuiltinOptions::HashtableFindOptions", pos),
          BuiltinOptions::HashtableImportOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableImportOptions>>("BuiltinOptions::HashtableImportOptions", pos),
          BuiltinOptions::HashtableSizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HashtableSizeOptions>>("BuiltinOptions::HashtableSizeOptions", pos),
          BuiltinOptions::VarHandleOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<VarHandleOptions>>("BuiltinOptions::VarHandleOptions", pos),
          BuiltinOptions::ReadVariableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadVariableOptions>>("BuiltinOptions::ReadVariableOptions", pos),
          BuiltinOptions::AssignVariableOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AssignVariableOptions>>("BuiltinOptions::AssignVariableOptions", pos),
          BuiltinOptions::RandomOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RandomOptions>>("BuiltinOptions::RandomOptions", pos),
          BuiltinOptions::BucketizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BucketizeOptions>>("BuiltinOptions::BucketizeOptions", pos),
          BuiltinOptions::GeluOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GeluOptions>>("BuiltinOptions::GeluOptions", pos),
          BuiltinOptions::DynamicUpdateSliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DynamicUpdateSliceOptions>>("BuiltinOptions::DynamicUpdateSliceOptions", pos),
          BuiltinOptions::UnsortedSegmentProdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentProdOptions>>("BuiltinOptions::UnsortedSegmentProdOptions", pos),
          BuiltinOptions::UnsortedSegmentMaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentMaxOptions>>("BuiltinOptions::UnsortedSegmentMaxOptions", pos),
          BuiltinOptions::UnsortedSegmentMinOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentMinOptions>>("BuiltinOptions::UnsortedSegmentMinOptions", pos),
          BuiltinOptions::UnsortedSegmentSumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsortedSegmentSumOptions>>("BuiltinOptions::UnsortedSegmentSumOptions", pos),
          BuiltinOptions::ATan2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ATan2Options>>("BuiltinOptions::ATan2Options", pos),
          BuiltinOptions::SignOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SignOptions>>("BuiltinOptions::SignOptions", pos),
          BuiltinOptions::BitcastOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BitcastOptions>>("BuiltinOptions::BitcastOptions", pos),
          BuiltinOptions::BitwiseXorOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BitwiseXorOptions>>("BuiltinOptions::BitwiseXorOptions", pos),
          BuiltinOptions::RightShiftOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RightShiftOptions>>("BuiltinOptions::RightShiftOptions", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("custom_options", Self::VT_CUSTOM_OPTIONS, false)?
     .visit_field::<CustomOptionsFormat>("custom_options_format", Self::VT_CUSTOM_OPTIONS_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("mutating_variable_inputs", Self::VT_MUTATING_VARIABLE_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("intermediates", Self::VT_INTERMEDIATES, false)?
     .finish();
            Ok(())
        }
    }
    pub struct OperatorArgs<'a> {
        pub opcode_index: u32,
        pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub builtin_options_type: BuiltinOptions,
        pub builtin_options: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub custom_options: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub custom_options_format: CustomOptionsFormat,
        pub mutating_variable_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
        pub intermediates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    }
    impl<'a> Default for OperatorArgs<'a> {
        #[inline]
        fn default() -> Self {
            OperatorArgs {
                opcode_index: 0,
                inputs: None,
                outputs: None,
                builtin_options_type: BuiltinOptions::NONE,
                builtin_options: None,
                custom_options: None,
                custom_options_format: CustomOptionsFormat::FLEXBUFFERS,
                mutating_variable_inputs: None,
                intermediates: None,
            }
        }
    }

    pub struct OperatorBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> OperatorBuilder<'a, 'b> {
        #[inline]
        pub fn add_opcode_index(&mut self, opcode_index: u32) {
            self.fbb_
                .push_slot::<u32>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
        }
        #[inline]
        pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_INPUTS, inputs);
        }
        #[inline]
        pub fn add_outputs(
            &mut self,
            outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_OUTPUTS, outputs);
        }
        #[inline]
        pub fn add_builtin_options_type(&mut self, builtin_options_type: BuiltinOptions) {
            self.fbb_.push_slot::<BuiltinOptions>(
                Operator::VT_BUILTIN_OPTIONS_TYPE,
                builtin_options_type,
                BuiltinOptions::NONE,
            );
        }
        #[inline]
        pub fn add_builtin_options(
            &mut self,
            builtin_options: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Operator::VT_BUILTIN_OPTIONS,
                builtin_options,
            );
        }
        #[inline]
        pub fn add_custom_options(
            &mut self,
            custom_options: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Operator::VT_CUSTOM_OPTIONS,
                custom_options,
            );
        }
        #[inline]
        pub fn add_custom_options_format(&mut self, custom_options_format: CustomOptionsFormat) {
            self.fbb_.push_slot::<CustomOptionsFormat>(
                Operator::VT_CUSTOM_OPTIONS_FORMAT,
                custom_options_format,
                CustomOptionsFormat::FLEXBUFFERS,
            );
        }
        #[inline]
        pub fn add_mutating_variable_inputs(
            &mut self,
            mutating_variable_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, bool>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Operator::VT_MUTATING_VARIABLE_INPUTS,
                mutating_variable_inputs,
            );
        }
        #[inline]
        pub fn add_intermediates(
            &mut self,
            intermediates: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Operator::VT_INTERMEDIATES,
                intermediates,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorBuilder<'a, 'b> {
            let start = _fbb.start_table();
            OperatorBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Operator<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Operator<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Operator");
            ds.field("opcode_index", &self.opcode_index());
            ds.field("inputs", &self.inputs());
            ds.field("outputs", &self.outputs());
            ds.field("builtin_options_type", &self.builtin_options_type());
            match self.builtin_options_type() {
                BuiltinOptions::Conv2DOptions => {
                    if let Some(x) = self.builtin_options_as_conv_2_doptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DepthwiseConv2DOptions => {
                    if let Some(x) = self.builtin_options_as_depthwise_conv_2_doptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ConcatEmbeddingsOptions => {
                    if let Some(x) = self.builtin_options_as_concat_embeddings_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LSHProjectionOptions => {
                    if let Some(x) = self.builtin_options_as_lshprojection_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::Pool2DOptions => {
                    if let Some(x) = self.builtin_options_as_pool_2_doptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SVDFOptions => {
                    if let Some(x) = self.builtin_options_as_svdfoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::RNNOptions => {
                    if let Some(x) = self.builtin_options_as_rnnoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::FullyConnectedOptions => {
                    if let Some(x) = self.builtin_options_as_fully_connected_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SoftmaxOptions => {
                    if let Some(x) = self.builtin_options_as_softmax_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ConcatenationOptions => {
                    if let Some(x) = self.builtin_options_as_concatenation_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::AddOptions => {
                    if let Some(x) = self.builtin_options_as_add_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::L2NormOptions => {
                    if let Some(x) = self.builtin_options_as_l2_norm_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LocalResponseNormalizationOptions => {
                    if let Some(x) = self.builtin_options_as_local_response_normalization_options()
                    {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LSTMOptions => {
                    if let Some(x) = self.builtin_options_as_lstmoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ResizeBilinearOptions => {
                    if let Some(x) = self.builtin_options_as_resize_bilinear_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::CallOptions => {
                    if let Some(x) = self.builtin_options_as_call_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ReshapeOptions => {
                    if let Some(x) = self.builtin_options_as_reshape_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SkipGramOptions => {
                    if let Some(x) = self.builtin_options_as_skip_gram_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SpaceToDepthOptions => {
                    if let Some(x) = self.builtin_options_as_space_to_depth_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::EmbeddingLookupSparseOptions => {
                    if let Some(x) = self.builtin_options_as_embedding_lookup_sparse_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::MulOptions => {
                    if let Some(x) = self.builtin_options_as_mul_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::PadOptions => {
                    if let Some(x) = self.builtin_options_as_pad_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::GatherOptions => {
                    if let Some(x) = self.builtin_options_as_gather_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BatchToSpaceNDOptions => {
                    if let Some(x) = self.builtin_options_as_batch_to_space_ndoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SpaceToBatchNDOptions => {
                    if let Some(x) = self.builtin_options_as_space_to_batch_ndoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::TransposeOptions => {
                    if let Some(x) = self.builtin_options_as_transpose_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ReducerOptions => {
                    if let Some(x) = self.builtin_options_as_reducer_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SubOptions => {
                    if let Some(x) = self.builtin_options_as_sub_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DivOptions => {
                    if let Some(x) = self.builtin_options_as_div_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SqueezeOptions => {
                    if let Some(x) = self.builtin_options_as_squeeze_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SequenceRNNOptions => {
                    if let Some(x) = self.builtin_options_as_sequence_rnnoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::StridedSliceOptions => {
                    if let Some(x) = self.builtin_options_as_strided_slice_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ExpOptions => {
                    if let Some(x) = self.builtin_options_as_exp_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::TopKV2Options => {
                    if let Some(x) = self.builtin_options_as_top_kv2_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SplitOptions => {
                    if let Some(x) = self.builtin_options_as_split_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LogSoftmaxOptions => {
                    if let Some(x) = self.builtin_options_as_log_softmax_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::CastOptions => {
                    if let Some(x) = self.builtin_options_as_cast_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DequantizeOptions => {
                    if let Some(x) = self.builtin_options_as_dequantize_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::MaximumMinimumOptions => {
                    if let Some(x) = self.builtin_options_as_maximum_minimum_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ArgMaxOptions => {
                    if let Some(x) = self.builtin_options_as_arg_max_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LessOptions => {
                    if let Some(x) = self.builtin_options_as_less_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::NegOptions => {
                    if let Some(x) = self.builtin_options_as_neg_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::PadV2Options => {
                    if let Some(x) = self.builtin_options_as_pad_v2_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::GreaterOptions => {
                    if let Some(x) = self.builtin_options_as_greater_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::GreaterEqualOptions => {
                    if let Some(x) = self.builtin_options_as_greater_equal_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LessEqualOptions => {
                    if let Some(x) = self.builtin_options_as_less_equal_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SelectOptions => {
                    if let Some(x) = self.builtin_options_as_select_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SliceOptions => {
                    if let Some(x) = self.builtin_options_as_slice_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::TransposeConvOptions => {
                    if let Some(x) = self.builtin_options_as_transpose_conv_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SparseToDenseOptions => {
                    if let Some(x) = self.builtin_options_as_sparse_to_dense_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::TileOptions => {
                    if let Some(x) = self.builtin_options_as_tile_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ExpandDimsOptions => {
                    if let Some(x) = self.builtin_options_as_expand_dims_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::EqualOptions => {
                    if let Some(x) = self.builtin_options_as_equal_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::NotEqualOptions => {
                    if let Some(x) = self.builtin_options_as_not_equal_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ShapeOptions => {
                    if let Some(x) = self.builtin_options_as_shape_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::PowOptions => {
                    if let Some(x) = self.builtin_options_as_pow_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ArgMinOptions => {
                    if let Some(x) = self.builtin_options_as_arg_min_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::FakeQuantOptions => {
                    if let Some(x) = self.builtin_options_as_fake_quant_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::PackOptions => {
                    if let Some(x) = self.builtin_options_as_pack_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LogicalOrOptions => {
                    if let Some(x) = self.builtin_options_as_logical_or_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::OneHotOptions => {
                    if let Some(x) = self.builtin_options_as_one_hot_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LogicalAndOptions => {
                    if let Some(x) = self.builtin_options_as_logical_and_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LogicalNotOptions => {
                    if let Some(x) = self.builtin_options_as_logical_not_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnpackOptions => {
                    if let Some(x) = self.builtin_options_as_unpack_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::FloorDivOptions => {
                    if let Some(x) = self.builtin_options_as_floor_div_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SquareOptions => {
                    if let Some(x) = self.builtin_options_as_square_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ZerosLikeOptions => {
                    if let Some(x) = self.builtin_options_as_zeros_like_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::FillOptions => {
                    if let Some(x) = self.builtin_options_as_fill_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BidirectionalSequenceLSTMOptions => {
                    if let Some(x) = self.builtin_options_as_bidirectional_sequence_lstmoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BidirectionalSequenceRNNOptions => {
                    if let Some(x) = self.builtin_options_as_bidirectional_sequence_rnnoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnidirectionalSequenceLSTMOptions => {
                    if let Some(x) = self.builtin_options_as_unidirectional_sequence_lstmoptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::FloorModOptions => {
                    if let Some(x) = self.builtin_options_as_floor_mod_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::RangeOptions => {
                    if let Some(x) = self.builtin_options_as_range_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ResizeNearestNeighborOptions => {
                    if let Some(x) = self.builtin_options_as_resize_nearest_neighbor_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::LeakyReluOptions => {
                    if let Some(x) = self.builtin_options_as_leaky_relu_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SquaredDifferenceOptions => {
                    if let Some(x) = self.builtin_options_as_squared_difference_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::MirrorPadOptions => {
                    if let Some(x) = self.builtin_options_as_mirror_pad_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::AbsOptions => {
                    if let Some(x) = self.builtin_options_as_abs_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SplitVOptions => {
                    if let Some(x) = self.builtin_options_as_split_voptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UniqueOptions => {
                    if let Some(x) = self.builtin_options_as_unique_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ReverseV2Options => {
                    if let Some(x) = self.builtin_options_as_reverse_v2_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::AddNOptions => {
                    if let Some(x) = self.builtin_options_as_add_noptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::GatherNdOptions => {
                    if let Some(x) = self.builtin_options_as_gather_nd_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::CosOptions => {
                    if let Some(x) = self.builtin_options_as_cos_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::WhereOptions => {
                    if let Some(x) = self.builtin_options_as_where_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::RankOptions => {
                    if let Some(x) = self.builtin_options_as_rank_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ReverseSequenceOptions => {
                    if let Some(x) = self.builtin_options_as_reverse_sequence_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::MatrixDiagOptions => {
                    if let Some(x) = self.builtin_options_as_matrix_diag_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::QuantizeOptions => {
                    if let Some(x) = self.builtin_options_as_quantize_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::MatrixSetDiagOptions => {
                    if let Some(x) = self.builtin_options_as_matrix_set_diag_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::HardSwishOptions => {
                    if let Some(x) = self.builtin_options_as_hard_swish_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::IfOptions => {
                    if let Some(x) = self.builtin_options_as_if_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::WhileOptions => {
                    if let Some(x) = self.builtin_options_as_while_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DepthToSpaceOptions => {
                    if let Some(x) = self.builtin_options_as_depth_to_space_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::NonMaxSuppressionV4Options => {
                    if let Some(x) = self.builtin_options_as_non_max_suppression_v4_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::NonMaxSuppressionV5Options => {
                    if let Some(x) = self.builtin_options_as_non_max_suppression_v5_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ScatterNdOptions => {
                    if let Some(x) = self.builtin_options_as_scatter_nd_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SelectV2Options => {
                    if let Some(x) = self.builtin_options_as_select_v2_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DensifyOptions => {
                    if let Some(x) = self.builtin_options_as_densify_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SegmentSumOptions => {
                    if let Some(x) = self.builtin_options_as_segment_sum_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BatchMatMulOptions => {
                    if let Some(x) = self.builtin_options_as_batch_mat_mul_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::CumsumOptions => {
                    if let Some(x) = self.builtin_options_as_cumsum_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::CallOnceOptions => {
                    if let Some(x) = self.builtin_options_as_call_once_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BroadcastToOptions => {
                    if let Some(x) = self.builtin_options_as_broadcast_to_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::Rfft2dOptions => {
                    if let Some(x) = self.builtin_options_as_rfft_2d_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::Conv3DOptions => {
                    if let Some(x) = self.builtin_options_as_conv_3_doptions() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::HashtableOptions => {
                    if let Some(x) = self.builtin_options_as_hashtable_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::HashtableFindOptions => {
                    if let Some(x) = self.builtin_options_as_hashtable_find_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::HashtableImportOptions => {
                    if let Some(x) = self.builtin_options_as_hashtable_import_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::HashtableSizeOptions => {
                    if let Some(x) = self.builtin_options_as_hashtable_size_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::VarHandleOptions => {
                    if let Some(x) = self.builtin_options_as_var_handle_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ReadVariableOptions => {
                    if let Some(x) = self.builtin_options_as_read_variable_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::AssignVariableOptions => {
                    if let Some(x) = self.builtin_options_as_assign_variable_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::RandomOptions => {
                    if let Some(x) = self.builtin_options_as_random_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BucketizeOptions => {
                    if let Some(x) = self.builtin_options_as_bucketize_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::GeluOptions => {
                    if let Some(x) = self.builtin_options_as_gelu_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::DynamicUpdateSliceOptions => {
                    if let Some(x) = self.builtin_options_as_dynamic_update_slice_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnsortedSegmentProdOptions => {
                    if let Some(x) = self.builtin_options_as_unsorted_segment_prod_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnsortedSegmentMaxOptions => {
                    if let Some(x) = self.builtin_options_as_unsorted_segment_max_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnsortedSegmentMinOptions => {
                    if let Some(x) = self.builtin_options_as_unsorted_segment_min_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::UnsortedSegmentSumOptions => {
                    if let Some(x) = self.builtin_options_as_unsorted_segment_sum_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::ATan2Options => {
                    if let Some(x) = self.builtin_options_as_atan_2_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::SignOptions => {
                    if let Some(x) = self.builtin_options_as_sign_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BitcastOptions => {
                    if let Some(x) = self.builtin_options_as_bitcast_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::BitwiseXorOptions => {
                    if let Some(x) = self.builtin_options_as_bitwise_xor_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                BuiltinOptions::RightShiftOptions => {
                    if let Some(x) = self.builtin_options_as_right_shift_options() {
                        ds.field("builtin_options", &x)
                    } else {
                        ds.field(
                            "builtin_options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("builtin_options", &x)
                }
            };
            ds.field("custom_options", &self.custom_options());
            ds.field("custom_options_format", &self.custom_options_format());
            ds.field("mutating_variable_inputs", &self.mutating_variable_inputs());
            ds.field("intermediates", &self.intermediates());
            ds.finish()
        }
    }
    pub enum SubGraphOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SubGraph<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SubGraph<'a> {
        type Inner = SubGraph<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SubGraph<'a> {
        pub const VT_TENSORS: flatbuffers::VOffsetT = 4;
        pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
        pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
        pub const VT_OPERATORS: flatbuffers::VOffsetT = 10;
        pub const VT_NAME: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SubGraph { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubGraphArgs<'args>,
        ) -> flatbuffers::WIPOffset<SubGraph<'bldr>> {
            let mut builder = SubGraphBuilder::new(_fbb);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            if let Some(x) = args.operators {
                builder.add_operators(x);
            }
            if let Some(x) = args.outputs {
                builder.add_outputs(x);
            }
            if let Some(x) = args.inputs {
                builder.add_inputs(x);
            }
            if let Some(x) = args.tensors {
                builder.add_tensors(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn tensors(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor>>,
                >>(SubGraph::VT_TENSORS, None)
            }
        }
        #[inline]
        pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        SubGraph::VT_INPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        SubGraph::VT_OUTPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn operators(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator>>,
                >>(SubGraph::VT_OPERATORS, None)
            }
        }
        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SubGraph::VT_NAME, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SubGraph<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tensor>>,
                >>("tensors", Self::VT_TENSORS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "inputs",
                    Self::VT_INPUTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "outputs",
                    Self::VT_OUTPUTS,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Operator>>,
                >>("operators", Self::VT_OPERATORS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubGraphArgs<'a> {
        pub tensors: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>,
            >,
        >,
        pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub operators: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>,
            >,
        >,
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SubGraphArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubGraphArgs {
                tensors: None,
                inputs: None,
                outputs: None,
                operators: None,
                name: None,
            }
        }
    }

    pub struct SubGraphBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubGraphBuilder<'a, 'b> {
        #[inline]
        pub fn add_tensors(
            &mut self,
            tensors: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Tensor<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_TENSORS, tensors);
        }
        #[inline]
        pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_INPUTS, inputs);
        }
        #[inline]
        pub fn add_outputs(
            &mut self,
            outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OUTPUTS, outputs);
        }
        #[inline]
        pub fn add_operators(
            &mut self,
            operators: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Operator<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OPERATORS, operators);
        }
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_NAME, name);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubGraphBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubGraphBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SubGraph<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SubGraph<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SubGraph");
            ds.field("tensors", &self.tensors());
            ds.field("inputs", &self.inputs());
            ds.field("outputs", &self.outputs());
            ds.field("operators", &self.operators());
            ds.field("name", &self.name());
            ds.finish()
        }
    }
    pub enum BufferOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Buffer<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Buffer<'a> {
        type Inner = Buffer<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Buffer<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Buffer { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BufferArgs<'args>,
        ) -> flatbuffers::WIPOffset<Buffer<'bldr>> {
            let mut builder = BufferBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Buffer::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Buffer<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BufferArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for BufferArgs<'a> {
        #[inline]
        fn default() -> Self {
            BufferArgs { data: None }
        }
    }

    pub struct BufferBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BufferBuilder<'a, 'b> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Buffer::VT_DATA, data);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BufferBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Buffer<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Buffer<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Buffer");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum MetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Metadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
        type Inner = Metadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Metadata<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_BUFFER: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Metadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
            let mut builder = MetadataBuilder::new(_fbb);
            builder.add_buffer(args.buffer);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_NAME, None)
            }
        }
        #[inline]
        pub fn buffer(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Metadata::VT_BUFFER, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for Metadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MetadataArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub buffer: u32,
    }
    impl<'a> Default for MetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            MetadataArgs {
                name: None,
                buffer: 0,
            }
        }
    }

    pub struct MetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_NAME, name);
        }
        #[inline]
        pub fn add_buffer(&mut self, buffer: u32) {
            self.fbb_.push_slot::<u32>(Metadata::VT_BUFFER, buffer, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Metadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Metadata");
            ds.field("name", &self.name());
            ds.field("buffer", &self.buffer());
            ds.finish()
        }
    }
    pub enum TensorMapOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TensorMap<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TensorMap<'a> {
        type Inner = TensorMap<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TensorMap<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_TENSOR_INDEX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TensorMap { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TensorMapArgs<'args>,
        ) -> flatbuffers::WIPOffset<TensorMap<'bldr>> {
            let mut builder = TensorMapBuilder::new(_fbb);
            builder.add_tensor_index(args.tensor_index);
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TensorMap::VT_NAME, None)
            }
        }
        #[inline]
        pub fn tensor_index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(TensorMap::VT_TENSOR_INDEX, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for TensorMap<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<u32>("tensor_index", Self::VT_TENSOR_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TensorMapArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tensor_index: u32,
    }
    impl<'a> Default for TensorMapArgs<'a> {
        #[inline]
        fn default() -> Self {
            TensorMapArgs {
                name: None,
                tensor_index: 0,
            }
        }
    }

    pub struct TensorMapBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TensorMapBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TensorMap::VT_NAME, name);
        }
        #[inline]
        pub fn add_tensor_index(&mut self, tensor_index: u32) {
            self.fbb_
                .push_slot::<u32>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorMapBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TensorMapBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TensorMap<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TensorMap<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TensorMap");
            ds.field("name", &self.name());
            ds.field("tensor_index", &self.tensor_index());
            ds.finish()
        }
    }
    pub enum SignatureDefOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SignatureDef<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SignatureDef<'a> {
        type Inner = SignatureDef<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SignatureDef<'a> {
        pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
        pub const VT_OUTPUTS: flatbuffers::VOffsetT = 6;
        pub const VT_SIGNATURE_KEY: flatbuffers::VOffsetT = 8;
        pub const VT_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SignatureDef { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SignatureDefArgs<'args>,
        ) -> flatbuffers::WIPOffset<SignatureDef<'bldr>> {
            let mut builder = SignatureDefBuilder::new(_fbb);
            builder.add_subgraph_index(args.subgraph_index);
            if let Some(x) = args.signature_key {
                builder.add_signature_key(x);
            }
            if let Some(x) = args.outputs {
                builder.add_outputs(x);
            }
            if let Some(x) = args.inputs {
                builder.add_inputs(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn inputs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap>>,
                >>(SignatureDef::VT_INPUTS, None)
            }
        }
        #[inline]
        pub fn outputs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap>>,
                >>(SignatureDef::VT_OUTPUTS, None)
            }
        }
        #[inline]
        pub fn signature_key(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SignatureDef::VT_SIGNATURE_KEY, None)
            }
        }
        #[inline]
        pub fn subgraph_index(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(SignatureDef::VT_SUBGRAPH_INDEX, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for SignatureDef<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMap>>,
                >>("inputs", Self::VT_INPUTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMap>>,
                >>("outputs", Self::VT_OUTPUTS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "signature_key",
                    Self::VT_SIGNATURE_KEY,
                    false,
                )?
                .visit_field::<u32>("subgraph_index", Self::VT_SUBGRAPH_INDEX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SignatureDefArgs<'a> {
        pub inputs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>,
            >,
        >,
        pub outputs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMap<'a>>>,
            >,
        >,
        pub signature_key: Option<flatbuffers::WIPOffset<&'a str>>,
        pub subgraph_index: u32,
    }
    impl<'a> Default for SignatureDefArgs<'a> {
        #[inline]
        fn default() -> Self {
            SignatureDefArgs {
                inputs: None,
                outputs: None,
                signature_key: None,
                subgraph_index: 0,
            }
        }
    }

    pub struct SignatureDefBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SignatureDefBuilder<'a, 'b> {
        #[inline]
        pub fn add_inputs(
            &mut self,
            inputs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorMap<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureDef::VT_INPUTS, inputs);
        }
        #[inline]
        pub fn add_outputs(
            &mut self,
            outputs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorMap<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureDef::VT_OUTPUTS, outputs);
        }
        #[inline]
        pub fn add_signature_key(&mut self, signature_key: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SignatureDef::VT_SIGNATURE_KEY,
                signature_key,
            );
        }
        #[inline]
        pub fn add_subgraph_index(&mut self, subgraph_index: u32) {
            self.fbb_
                .push_slot::<u32>(SignatureDef::VT_SUBGRAPH_INDEX, subgraph_index, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SignatureDefBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SignatureDefBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SignatureDef<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SignatureDef<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SignatureDef");
            ds.field("inputs", &self.inputs());
            ds.field("outputs", &self.outputs());
            ds.field("signature_key", &self.signature_key());
            ds.field("subgraph_index", &self.subgraph_index());
            ds.finish()
        }
    }
    pub enum ModelOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Model<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Model<'a> {
        type Inner = Model<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Model<'a> {
        pub const VT_VERSION: flatbuffers::VOffsetT = 4;
        pub const VT_OPERATOR_CODES: flatbuffers::VOffsetT = 6;
        pub const VT_SUBGRAPHS: flatbuffers::VOffsetT = 8;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
        pub const VT_BUFFERS: flatbuffers::VOffsetT = 12;
        pub const VT_METADATA_BUFFER: flatbuffers::VOffsetT = 14;
        pub const VT_METADATA: flatbuffers::VOffsetT = 16;
        pub const VT_SIGNATURE_DEFS: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Model { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ModelArgs<'args>,
        ) -> flatbuffers::WIPOffset<Model<'bldr>> {
            let mut builder = ModelBuilder::new(_fbb);
            if let Some(x) = args.signature_defs {
                builder.add_signature_defs(x);
            }
            if let Some(x) = args.metadata {
                builder.add_metadata(x);
            }
            if let Some(x) = args.metadata_buffer {
                builder.add_metadata_buffer(x);
            }
            if let Some(x) = args.buffers {
                builder.add_buffers(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.subgraphs {
                builder.add_subgraphs(x);
            }
            if let Some(x) = args.operator_codes {
                builder.add_operator_codes(x);
            }
            builder.add_version(args.version);
            builder.finish()
        }

        #[inline]
        pub fn version(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(Model::VT_VERSION, Some(0)).unwrap() }
        }
        #[inline]
        pub fn operator_codes(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode>>,
                >>(Model::VT_OPERATOR_CODES, None)
            }
        }
        #[inline]
        pub fn subgraphs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph>>,
                >>(Model::VT_SUBGRAPHS, None)
            }
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_DESCRIPTION, None)
            }
        }
        #[inline]
        pub fn buffers(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer>>,
                >>(Model::VT_BUFFERS, None)
            }
        }
        #[inline]
        pub fn metadata_buffer(&self) -> Option<flatbuffers::Vector<'a, i32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                        Model::VT_METADATA_BUFFER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata>>,
                >>(Model::VT_METADATA, None)
            }
        }
        #[inline]
        pub fn signature_defs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef>>,
                >>(Model::VT_SIGNATURE_DEFS, None)
            }
        }
    }

    impl flatbuffers::Verifiable for Model<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("version", Self::VT_VERSION, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorCode>>,
                >>("operator_codes", Self::VT_OPERATOR_CODES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SubGraph>>,
                >>("subgraphs", Self::VT_SUBGRAPHS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "description",
                    Self::VT_DESCRIPTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Buffer>>,
                >>("buffers", Self::VT_BUFFERS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                    "metadata_buffer",
                    Self::VT_METADATA_BUFFER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Metadata>>,
                >>("metadata", Self::VT_METADATA, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SignatureDef>>,
                >>("signature_defs", Self::VT_SIGNATURE_DEFS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ModelArgs<'a> {
        pub version: u32,
        pub operator_codes: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>,
            >,
        >,
        pub subgraphs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>,
            >,
        >,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub buffers: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>,
            >,
        >,
        pub metadata_buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
        pub metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>,
            >,
        >,
        pub signature_defs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SignatureDef<'a>>>,
            >,
        >,
    }
    impl<'a> Default for ModelArgs<'a> {
        #[inline]
        fn default() -> Self {
            ModelArgs {
                version: 0,
                operator_codes: None,
                subgraphs: None,
                description: None,
                buffers: None,
                metadata_buffer: None,
                metadata: None,
                signature_defs: None,
            }
        }
    }

    pub struct ModelBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
        #[inline]
        pub fn add_version(&mut self, version: u32) {
            self.fbb_.push_slot::<u32>(Model::VT_VERSION, version, 0);
        }
        #[inline]
        pub fn add_operator_codes(
            &mut self,
            operator_codes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<OperatorCode<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Model::VT_OPERATOR_CODES,
                operator_codes,
            );
        }
        #[inline]
        pub fn add_subgraphs(
            &mut self,
            subgraphs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SubGraph<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_SUBGRAPHS, subgraphs);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_DESCRIPTION, description);
        }
        #[inline]
        pub fn add_buffers(
            &mut self,
            buffers: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Buffer<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_BUFFERS, buffers);
        }
        #[inline]
        pub fn add_metadata_buffer(
            &mut self,
            metadata_buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Model::VT_METADATA_BUFFER,
                metadata_buffer,
            );
        }
        #[inline]
        pub fn add_metadata(
            &mut self,
            metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Metadata<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA, metadata);
        }
        #[inline]
        pub fn add_signature_defs(
            &mut self,
            signature_defs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SignatureDef<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Model::VT_SIGNATURE_DEFS,
                signature_defs,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ModelBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Model<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Model");
            ds.field("version", &self.version());
            ds.field("operator_codes", &self.operator_codes());
            ds.field("subgraphs", &self.subgraphs());
            ds.field("description", &self.description());
            ds.field("buffers", &self.buffers());
            ds.field("metadata_buffer", &self.metadata_buffer());
            ds.field("metadata", &self.metadata());
            ds.field("signature_defs", &self.signature_defs());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Model`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_unchecked`.
    pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Model>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Model` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_model_unchecked`.
    pub fn size_prefixed_root_as_model(
        buf: &[u8],
    ) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Model>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Model` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_unchecked`.
    pub fn root_as_model_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Model` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_unchecked`.
    pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Model`.
    pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
        flatbuffers::root_unchecked::<Model>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
    pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
        flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
    }
    pub const MODEL_IDENTIFIER: &str = "TFL3";

    #[inline]
    pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
    }

    #[inline]
    pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
    }

    pub const MODEL_EXTENSION: &str = "tflite";

    #[inline]
    pub fn finish_model_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Model<'a>>,
    ) {
        fbb.finish(root, Some(MODEL_IDENTIFIER));
    }

    #[inline]
    pub fn finish_size_prefixed_model_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Model<'a>>,
    ) {
        fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
    }
} // pub mod tflite
