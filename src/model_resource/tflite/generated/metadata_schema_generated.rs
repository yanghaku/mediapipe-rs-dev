// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tflite {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_ASSOCIATED_FILE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_ASSOCIATED_FILE_TYPE: i8 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_ASSOCIATED_FILE_TYPE: [AssociatedFileType; 7] = [
        AssociatedFileType::UNKNOWN,
        AssociatedFileType::DESCRIPTIONS,
        AssociatedFileType::TENSOR_AXIS_LABELS,
        AssociatedFileType::TENSOR_VALUE_LABELS,
        AssociatedFileType::TENSOR_AXIS_SCORE_CALIBRATION,
        AssociatedFileType::VOCABULARY,
        AssociatedFileType::SCANN_INDEX_FILE,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct AssociatedFileType(pub i8);
    #[allow(non_upper_case_globals)]
    impl AssociatedFileType {
        pub const UNKNOWN: Self = Self(0);
        pub const DESCRIPTIONS: Self = Self(1);
        pub const TENSOR_AXIS_LABELS: Self = Self(2);
        pub const TENSOR_VALUE_LABELS: Self = Self(3);
        pub const TENSOR_AXIS_SCORE_CALIBRATION: Self = Self(4);
        pub const VOCABULARY: Self = Self(5);
        pub const SCANN_INDEX_FILE: Self = Self(6);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::UNKNOWN,
            Self::DESCRIPTIONS,
            Self::TENSOR_AXIS_LABELS,
            Self::TENSOR_VALUE_LABELS,
            Self::TENSOR_AXIS_SCORE_CALIBRATION,
            Self::VOCABULARY,
            Self::SCANN_INDEX_FILE,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN => Some("UNKNOWN"),
                Self::DESCRIPTIONS => Some("DESCRIPTIONS"),
                Self::TENSOR_AXIS_LABELS => Some("TENSOR_AXIS_LABELS"),
                Self::TENSOR_VALUE_LABELS => Some("TENSOR_VALUE_LABELS"),
                Self::TENSOR_AXIS_SCORE_CALIBRATION => Some("TENSOR_AXIS_SCORE_CALIBRATION"),
                Self::VOCABULARY => Some("VOCABULARY"),
                Self::SCANN_INDEX_FILE => Some("SCANN_INDEX_FILE"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for AssociatedFileType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for AssociatedFileType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for AssociatedFileType {
        type Output = AssociatedFileType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for AssociatedFileType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for AssociatedFileType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for AssociatedFileType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COLOR_SPACE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COLOR_SPACE_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COLOR_SPACE_TYPE: [ColorSpaceType; 3] = [
        ColorSpaceType::UNKNOWN,
        ColorSpaceType::RGB,
        ColorSpaceType::GRAYSCALE,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ColorSpaceType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ColorSpaceType {
        pub const UNKNOWN: Self = Self(0);
        pub const RGB: Self = Self(1);
        pub const GRAYSCALE: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] = &[Self::UNKNOWN, Self::RGB, Self::GRAYSCALE];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN => Some("UNKNOWN"),
                Self::RGB => Some("RGB"),
                Self::GRAYSCALE => Some("GRAYSCALE"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ColorSpaceType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ColorSpaceType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ColorSpaceType {
        type Output = ColorSpaceType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ColorSpaceType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ColorSpaceType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ColorSpaceType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_BOUNDING_BOX_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_BOUNDING_BOX_TYPE: i8 = 3;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_BOUNDING_BOX_TYPE: [BoundingBoxType; 4] = [
        BoundingBoxType::UNKNOWN,
        BoundingBoxType::BOUNDARIES,
        BoundingBoxType::UPPER_LEFT,
        BoundingBoxType::CENTER,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct BoundingBoxType(pub i8);
    #[allow(non_upper_case_globals)]
    impl BoundingBoxType {
        pub const UNKNOWN: Self = Self(0);
        pub const BOUNDARIES: Self = Self(1);
        pub const UPPER_LEFT: Self = Self(2);
        pub const CENTER: Self = Self(3);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 3;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::UNKNOWN,
            Self::BOUNDARIES,
            Self::UPPER_LEFT,
            Self::CENTER,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::UNKNOWN => Some("UNKNOWN"),
                Self::BOUNDARIES => Some("BOUNDARIES"),
                Self::UPPER_LEFT => Some("UPPER_LEFT"),
                Self::CENTER => Some("CENTER"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for BoundingBoxType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for BoundingBoxType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for BoundingBoxType {
        type Output = BoundingBoxType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for BoundingBoxType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for BoundingBoxType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for BoundingBoxType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_COORDINATE_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_COORDINATE_TYPE: i8 = 1;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_COORDINATE_TYPE: [CoordinateType; 2] =
        [CoordinateType::RATIO, CoordinateType::PIXEL];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct CoordinateType(pub i8);
    #[allow(non_upper_case_globals)]
    impl CoordinateType {
        pub const RATIO: Self = Self(0);
        pub const PIXEL: Self = Self(1);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 1;
        pub const ENUM_VALUES: &'static [Self] = &[Self::RATIO, Self::PIXEL];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::RATIO => Some("RATIO"),
                Self::PIXEL => Some("PIXEL"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for CoordinateType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for CoordinateType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for CoordinateType {
        type Output = CoordinateType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for CoordinateType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for CoordinateType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for CoordinateType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_CONTENT_PROPERTIES: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_CONTENT_PROPERTIES: u8 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_CONTENT_PROPERTIES: [ContentProperties; 5] = [
        ContentProperties::NONE,
        ContentProperties::FeatureProperties,
        ContentProperties::ImageProperties,
        ContentProperties::BoundingBoxProperties,
        ContentProperties::AudioProperties,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ContentProperties(pub u8);
    #[allow(non_upper_case_globals)]
    impl ContentProperties {
        pub const NONE: Self = Self(0);
        pub const FeatureProperties: Self = Self(1);
        pub const ImageProperties: Self = Self(2);
        pub const BoundingBoxProperties: Self = Self(3);
        pub const AudioProperties: Self = Self(4);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::FeatureProperties,
            Self::ImageProperties,
            Self::BoundingBoxProperties,
            Self::AudioProperties,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::FeatureProperties => Some("FeatureProperties"),
                Self::ImageProperties => Some("ImageProperties"),
                Self::BoundingBoxProperties => Some("BoundingBoxProperties"),
                Self::AudioProperties => Some("AudioProperties"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ContentProperties {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ContentProperties {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ContentProperties {
        type Output = ContentProperties;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ContentProperties {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ContentProperties {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ContentProperties {}
    pub struct ContentPropertiesUnionTableOffset {}

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_SCORE_TRANSFORMATION_TYPE: i8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_SCORE_TRANSFORMATION_TYPE: i8 = 2;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_SCORE_TRANSFORMATION_TYPE: [ScoreTransformationType; 3] = [
        ScoreTransformationType::IDENTITY,
        ScoreTransformationType::LOG,
        ScoreTransformationType::INVERSE_LOGISTIC,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ScoreTransformationType(pub i8);
    #[allow(non_upper_case_globals)]
    impl ScoreTransformationType {
        pub const IDENTITY: Self = Self(0);
        pub const LOG: Self = Self(1);
        pub const INVERSE_LOGISTIC: Self = Self(2);

        pub const ENUM_MIN: i8 = 0;
        pub const ENUM_MAX: i8 = 2;
        pub const ENUM_VALUES: &'static [Self] =
            &[Self::IDENTITY, Self::LOG, Self::INVERSE_LOGISTIC];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::IDENTITY => Some("IDENTITY"),
                Self::LOG => Some("LOG"),
                Self::INVERSE_LOGISTIC => Some("INVERSE_LOGISTIC"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ScoreTransformationType {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ScoreTransformationType {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ScoreTransformationType {
        type Output = ScoreTransformationType;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<i8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ScoreTransformationType {
        type Scalar = i8;
        #[inline]
        fn to_little_endian(self) -> i8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: i8) -> Self {
            let b = i8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ScoreTransformationType {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            i8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ScoreTransformationType {}
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_PROCESS_UNIT_OPTIONS: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_PROCESS_UNIT_OPTIONS: u8 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_PROCESS_UNIT_OPTIONS: [ProcessUnitOptions; 7] = [
        ProcessUnitOptions::NONE,
        ProcessUnitOptions::NormalizationOptions,
        ProcessUnitOptions::ScoreCalibrationOptions,
        ProcessUnitOptions::ScoreThresholdingOptions,
        ProcessUnitOptions::BertTokenizerOptions,
        ProcessUnitOptions::SentencePieceTokenizerOptions,
        ProcessUnitOptions::RegexTokenizerOptions,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct ProcessUnitOptions(pub u8);
    #[allow(non_upper_case_globals)]
    impl ProcessUnitOptions {
        pub const NONE: Self = Self(0);
        pub const NormalizationOptions: Self = Self(1);
        pub const ScoreCalibrationOptions: Self = Self(2);
        pub const ScoreThresholdingOptions: Self = Self(3);
        pub const BertTokenizerOptions: Self = Self(4);
        pub const SentencePieceTokenizerOptions: Self = Self(5);
        pub const RegexTokenizerOptions: Self = Self(6);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::NormalizationOptions,
            Self::ScoreCalibrationOptions,
            Self::ScoreThresholdingOptions,
            Self::BertTokenizerOptions,
            Self::SentencePieceTokenizerOptions,
            Self::RegexTokenizerOptions,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::NormalizationOptions => Some("NormalizationOptions"),
                Self::ScoreCalibrationOptions => Some("ScoreCalibrationOptions"),
                Self::ScoreThresholdingOptions => Some("ScoreThresholdingOptions"),
                Self::BertTokenizerOptions => Some("BertTokenizerOptions"),
                Self::SentencePieceTokenizerOptions => Some("SentencePieceTokenizerOptions"),
                Self::RegexTokenizerOptions => Some("RegexTokenizerOptions"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for ProcessUnitOptions {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for ProcessUnitOptions {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for ProcessUnitOptions {
        type Output = ProcessUnitOptions;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for ProcessUnitOptions {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for ProcessUnitOptions {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for ProcessUnitOptions {}
    pub struct ProcessUnitOptionsUnionTableOffset {}

    pub enum AssociatedFileOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AssociatedFile<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AssociatedFile<'a> {
        type Inner = AssociatedFile<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AssociatedFile<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
        pub const VT_LOCALE: flatbuffers::VOffsetT = 10;
        pub const VT_VERSION: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AssociatedFile { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AssociatedFileArgs<'args>,
        ) -> flatbuffers::WIPOffset<AssociatedFile<'bldr>> {
            let mut builder = AssociatedFileBuilder::new(_fbb);
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            if let Some(x) = args.locale {
                builder.add_locale(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AssociatedFile::VT_NAME, None)
            }
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AssociatedFile::VT_DESCRIPTION, None)
            }
        }
        #[inline]
        pub fn type_(&self) -> AssociatedFileType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<AssociatedFileType>(
                        AssociatedFile::VT_TYPE_,
                        Some(AssociatedFileType::UNKNOWN),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn locale(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AssociatedFile::VT_LOCALE, None)
            }
        }
        #[inline]
        pub fn version(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(AssociatedFile::VT_VERSION, None)
            }
        }
    }

    impl flatbuffers::Verifiable for AssociatedFile<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "description",
                    Self::VT_DESCRIPTION,
                    false,
                )?
                .visit_field::<AssociatedFileType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "locale",
                    Self::VT_LOCALE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct AssociatedFileArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub type_: AssociatedFileType,
        pub locale: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for AssociatedFileArgs<'a> {
        #[inline]
        fn default() -> Self {
            AssociatedFileArgs {
                name: None,
                description: None,
                type_: AssociatedFileType::UNKNOWN,
                locale: None,
                version: None,
            }
        }
    }

    pub struct AssociatedFileBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AssociatedFileBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AssociatedFile::VT_NAME, name);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                AssociatedFile::VT_DESCRIPTION,
                description,
            );
        }
        #[inline]
        pub fn add_type_(&mut self, type_: AssociatedFileType) {
            self.fbb_.push_slot::<AssociatedFileType>(
                AssociatedFile::VT_TYPE_,
                type_,
                AssociatedFileType::UNKNOWN,
            );
        }
        #[inline]
        pub fn add_locale(&mut self, locale: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AssociatedFile::VT_LOCALE, locale);
        }
        #[inline]
        pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(AssociatedFile::VT_VERSION, version);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AssociatedFileBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AssociatedFileBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AssociatedFile<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AssociatedFile<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AssociatedFile");
            ds.field("name", &self.name());
            ds.field("description", &self.description());
            ds.field("type_", &self.type_());
            ds.field("locale", &self.locale());
            ds.field("version", &self.version());
            ds.finish()
        }
    }
    pub enum FeaturePropertiesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct FeatureProperties<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for FeatureProperties<'a> {
        type Inner = FeatureProperties<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> FeatureProperties<'a> {
        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            FeatureProperties { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            _args: &'args FeaturePropertiesArgs,
        ) -> flatbuffers::WIPOffset<FeatureProperties<'bldr>> {
            let mut builder = FeaturePropertiesBuilder::new(_fbb);
            builder.finish()
        }
    }

    impl flatbuffers::Verifiable for FeatureProperties<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?.finish();
            Ok(())
        }
    }
    pub struct FeaturePropertiesArgs {}
    impl<'a> Default for FeaturePropertiesArgs {
        #[inline]
        fn default() -> Self {
            FeaturePropertiesArgs {}
        }
    }

    pub struct FeaturePropertiesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> FeaturePropertiesBuilder<'a, 'b> {
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> FeaturePropertiesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            FeaturePropertiesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<FeatureProperties<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for FeatureProperties<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("FeatureProperties");
            ds.finish()
        }
    }
    pub enum ImageSizeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ImageSize<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImageSize<'a> {
        type Inner = ImageSize<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ImageSize<'a> {
        pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
        pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImageSize { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImageSizeArgs,
        ) -> flatbuffers::WIPOffset<ImageSize<'bldr>> {
            let mut builder = ImageSizeBuilder::new(_fbb);
            builder.add_height(args.height);
            builder.add_width(args.width);
            builder.finish()
        }

        #[inline]
        pub fn width(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ImageSize::VT_WIDTH, Some(0)).unwrap() }
        }
        #[inline]
        pub fn height(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u32>(ImageSize::VT_HEIGHT, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for ImageSize<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("width", Self::VT_WIDTH, false)?
                .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ImageSizeArgs {
        pub width: u32,
        pub height: u32,
    }
    impl<'a> Default for ImageSizeArgs {
        #[inline]
        fn default() -> Self {
            ImageSizeArgs {
                width: 0,
                height: 0,
            }
        }
    }

    pub struct ImageSizeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImageSizeBuilder<'a, 'b> {
        #[inline]
        pub fn add_width(&mut self, width: u32) {
            self.fbb_.push_slot::<u32>(ImageSize::VT_WIDTH, width, 0);
        }
        #[inline]
        pub fn add_height(&mut self, height: u32) {
            self.fbb_.push_slot::<u32>(ImageSize::VT_HEIGHT, height, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImageSizeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImageSizeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImageSize<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ImageSize<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ImageSize");
            ds.field("width", &self.width());
            ds.field("height", &self.height());
            ds.finish()
        }
    }
    pub enum ImagePropertiesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ImageProperties<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ImageProperties<'a> {
        type Inner = ImageProperties<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ImageProperties<'a> {
        pub const VT_COLOR_SPACE: flatbuffers::VOffsetT = 4;
        pub const VT_DEFAULT_SIZE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ImageProperties { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ImagePropertiesArgs<'args>,
        ) -> flatbuffers::WIPOffset<ImageProperties<'bldr>> {
            let mut builder = ImagePropertiesBuilder::new(_fbb);
            if let Some(x) = args.default_size {
                builder.add_default_size(x);
            }
            builder.add_color_space(args.color_space);
            builder.finish()
        }

        #[inline]
        pub fn color_space(&self) -> ColorSpaceType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ColorSpaceType>(
                        ImageProperties::VT_COLOR_SPACE,
                        Some(ColorSpaceType::UNKNOWN),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn default_size(&self) -> Option<ImageSize<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<ImageSize>>(
                    ImageProperties::VT_DEFAULT_SIZE,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for ImageProperties<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ColorSpaceType>("color_space", Self::VT_COLOR_SPACE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<ImageSize>>(
                    "default_size",
                    Self::VT_DEFAULT_SIZE,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ImagePropertiesArgs<'a> {
        pub color_space: ColorSpaceType,
        pub default_size: Option<flatbuffers::WIPOffset<ImageSize<'a>>>,
    }
    impl<'a> Default for ImagePropertiesArgs<'a> {
        #[inline]
        fn default() -> Self {
            ImagePropertiesArgs {
                color_space: ColorSpaceType::UNKNOWN,
                default_size: None,
            }
        }
    }

    pub struct ImagePropertiesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ImagePropertiesBuilder<'a, 'b> {
        #[inline]
        pub fn add_color_space(&mut self, color_space: ColorSpaceType) {
            self.fbb_.push_slot::<ColorSpaceType>(
                ImageProperties::VT_COLOR_SPACE,
                color_space,
                ColorSpaceType::UNKNOWN,
            );
        }
        #[inline]
        pub fn add_default_size(&mut self, default_size: flatbuffers::WIPOffset<ImageSize<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ImageSize>>(
                    ImageProperties::VT_DEFAULT_SIZE,
                    default_size,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ImagePropertiesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ImagePropertiesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ImageProperties<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ImageProperties<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ImageProperties");
            ds.field("color_space", &self.color_space());
            ds.field("default_size", &self.default_size());
            ds.finish()
        }
    }
    pub enum AudioPropertiesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct AudioProperties<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for AudioProperties<'a> {
        type Inner = AudioProperties<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> AudioProperties<'a> {
        pub const VT_SAMPLE_RATE: flatbuffers::VOffsetT = 4;
        pub const VT_CHANNELS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            AudioProperties { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args AudioPropertiesArgs,
        ) -> flatbuffers::WIPOffset<AudioProperties<'bldr>> {
            let mut builder = AudioPropertiesBuilder::new(_fbb);
            builder.add_channels(args.channels);
            builder.add_sample_rate(args.sample_rate);
            builder.finish()
        }

        #[inline]
        pub fn sample_rate(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AudioProperties::VT_SAMPLE_RATE, Some(0))
                    .unwrap()
            }
        }
        #[inline]
        pub fn channels(&self) -> u32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<u32>(AudioProperties::VT_CHANNELS, Some(0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for AudioProperties<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<u32>("sample_rate", Self::VT_SAMPLE_RATE, false)?
                .visit_field::<u32>("channels", Self::VT_CHANNELS, false)?
                .finish();
            Ok(())
        }
    }
    pub struct AudioPropertiesArgs {
        pub sample_rate: u32,
        pub channels: u32,
    }
    impl<'a> Default for AudioPropertiesArgs {
        #[inline]
        fn default() -> Self {
            AudioPropertiesArgs {
                sample_rate: 0,
                channels: 0,
            }
        }
    }

    pub struct AudioPropertiesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> AudioPropertiesBuilder<'a, 'b> {
        #[inline]
        pub fn add_sample_rate(&mut self, sample_rate: u32) {
            self.fbb_
                .push_slot::<u32>(AudioProperties::VT_SAMPLE_RATE, sample_rate, 0);
        }
        #[inline]
        pub fn add_channels(&mut self, channels: u32) {
            self.fbb_
                .push_slot::<u32>(AudioProperties::VT_CHANNELS, channels, 0);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> AudioPropertiesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            AudioPropertiesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<AudioProperties<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for AudioProperties<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("AudioProperties");
            ds.field("sample_rate", &self.sample_rate());
            ds.field("channels", &self.channels());
            ds.finish()
        }
    }
    pub enum BoundingBoxPropertiesOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BoundingBoxProperties<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BoundingBoxProperties<'a> {
        type Inner = BoundingBoxProperties<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BoundingBoxProperties<'a> {
        pub const VT_INDEX: flatbuffers::VOffsetT = 4;
        pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
        pub const VT_COORDINATE_TYPE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BoundingBoxProperties { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BoundingBoxPropertiesArgs<'args>,
        ) -> flatbuffers::WIPOffset<BoundingBoxProperties<'bldr>> {
            let mut builder = BoundingBoxPropertiesBuilder::new(_fbb);
            if let Some(x) = args.index {
                builder.add_index(x);
            }
            builder.add_coordinate_type(args.coordinate_type);
            builder.add_type_(args.type_);
            builder.finish()
        }

        #[inline]
        pub fn index(&self) -> Option<flatbuffers::Vector<'a, u32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                        BoundingBoxProperties::VT_INDEX,
                        None,
                    )
            }
        }
        #[inline]
        pub fn type_(&self) -> BoundingBoxType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<BoundingBoxType>(
                        BoundingBoxProperties::VT_TYPE_,
                        Some(BoundingBoxType::UNKNOWN),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn coordinate_type(&self) -> CoordinateType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<CoordinateType>(
                        BoundingBoxProperties::VT_COORDINATE_TYPE,
                        Some(CoordinateType::RATIO),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for BoundingBoxProperties<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                    "index",
                    Self::VT_INDEX,
                    false,
                )?
                .visit_field::<BoundingBoxType>("type_", Self::VT_TYPE_, false)?
                .visit_field::<CoordinateType>("coordinate_type", Self::VT_COORDINATE_TYPE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BoundingBoxPropertiesArgs<'a> {
        pub index: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        pub type_: BoundingBoxType,
        pub coordinate_type: CoordinateType,
    }
    impl<'a> Default for BoundingBoxPropertiesArgs<'a> {
        #[inline]
        fn default() -> Self {
            BoundingBoxPropertiesArgs {
                index: None,
                type_: BoundingBoxType::UNKNOWN,
                coordinate_type: CoordinateType::RATIO,
            }
        }
    }

    pub struct BoundingBoxPropertiesBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BoundingBoxPropertiesBuilder<'a, 'b> {
        #[inline]
        pub fn add_index(&mut self, index: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BoundingBoxProperties::VT_INDEX,
                index,
            );
        }
        #[inline]
        pub fn add_type_(&mut self, type_: BoundingBoxType) {
            self.fbb_.push_slot::<BoundingBoxType>(
                BoundingBoxProperties::VT_TYPE_,
                type_,
                BoundingBoxType::UNKNOWN,
            );
        }
        #[inline]
        pub fn add_coordinate_type(&mut self, coordinate_type: CoordinateType) {
            self.fbb_.push_slot::<CoordinateType>(
                BoundingBoxProperties::VT_COORDINATE_TYPE,
                coordinate_type,
                CoordinateType::RATIO,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BoundingBoxPropertiesBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BoundingBoxPropertiesBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BoundingBoxProperties<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BoundingBoxProperties<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BoundingBoxProperties");
            ds.field("index", &self.index());
            ds.field("type_", &self.type_());
            ds.field("coordinate_type", &self.coordinate_type());
            ds.finish()
        }
    }
    pub enum ValueRangeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ValueRange<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ValueRange<'a> {
        type Inner = ValueRange<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ValueRange<'a> {
        pub const VT_MIN: flatbuffers::VOffsetT = 4;
        pub const VT_MAX: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ValueRange { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ValueRangeArgs,
        ) -> flatbuffers::WIPOffset<ValueRange<'bldr>> {
            let mut builder = ValueRangeBuilder::new(_fbb);
            builder.add_max(args.max);
            builder.add_min(args.min);
            builder.finish()
        }

        #[inline]
        pub fn min(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(ValueRange::VT_MIN, Some(0)).unwrap() }
        }
        #[inline]
        pub fn max(&self) -> i32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<i32>(ValueRange::VT_MAX, Some(0)).unwrap() }
        }
    }

    impl flatbuffers::Verifiable for ValueRange<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<i32>("min", Self::VT_MIN, false)?
                .visit_field::<i32>("max", Self::VT_MAX, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ValueRangeArgs {
        pub min: i32,
        pub max: i32,
    }
    impl<'a> Default for ValueRangeArgs {
        #[inline]
        fn default() -> Self {
            ValueRangeArgs { min: 0, max: 0 }
        }
    }

    pub struct ValueRangeBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ValueRangeBuilder<'a, 'b> {
        #[inline]
        pub fn add_min(&mut self, min: i32) {
            self.fbb_.push_slot::<i32>(ValueRange::VT_MIN, min, 0);
        }
        #[inline]
        pub fn add_max(&mut self, max: i32) {
            self.fbb_.push_slot::<i32>(ValueRange::VT_MAX, max, 0);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueRangeBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ValueRangeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ValueRange<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ValueRange<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ValueRange");
            ds.field("min", &self.min());
            ds.field("max", &self.max());
            ds.finish()
        }
    }
    pub enum ContentOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Content<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Content<'a> {
        type Inner = Content<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Content<'a> {
        pub const VT_CONTENT_PROPERTIES_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_CONTENT_PROPERTIES: flatbuffers::VOffsetT = 6;
        pub const VT_RANGE: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Content { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ContentArgs<'args>,
        ) -> flatbuffers::WIPOffset<Content<'bldr>> {
            let mut builder = ContentBuilder::new(_fbb);
            if let Some(x) = args.range {
                builder.add_range(x);
            }
            if let Some(x) = args.content_properties {
                builder.add_content_properties(x);
            }
            builder.add_content_properties_type(args.content_properties_type);
            builder.finish()
        }

        #[inline]
        pub fn content_properties_type(&self) -> ContentProperties {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ContentProperties>(
                        Content::VT_CONTENT_PROPERTIES_TYPE,
                        Some(ContentProperties::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn content_properties(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Content::VT_CONTENT_PROPERTIES,
                        None,
                    )
            }
        }
        #[inline]
        pub fn range(&self) -> Option<ValueRange<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<ValueRange>>(Content::VT_RANGE, None)
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn content_properties_as_feature_properties(&self) -> Option<FeatureProperties<'a>> {
            if self.content_properties_type() == ContentProperties::FeatureProperties {
                self.content_properties().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { FeatureProperties::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn content_properties_as_image_properties(&self) -> Option<ImageProperties<'a>> {
            if self.content_properties_type() == ContentProperties::ImageProperties {
                self.content_properties().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ImageProperties::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn content_properties_as_bounding_box_properties(
            &self,
        ) -> Option<BoundingBoxProperties<'a>> {
            if self.content_properties_type() == ContentProperties::BoundingBoxProperties {
                self.content_properties().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BoundingBoxProperties::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn content_properties_as_audio_properties(&self) -> Option<AudioProperties<'a>> {
            if self.content_properties_type() == ContentProperties::AudioProperties {
                self.content_properties().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { AudioProperties::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Content<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<ContentProperties, _>("content_properties_type", Self::VT_CONTENT_PROPERTIES_TYPE, "content_properties", Self::VT_CONTENT_PROPERTIES, false, |key, v, pos| {
        match key {
          ContentProperties::FeatureProperties => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FeatureProperties>>("ContentProperties::FeatureProperties", pos),
          ContentProperties::ImageProperties => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ImageProperties>>("ContentProperties::ImageProperties", pos),
          ContentProperties::BoundingBoxProperties => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoundingBoxProperties>>("ContentProperties::BoundingBoxProperties", pos),
          ContentProperties::AudioProperties => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AudioProperties>>("ContentProperties::AudioProperties", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<ValueRange>>("range", Self::VT_RANGE, false)?
     .finish();
            Ok(())
        }
    }
    pub struct ContentArgs<'a> {
        pub content_properties_type: ContentProperties,
        pub content_properties: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        pub range: Option<flatbuffers::WIPOffset<ValueRange<'a>>>,
    }
    impl<'a> Default for ContentArgs<'a> {
        #[inline]
        fn default() -> Self {
            ContentArgs {
                content_properties_type: ContentProperties::NONE,
                content_properties: None,
                range: None,
            }
        }
    }

    pub struct ContentBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ContentBuilder<'a, 'b> {
        #[inline]
        pub fn add_content_properties_type(&mut self, content_properties_type: ContentProperties) {
            self.fbb_.push_slot::<ContentProperties>(
                Content::VT_CONTENT_PROPERTIES_TYPE,
                content_properties_type,
                ContentProperties::NONE,
            );
        }
        #[inline]
        pub fn add_content_properties(
            &mut self,
            content_properties: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Content::VT_CONTENT_PROPERTIES,
                content_properties,
            );
        }
        #[inline]
        pub fn add_range(&mut self, range: flatbuffers::WIPOffset<ValueRange<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<ValueRange>>(Content::VT_RANGE, range);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContentBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ContentBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Content<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Content<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Content");
            ds.field("content_properties_type", &self.content_properties_type());
            match self.content_properties_type() {
                ContentProperties::FeatureProperties => {
                    if let Some(x) = self.content_properties_as_feature_properties() {
                        ds.field("content_properties", &x)
                    } else {
                        ds.field(
                            "content_properties",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContentProperties::ImageProperties => {
                    if let Some(x) = self.content_properties_as_image_properties() {
                        ds.field("content_properties", &x)
                    } else {
                        ds.field(
                            "content_properties",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContentProperties::BoundingBoxProperties => {
                    if let Some(x) = self.content_properties_as_bounding_box_properties() {
                        ds.field("content_properties", &x)
                    } else {
                        ds.field(
                            "content_properties",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ContentProperties::AudioProperties => {
                    if let Some(x) = self.content_properties_as_audio_properties() {
                        ds.field("content_properties", &x)
                    } else {
                        ds.field(
                            "content_properties",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("content_properties", &x)
                }
            };
            ds.field("range", &self.range());
            ds.finish()
        }
    }
    pub enum NormalizationOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct NormalizationOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for NormalizationOptions<'a> {
        type Inner = NormalizationOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> NormalizationOptions<'a> {
        pub const VT_MEAN: flatbuffers::VOffsetT = 4;
        pub const VT_STD_: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            NormalizationOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args NormalizationOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<NormalizationOptions<'bldr>> {
            let mut builder = NormalizationOptionsBuilder::new(_fbb);
            if let Some(x) = args.std_ {
                builder.add_std_(x);
            }
            if let Some(x) = args.mean {
                builder.add_mean(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn mean(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        NormalizationOptions::VT_MEAN,
                        None,
                    )
            }
        }
        #[inline]
        pub fn std_(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        NormalizationOptions::VT_STD_,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for NormalizationOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "mean",
                    Self::VT_MEAN,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "std_",
                    Self::VT_STD_,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct NormalizationOptionsArgs<'a> {
        pub mean: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
        pub std_: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    }
    impl<'a> Default for NormalizationOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            NormalizationOptionsArgs {
                mean: None,
                std_: None,
            }
        }
    }

    pub struct NormalizationOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> NormalizationOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_mean(&mut self, mean: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NormalizationOptions::VT_MEAN, mean);
        }
        #[inline]
        pub fn add_std_(&mut self, std_: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(NormalizationOptions::VT_STD_, std_);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> NormalizationOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            NormalizationOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<NormalizationOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for NormalizationOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("NormalizationOptions");
            ds.field("mean", &self.mean());
            ds.field("std_", &self.std_());
            ds.finish()
        }
    }
    pub enum ScoreCalibrationOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ScoreCalibrationOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ScoreCalibrationOptions<'a> {
        type Inner = ScoreCalibrationOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ScoreCalibrationOptions<'a> {
        pub const VT_SCORE_TRANSFORMATION: flatbuffers::VOffsetT = 4;
        pub const VT_DEFAULT_SCORE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ScoreCalibrationOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ScoreCalibrationOptionsArgs,
        ) -> flatbuffers::WIPOffset<ScoreCalibrationOptions<'bldr>> {
            let mut builder = ScoreCalibrationOptionsBuilder::new(_fbb);
            builder.add_default_score(args.default_score);
            builder.add_score_transformation(args.score_transformation);
            builder.finish()
        }

        #[inline]
        pub fn score_transformation(&self) -> ScoreTransformationType {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ScoreTransformationType>(
                        ScoreCalibrationOptions::VT_SCORE_TRANSFORMATION,
                        Some(ScoreTransformationType::IDENTITY),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn default_score(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(ScoreCalibrationOptions::VT_DEFAULT_SCORE, Some(0.0))
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ScoreCalibrationOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<ScoreTransformationType>(
                    "score_transformation",
                    Self::VT_SCORE_TRANSFORMATION,
                    false,
                )?
                .visit_field::<f32>("default_score", Self::VT_DEFAULT_SCORE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct ScoreCalibrationOptionsArgs {
        pub score_transformation: ScoreTransformationType,
        pub default_score: f32,
    }
    impl<'a> Default for ScoreCalibrationOptionsArgs {
        #[inline]
        fn default() -> Self {
            ScoreCalibrationOptionsArgs {
                score_transformation: ScoreTransformationType::IDENTITY,
                default_score: 0.0,
            }
        }
    }

    pub struct ScoreCalibrationOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ScoreCalibrationOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_score_transformation(&mut self, score_transformation: ScoreTransformationType) {
            self.fbb_.push_slot::<ScoreTransformationType>(
                ScoreCalibrationOptions::VT_SCORE_TRANSFORMATION,
                score_transformation,
                ScoreTransformationType::IDENTITY,
            );
        }
        #[inline]
        pub fn add_default_score(&mut self, default_score: f32) {
            self.fbb_.push_slot::<f32>(
                ScoreCalibrationOptions::VT_DEFAULT_SCORE,
                default_score,
                0.0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ScoreCalibrationOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ScoreCalibrationOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ScoreCalibrationOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ScoreCalibrationOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ScoreCalibrationOptions");
            ds.field("score_transformation", &self.score_transformation());
            ds.field("default_score", &self.default_score());
            ds.finish()
        }
    }
    pub enum ScoreThresholdingOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ScoreThresholdingOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ScoreThresholdingOptions<'a> {
        type Inner = ScoreThresholdingOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ScoreThresholdingOptions<'a> {
        pub const VT_GLOBAL_SCORE_THRESHOLD: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ScoreThresholdingOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ScoreThresholdingOptionsArgs,
        ) -> flatbuffers::WIPOffset<ScoreThresholdingOptions<'bldr>> {
            let mut builder = ScoreThresholdingOptionsBuilder::new(_fbb);
            builder.add_global_score_threshold(args.global_score_threshold);
            builder.finish()
        }

        #[inline]
        pub fn global_score_threshold(&self) -> f32 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<f32>(
                        ScoreThresholdingOptions::VT_GLOBAL_SCORE_THRESHOLD,
                        Some(0.0),
                    )
                    .unwrap()
            }
        }
    }

    impl flatbuffers::Verifiable for ScoreThresholdingOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<f32>(
                    "global_score_threshold",
                    Self::VT_GLOBAL_SCORE_THRESHOLD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ScoreThresholdingOptionsArgs {
        pub global_score_threshold: f32,
    }
    impl<'a> Default for ScoreThresholdingOptionsArgs {
        #[inline]
        fn default() -> Self {
            ScoreThresholdingOptionsArgs {
                global_score_threshold: 0.0,
            }
        }
    }

    pub struct ScoreThresholdingOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ScoreThresholdingOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_global_score_threshold(&mut self, global_score_threshold: f32) {
            self.fbb_.push_slot::<f32>(
                ScoreThresholdingOptions::VT_GLOBAL_SCORE_THRESHOLD,
                global_score_threshold,
                0.0,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ScoreThresholdingOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ScoreThresholdingOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ScoreThresholdingOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ScoreThresholdingOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ScoreThresholdingOptions");
            ds.field("global_score_threshold", &self.global_score_threshold());
            ds.finish()
        }
    }
    pub enum BertTokenizerOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BertTokenizerOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BertTokenizerOptions<'a> {
        type Inner = BertTokenizerOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BertTokenizerOptions<'a> {
        pub const VT_VOCAB_FILE: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BertTokenizerOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args BertTokenizerOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<BertTokenizerOptions<'bldr>> {
            let mut builder = BertTokenizerOptionsBuilder::new(_fbb);
            if let Some(x) = args.vocab_file {
                builder.add_vocab_file(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn vocab_file(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(BertTokenizerOptions::VT_VOCAB_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for BertTokenizerOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("vocab_file", Self::VT_VOCAB_FILE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BertTokenizerOptionsArgs<'a> {
        pub vocab_file: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
    }
    impl<'a> Default for BertTokenizerOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            BertTokenizerOptionsArgs { vocab_file: None }
        }
    }

    pub struct BertTokenizerOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> BertTokenizerOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_vocab_file(
            &mut self,
            vocab_file: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BertTokenizerOptions::VT_VOCAB_FILE,
                vocab_file,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> BertTokenizerOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            BertTokenizerOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BertTokenizerOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BertTokenizerOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BertTokenizerOptions");
            ds.field("vocab_file", &self.vocab_file());
            ds.finish()
        }
    }
    pub enum SentencePieceTokenizerOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SentencePieceTokenizerOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SentencePieceTokenizerOptions<'a> {
        type Inner = SentencePieceTokenizerOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SentencePieceTokenizerOptions<'a> {
        pub const VT_SENTENCEPIECE_MODEL: flatbuffers::VOffsetT = 4;
        pub const VT_VOCAB_FILE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SentencePieceTokenizerOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SentencePieceTokenizerOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<SentencePieceTokenizerOptions<'bldr>> {
            let mut builder = SentencePieceTokenizerOptionsBuilder::new(_fbb);
            if let Some(x) = args.vocab_file {
                builder.add_vocab_file(x);
            }
            if let Some(x) = args.sentencePiece_model {
                builder.add_sentencePiece_model(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sentencePiece_model(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(
                    SentencePieceTokenizerOptions::VT_SENTENCEPIECE_MODEL, None
                )
            }
        }
        #[inline]
        pub fn vocab_file(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(SentencePieceTokenizerOptions::VT_VOCAB_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SentencePieceTokenizerOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("sentencePiece_model", Self::VT_SENTENCEPIECE_MODEL, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("vocab_file", Self::VT_VOCAB_FILE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SentencePieceTokenizerOptionsArgs<'a> {
        pub sentencePiece_model: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
        pub vocab_file: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SentencePieceTokenizerOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            SentencePieceTokenizerOptionsArgs {
                sentencePiece_model: None,
                vocab_file: None,
            }
        }
    }

    pub struct SentencePieceTokenizerOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SentencePieceTokenizerOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_sentencePiece_model(
            &mut self,
            sentencePiece_model: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SentencePieceTokenizerOptions::VT_SENTENCEPIECE_MODEL,
                sentencePiece_model,
            );
        }
        #[inline]
        pub fn add_vocab_file(
            &mut self,
            vocab_file: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SentencePieceTokenizerOptions::VT_VOCAB_FILE,
                vocab_file,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SentencePieceTokenizerOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SentencePieceTokenizerOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SentencePieceTokenizerOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SentencePieceTokenizerOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SentencePieceTokenizerOptions");
            ds.field("sentencePiece_model", &self.sentencePiece_model());
            ds.field("vocab_file", &self.vocab_file());
            ds.finish()
        }
    }
    pub enum RegexTokenizerOptionsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct RegexTokenizerOptions<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RegexTokenizerOptions<'a> {
        type Inner = RegexTokenizerOptions<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> RegexTokenizerOptions<'a> {
        pub const VT_DELIM_REGEX_PATTERN: flatbuffers::VOffsetT = 4;
        pub const VT_VOCAB_FILE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RegexTokenizerOptions { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RegexTokenizerOptionsArgs<'args>,
        ) -> flatbuffers::WIPOffset<RegexTokenizerOptions<'bldr>> {
            let mut builder = RegexTokenizerOptionsBuilder::new(_fbb);
            if let Some(x) = args.vocab_file {
                builder.add_vocab_file(x);
            }
            if let Some(x) = args.delim_regex_pattern {
                builder.add_delim_regex_pattern(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn delim_regex_pattern(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    RegexTokenizerOptions::VT_DELIM_REGEX_PATTERN,
                    None,
                )
            }
        }
        #[inline]
        pub fn vocab_file(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(RegexTokenizerOptions::VT_VOCAB_FILE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for RegexTokenizerOptions<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "delim_regex_pattern",
                    Self::VT_DELIM_REGEX_PATTERN,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("vocab_file", Self::VT_VOCAB_FILE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct RegexTokenizerOptionsArgs<'a> {
        pub delim_regex_pattern: Option<flatbuffers::WIPOffset<&'a str>>,
        pub vocab_file: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
    }
    impl<'a> Default for RegexTokenizerOptionsArgs<'a> {
        #[inline]
        fn default() -> Self {
            RegexTokenizerOptionsArgs {
                delim_regex_pattern: None,
                vocab_file: None,
            }
        }
    }

    pub struct RegexTokenizerOptionsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RegexTokenizerOptionsBuilder<'a, 'b> {
        #[inline]
        pub fn add_delim_regex_pattern(
            &mut self,
            delim_regex_pattern: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RegexTokenizerOptions::VT_DELIM_REGEX_PATTERN,
                delim_regex_pattern,
            );
        }
        #[inline]
        pub fn add_vocab_file(
            &mut self,
            vocab_file: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RegexTokenizerOptions::VT_VOCAB_FILE,
                vocab_file,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> RegexTokenizerOptionsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RegexTokenizerOptionsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RegexTokenizerOptions<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for RegexTokenizerOptions<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("RegexTokenizerOptions");
            ds.field("delim_regex_pattern", &self.delim_regex_pattern());
            ds.field("vocab_file", &self.vocab_file());
            ds.finish()
        }
    }
    pub enum ProcessUnitOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ProcessUnit<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ProcessUnit<'a> {
        type Inner = ProcessUnit<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ProcessUnit<'a> {
        pub const VT_OPTIONS_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_OPTIONS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ProcessUnit { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ProcessUnitArgs,
        ) -> flatbuffers::WIPOffset<ProcessUnit<'bldr>> {
            let mut builder = ProcessUnitBuilder::new(_fbb);
            if let Some(x) = args.options {
                builder.add_options(x);
            }
            builder.add_options_type(args.options_type);
            builder.finish()
        }

        #[inline]
        pub fn options_type(&self) -> ProcessUnitOptions {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<ProcessUnitOptions>(
                        ProcessUnit::VT_OPTIONS_TYPE,
                        Some(ProcessUnitOptions::NONE),
                    )
                    .unwrap()
            }
        }
        #[inline]
        pub fn options(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        ProcessUnit::VT_OPTIONS,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_normalization_options(&self) -> Option<NormalizationOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::NormalizationOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { NormalizationOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_score_calibration_options(&self) -> Option<ScoreCalibrationOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::ScoreCalibrationOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ScoreCalibrationOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_score_thresholding_options(
            &self,
        ) -> Option<ScoreThresholdingOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::ScoreThresholdingOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { ScoreThresholdingOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_bert_tokenizer_options(&self) -> Option<BertTokenizerOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::BertTokenizerOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BertTokenizerOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_sentence_piece_tokenizer_options(
            &self,
        ) -> Option<SentencePieceTokenizerOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::SentencePieceTokenizerOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SentencePieceTokenizerOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn options_as_regex_tokenizer_options(&self) -> Option<RegexTokenizerOptions<'a>> {
            if self.options_type() == ProcessUnitOptions::RegexTokenizerOptions {
                self.options().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { RegexTokenizerOptions::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for ProcessUnit<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
     .visit_union::<ProcessUnitOptions, _>("options_type", Self::VT_OPTIONS_TYPE, "options", Self::VT_OPTIONS, false, |key, v, pos| {
        match key {
          ProcessUnitOptions::NormalizationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NormalizationOptions>>("ProcessUnitOptions::NormalizationOptions", pos),
          ProcessUnitOptions::ScoreCalibrationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScoreCalibrationOptions>>("ProcessUnitOptions::ScoreCalibrationOptions", pos),
          ProcessUnitOptions::ScoreThresholdingOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScoreThresholdingOptions>>("ProcessUnitOptions::ScoreThresholdingOptions", pos),
          ProcessUnitOptions::BertTokenizerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BertTokenizerOptions>>("ProcessUnitOptions::BertTokenizerOptions", pos),
          ProcessUnitOptions::SentencePieceTokenizerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SentencePieceTokenizerOptions>>("ProcessUnitOptions::SentencePieceTokenizerOptions", pos),
          ProcessUnitOptions::RegexTokenizerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RegexTokenizerOptions>>("ProcessUnitOptions::RegexTokenizerOptions", pos),
          _ => Ok(()),
        }
     })?
     .finish();
            Ok(())
        }
    }
    pub struct ProcessUnitArgs {
        pub options_type: ProcessUnitOptions,
        pub options: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for ProcessUnitArgs {
        #[inline]
        fn default() -> Self {
            ProcessUnitArgs {
                options_type: ProcessUnitOptions::NONE,
                options: None,
            }
        }
    }

    pub struct ProcessUnitBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ProcessUnitBuilder<'a, 'b> {
        #[inline]
        pub fn add_options_type(&mut self, options_type: ProcessUnitOptions) {
            self.fbb_.push_slot::<ProcessUnitOptions>(
                ProcessUnit::VT_OPTIONS_TYPE,
                options_type,
                ProcessUnitOptions::NONE,
            );
        }
        #[inline]
        pub fn add_options(
            &mut self,
            options: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ProcessUnit::VT_OPTIONS, options);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProcessUnitBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ProcessUnitBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ProcessUnit<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ProcessUnit<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ProcessUnit");
            ds.field("options_type", &self.options_type());
            match self.options_type() {
                ProcessUnitOptions::NormalizationOptions => {
                    if let Some(x) = self.options_as_normalization_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ProcessUnitOptions::ScoreCalibrationOptions => {
                    if let Some(x) = self.options_as_score_calibration_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ProcessUnitOptions::ScoreThresholdingOptions => {
                    if let Some(x) = self.options_as_score_thresholding_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ProcessUnitOptions::BertTokenizerOptions => {
                    if let Some(x) = self.options_as_bert_tokenizer_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ProcessUnitOptions::SentencePieceTokenizerOptions => {
                    if let Some(x) = self.options_as_sentence_piece_tokenizer_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                ProcessUnitOptions::RegexTokenizerOptions => {
                    if let Some(x) = self.options_as_regex_tokenizer_options() {
                        ds.field("options", &x)
                    } else {
                        ds.field(
                            "options",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("options", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum StatsOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Stats<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Stats<'a> {
        type Inner = Stats<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Stats<'a> {
        pub const VT_MAX: flatbuffers::VOffsetT = 4;
        pub const VT_MIN: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Stats { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args StatsArgs<'args>,
        ) -> flatbuffers::WIPOffset<Stats<'bldr>> {
            let mut builder = StatsBuilder::new(_fbb);
            if let Some(x) = args.min {
                builder.add_min(x);
            }
            if let Some(x) = args.max {
                builder.add_max(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn max(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        Stats::VT_MAX,
                        None,
                    )
            }
        }
        #[inline]
        pub fn min(&self) -> Option<flatbuffers::Vector<'a, f32>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                        Stats::VT_MIN,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Stats<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "max",
                    Self::VT_MAX,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                    "min",
                    Self::VT_MIN,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct StatsArgs<'a> {
        pub max: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
        pub min: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    }
    impl<'a> Default for StatsArgs<'a> {
        #[inline]
        fn default() -> Self {
            StatsArgs {
                max: None,
                min: None,
            }
        }
    }

    pub struct StatsBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> StatsBuilder<'a, 'b> {
        #[inline]
        pub fn add_max(&mut self, max: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Stats::VT_MAX, max);
        }
        #[inline]
        pub fn add_min(&mut self, min: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Stats::VT_MIN, min);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StatsBuilder<'a, 'b> {
            let start = _fbb.start_table();
            StatsBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Stats<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Stats<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Stats");
            ds.field("max", &self.max());
            ds.field("min", &self.min());
            ds.finish()
        }
    }
    pub enum TensorGroupOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TensorGroup<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TensorGroup<'a> {
        type Inner = TensorGroup<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TensorGroup<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_TENSOR_NAMES: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TensorGroup { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TensorGroupArgs<'args>,
        ) -> flatbuffers::WIPOffset<TensorGroup<'bldr>> {
            let mut builder = TensorGroupBuilder::new(_fbb);
            if let Some(x) = args.tensor_names {
                builder.add_tensor_names(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TensorGroup::VT_NAME, None)
            }
        }
        #[inline]
        pub fn tensor_names(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(TensorGroup::VT_TENSOR_NAMES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TensorGroup<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("tensor_names", Self::VT_TENSOR_NAMES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TensorGroupArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub tensor_names: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
    }
    impl<'a> Default for TensorGroupArgs<'a> {
        #[inline]
        fn default() -> Self {
            TensorGroupArgs {
                name: None,
                tensor_names: None,
            }
        }
    }

    pub struct TensorGroupBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TensorGroupBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TensorGroup::VT_NAME, name);
        }
        #[inline]
        pub fn add_tensor_names(
            &mut self,
            tensor_names: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TensorGroup::VT_TENSOR_NAMES,
                tensor_names,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorGroupBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TensorGroupBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TensorGroup<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TensorGroup<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TensorGroup");
            ds.field("name", &self.name());
            ds.field("tensor_names", &self.tensor_names());
            ds.finish()
        }
    }
    pub enum TensorMetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct TensorMetadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for TensorMetadata<'a> {
        type Inner = TensorMetadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> TensorMetadata<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
        pub const VT_DIMENSION_NAMES: flatbuffers::VOffsetT = 8;
        pub const VT_CONTENT: flatbuffers::VOffsetT = 10;
        pub const VT_PROCESS_UNITS: flatbuffers::VOffsetT = 12;
        pub const VT_STATS: flatbuffers::VOffsetT = 14;
        pub const VT_ASSOCIATED_FILES: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            TensorMetadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args TensorMetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<TensorMetadata<'bldr>> {
            let mut builder = TensorMetadataBuilder::new(_fbb);
            if let Some(x) = args.associated_files {
                builder.add_associated_files(x);
            }
            if let Some(x) = args.stats {
                builder.add_stats(x);
            }
            if let Some(x) = args.process_units {
                builder.add_process_units(x);
            }
            if let Some(x) = args.content {
                builder.add_content(x);
            }
            if let Some(x) = args.dimension_names {
                builder.add_dimension_names(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TensorMetadata::VT_NAME, None)
            }
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(TensorMetadata::VT_DESCRIPTION, None)
            }
        }
        #[inline]
        pub fn dimension_names(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(TensorMetadata::VT_DIMENSION_NAMES, None)
            }
        }
        #[inline]
        pub fn content(&self) -> Option<Content<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Content>>(TensorMetadata::VT_CONTENT, None)
            }
        }
        #[inline]
        pub fn process_units(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>(TensorMetadata::VT_PROCESS_UNITS, None)
            }
        }
        #[inline]
        pub fn stats(&self) -> Option<Stats<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Stats>>(TensorMetadata::VT_STATS, None)
            }
        }
        #[inline]
        pub fn associated_files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(TensorMetadata::VT_ASSOCIATED_FILES, None)
            }
        }
    }

    impl flatbuffers::Verifiable for TensorMetadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "description",
                    Self::VT_DESCRIPTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
                >>("dimension_names", Self::VT_DIMENSION_NAMES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Content>>(
                    "content",
                    Self::VT_CONTENT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>("process_units", Self::VT_PROCESS_UNITS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<Stats>>("stats", Self::VT_STATS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("associated_files", Self::VT_ASSOCIATED_FILES, false)?
                .finish();
            Ok(())
        }
    }
    pub struct TensorMetadataArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub dimension_names: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub content: Option<flatbuffers::WIPOffset<Content<'a>>>,
        pub process_units: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>,
            >,
        >,
        pub stats: Option<flatbuffers::WIPOffset<Stats<'a>>>,
        pub associated_files: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
    }
    impl<'a> Default for TensorMetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            TensorMetadataArgs {
                name: None,
                description: None,
                dimension_names: None,
                content: None,
                process_units: None,
                stats: None,
                associated_files: None,
            }
        }
    }

    pub struct TensorMetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> TensorMetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(TensorMetadata::VT_NAME, name);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TensorMetadata::VT_DESCRIPTION,
                description,
            );
        }
        #[inline]
        pub fn add_dimension_names(
            &mut self,
            dimension_names: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TensorMetadata::VT_DIMENSION_NAMES,
                dimension_names,
            );
        }
        #[inline]
        pub fn add_content(&mut self, content: flatbuffers::WIPOffset<Content<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Content>>(
                    TensorMetadata::VT_CONTENT,
                    content,
                );
        }
        #[inline]
        pub fn add_process_units(
            &mut self,
            process_units: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ProcessUnit<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TensorMetadata::VT_PROCESS_UNITS,
                process_units,
            );
        }
        #[inline]
        pub fn add_stats(&mut self, stats: flatbuffers::WIPOffset<Stats<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Stats>>(TensorMetadata::VT_STATS, stats);
        }
        #[inline]
        pub fn add_associated_files(
            &mut self,
            associated_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                TensorMetadata::VT_ASSOCIATED_FILES,
                associated_files,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> TensorMetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            TensorMetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<TensorMetadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for TensorMetadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("TensorMetadata");
            ds.field("name", &self.name());
            ds.field("description", &self.description());
            ds.field("dimension_names", &self.dimension_names());
            ds.field("content", &self.content());
            ds.field("process_units", &self.process_units());
            ds.field("stats", &self.stats());
            ds.field("associated_files", &self.associated_files());
            ds.finish()
        }
    }
    pub enum CustomMetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct CustomMetadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for CustomMetadata<'a> {
        type Inner = CustomMetadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> CustomMetadata<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_DATA: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            CustomMetadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CustomMetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<CustomMetadata<'bldr>> {
            let mut builder = CustomMetadataBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(CustomMetadata::VT_NAME, None)
            }
        }
        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        CustomMetadata::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for CustomMetadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct CustomMetadataArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for CustomMetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            CustomMetadataArgs {
                name: None,
                data: None,
            }
        }
    }

    pub struct CustomMetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CustomMetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMetadata::VT_NAME, name);
        }
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(CustomMetadata::VT_DATA, data);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> CustomMetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CustomMetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<CustomMetadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for CustomMetadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("CustomMetadata");
            ds.field("name", &self.name());
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    pub enum SubGraphMetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SubGraphMetadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SubGraphMetadata<'a> {
        type Inner = SubGraphMetadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SubGraphMetadata<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
        pub const VT_INPUT_TENSOR_METADATA: flatbuffers::VOffsetT = 8;
        pub const VT_OUTPUT_TENSOR_METADATA: flatbuffers::VOffsetT = 10;
        pub const VT_ASSOCIATED_FILES: flatbuffers::VOffsetT = 12;
        pub const VT_INPUT_PROCESS_UNITS: flatbuffers::VOffsetT = 14;
        pub const VT_OUTPUT_PROCESS_UNITS: flatbuffers::VOffsetT = 16;
        pub const VT_INPUT_TENSOR_GROUPS: flatbuffers::VOffsetT = 18;
        pub const VT_OUTPUT_TENSOR_GROUPS: flatbuffers::VOffsetT = 20;
        pub const VT_CUSTOM_METADATA: flatbuffers::VOffsetT = 22;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SubGraphMetadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SubGraphMetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<SubGraphMetadata<'bldr>> {
            let mut builder = SubGraphMetadataBuilder::new(_fbb);
            if let Some(x) = args.custom_metadata {
                builder.add_custom_metadata(x);
            }
            if let Some(x) = args.output_tensor_groups {
                builder.add_output_tensor_groups(x);
            }
            if let Some(x) = args.input_tensor_groups {
                builder.add_input_tensor_groups(x);
            }
            if let Some(x) = args.output_process_units {
                builder.add_output_process_units(x);
            }
            if let Some(x) = args.input_process_units {
                builder.add_input_process_units(x);
            }
            if let Some(x) = args.associated_files {
                builder.add_associated_files(x);
            }
            if let Some(x) = args.output_tensor_metadata {
                builder.add_output_tensor_metadata(x);
            }
            if let Some(x) = args.input_tensor_metadata {
                builder.add_input_tensor_metadata(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(SubGraphMetadata::VT_NAME, None)
            }
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    SubGraphMetadata::VT_DESCRIPTION,
                    None,
                )
            }
        }
        #[inline]
        pub fn input_tensor_metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata>>,
                >>(SubGraphMetadata::VT_INPUT_TENSOR_METADATA, None)
            }
        }
        #[inline]
        pub fn output_tensor_metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata>>,
                >>(SubGraphMetadata::VT_OUTPUT_TENSOR_METADATA, None)
            }
        }
        #[inline]
        pub fn associated_files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(SubGraphMetadata::VT_ASSOCIATED_FILES, None)
            }
        }
        #[inline]
        pub fn input_process_units(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>(SubGraphMetadata::VT_INPUT_PROCESS_UNITS, None)
            }
        }
        #[inline]
        pub fn output_process_units(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>(SubGraphMetadata::VT_OUTPUT_PROCESS_UNITS, None)
            }
        }
        #[inline]
        pub fn input_tensor_groups(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup>>,
                >>(SubGraphMetadata::VT_INPUT_TENSOR_GROUPS, None)
            }
        }
        #[inline]
        pub fn output_tensor_groups(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup>>,
                >>(SubGraphMetadata::VT_OUTPUT_TENSOR_GROUPS, None)
            }
        }
        #[inline]
        pub fn custom_metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomMetadata<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomMetadata>>,
                >>(SubGraphMetadata::VT_CUSTOM_METADATA, None)
            }
        }
    }

    impl flatbuffers::Verifiable for SubGraphMetadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "description",
                    Self::VT_DESCRIPTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMetadata>>,
                >>(
                    "input_tensor_metadata",
                    Self::VT_INPUT_TENSOR_METADATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorMetadata>>,
                >>(
                    "output_tensor_metadata",
                    Self::VT_OUTPUT_TENSOR_METADATA,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("associated_files", Self::VT_ASSOCIATED_FILES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>("input_process_units", Self::VT_INPUT_PROCESS_UNITS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProcessUnit>>,
                >>("output_process_units", Self::VT_OUTPUT_PROCESS_UNITS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorGroup>>,
                >>("input_tensor_groups", Self::VT_INPUT_TENSOR_GROUPS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TensorGroup>>,
                >>("output_tensor_groups", Self::VT_OUTPUT_TENSOR_GROUPS, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CustomMetadata>>,
                >>("custom_metadata", Self::VT_CUSTOM_METADATA, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SubGraphMetadataArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub input_tensor_metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata<'a>>>,
            >,
        >,
        pub output_tensor_metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorMetadata<'a>>>,
            >,
        >,
        pub associated_files: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
        pub input_process_units: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>,
            >,
        >,
        pub output_process_units: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProcessUnit<'a>>>,
            >,
        >,
        pub input_tensor_groups: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup<'a>>>,
            >,
        >,
        pub output_tensor_groups: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TensorGroup<'a>>>,
            >,
        >,
        pub custom_metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomMetadata<'a>>>,
            >,
        >,
    }
    impl<'a> Default for SubGraphMetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            SubGraphMetadataArgs {
                name: None,
                description: None,
                input_tensor_metadata: None,
                output_tensor_metadata: None,
                associated_files: None,
                input_process_units: None,
                output_process_units: None,
                input_tensor_groups: None,
                output_tensor_groups: None,
                custom_metadata: None,
            }
        }
    }

    pub struct SubGraphMetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SubGraphMetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraphMetadata::VT_NAME, name);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_DESCRIPTION,
                description,
            );
        }
        #[inline]
        pub fn add_input_tensor_metadata(
            &mut self,
            input_tensor_metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorMetadata<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_INPUT_TENSOR_METADATA,
                input_tensor_metadata,
            );
        }
        #[inline]
        pub fn add_output_tensor_metadata(
            &mut self,
            output_tensor_metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorMetadata<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_OUTPUT_TENSOR_METADATA,
                output_tensor_metadata,
            );
        }
        #[inline]
        pub fn add_associated_files(
            &mut self,
            associated_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_ASSOCIATED_FILES,
                associated_files,
            );
        }
        #[inline]
        pub fn add_input_process_units(
            &mut self,
            input_process_units: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ProcessUnit<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_INPUT_PROCESS_UNITS,
                input_process_units,
            );
        }
        #[inline]
        pub fn add_output_process_units(
            &mut self,
            output_process_units: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ProcessUnit<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_OUTPUT_PROCESS_UNITS,
                output_process_units,
            );
        }
        #[inline]
        pub fn add_input_tensor_groups(
            &mut self,
            input_tensor_groups: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorGroup<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_INPUT_TENSOR_GROUPS,
                input_tensor_groups,
            );
        }
        #[inline]
        pub fn add_output_tensor_groups(
            &mut self,
            output_tensor_groups: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TensorGroup<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_OUTPUT_TENSOR_GROUPS,
                output_tensor_groups,
            );
        }
        #[inline]
        pub fn add_custom_metadata(
            &mut self,
            custom_metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CustomMetadata<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SubGraphMetadata::VT_CUSTOM_METADATA,
                custom_metadata,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SubGraphMetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SubGraphMetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SubGraphMetadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SubGraphMetadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SubGraphMetadata");
            ds.field("name", &self.name());
            ds.field("description", &self.description());
            ds.field("input_tensor_metadata", &self.input_tensor_metadata());
            ds.field("output_tensor_metadata", &self.output_tensor_metadata());
            ds.field("associated_files", &self.associated_files());
            ds.field("input_process_units", &self.input_process_units());
            ds.field("output_process_units", &self.output_process_units());
            ds.field("input_tensor_groups", &self.input_tensor_groups());
            ds.field("output_tensor_groups", &self.output_tensor_groups());
            ds.field("custom_metadata", &self.custom_metadata());
            ds.finish()
        }
    }
    pub enum ModelMetadataOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct ModelMetadata<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for ModelMetadata<'a> {
        type Inner = ModelMetadata<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> ModelMetadata<'a> {
        pub const VT_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
        pub const VT_VERSION: flatbuffers::VOffsetT = 8;
        pub const VT_SUBGRAPH_METADATA: flatbuffers::VOffsetT = 10;
        pub const VT_AUTHOR: flatbuffers::VOffsetT = 12;
        pub const VT_LICENSE: flatbuffers::VOffsetT = 14;
        pub const VT_ASSOCIATED_FILES: flatbuffers::VOffsetT = 16;
        pub const VT_MIN_PARSER_VERSION: flatbuffers::VOffsetT = 18;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            ModelMetadata { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ModelMetadataArgs<'args>,
        ) -> flatbuffers::WIPOffset<ModelMetadata<'bldr>> {
            let mut builder = ModelMetadataBuilder::new(_fbb);
            if let Some(x) = args.min_parser_version {
                builder.add_min_parser_version(x);
            }
            if let Some(x) = args.associated_files {
                builder.add_associated_files(x);
            }
            if let Some(x) = args.license {
                builder.add_license(x);
            }
            if let Some(x) = args.author {
                builder.add_author(x);
            }
            if let Some(x) = args.subgraph_metadata {
                builder.add_subgraph_metadata(x);
            }
            if let Some(x) = args.version {
                builder.add_version(x);
            }
            if let Some(x) = args.description {
                builder.add_description(x);
            }
            if let Some(x) = args.name {
                builder.add_name(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn name(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ModelMetadata::VT_NAME, None)
            }
        }
        #[inline]
        pub fn description(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ModelMetadata::VT_DESCRIPTION, None)
            }
        }
        #[inline]
        pub fn version(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ModelMetadata::VT_VERSION, None)
            }
        }
        #[inline]
        pub fn subgraph_metadata(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraphMetadata<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraphMetadata>>,
                >>(ModelMetadata::VT_SUBGRAPH_METADATA, None)
            }
        }
        #[inline]
        pub fn author(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ModelMetadata::VT_AUTHOR, None)
            }
        }
        #[inline]
        pub fn license(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<&str>>(ModelMetadata::VT_LICENSE, None)
            }
        }
        #[inline]
        pub fn associated_files(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>>
        {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>(ModelMetadata::VT_ASSOCIATED_FILES, None)
            }
        }
        #[inline]
        pub fn min_parser_version(&self) -> Option<&'a str> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                    ModelMetadata::VT_MIN_PARSER_VERSION,
                    None,
                )
            }
        }
    }

    impl flatbuffers::Verifiable for ModelMetadata<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "description",
                    Self::VT_DESCRIPTION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "version",
                    Self::VT_VERSION,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SubGraphMetadata>>,
                >>("subgraph_metadata", Self::VT_SUBGRAPH_METADATA, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "author",
                    Self::VT_AUTHOR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "license",
                    Self::VT_LICENSE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AssociatedFile>>,
                >>("associated_files", Self::VT_ASSOCIATED_FILES, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                    "min_parser_version",
                    Self::VT_MIN_PARSER_VERSION,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ModelMetadataArgs<'a> {
        pub name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub description: Option<flatbuffers::WIPOffset<&'a str>>,
        pub version: Option<flatbuffers::WIPOffset<&'a str>>,
        pub subgraph_metadata: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraphMetadata<'a>>>,
            >,
        >,
        pub author: Option<flatbuffers::WIPOffset<&'a str>>,
        pub license: Option<flatbuffers::WIPOffset<&'a str>>,
        pub associated_files: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AssociatedFile<'a>>>,
            >,
        >,
        pub min_parser_version: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ModelMetadataArgs<'a> {
        #[inline]
        fn default() -> Self {
            ModelMetadataArgs {
                name: None,
                description: None,
                version: None,
                subgraph_metadata: None,
                author: None,
                license: None,
                associated_files: None,
                min_parser_version: None,
            }
        }
    }

    pub struct ModelMetadataBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ModelMetadataBuilder<'a, 'b> {
        #[inline]
        pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ModelMetadata::VT_NAME, name);
        }
        #[inline]
        pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ModelMetadata::VT_DESCRIPTION,
                description,
            );
        }
        #[inline]
        pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ModelMetadata::VT_VERSION, version);
        }
        #[inline]
        pub fn add_subgraph_metadata(
            &mut self,
            subgraph_metadata: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SubGraphMetadata<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ModelMetadata::VT_SUBGRAPH_METADATA,
                subgraph_metadata,
            );
        }
        #[inline]
        pub fn add_author(&mut self, author: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ModelMetadata::VT_AUTHOR, author);
        }
        #[inline]
        pub fn add_license(&mut self, license: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(ModelMetadata::VT_LICENSE, license);
        }
        #[inline]
        pub fn add_associated_files(
            &mut self,
            associated_files: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AssociatedFile<'b>>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ModelMetadata::VT_ASSOCIATED_FILES,
                associated_files,
            );
        }
        #[inline]
        pub fn add_min_parser_version(
            &mut self,
            min_parser_version: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                ModelMetadata::VT_MIN_PARSER_VERSION,
                min_parser_version,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> ModelMetadataBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ModelMetadataBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<ModelMetadata<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for ModelMetadata<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("ModelMetadata");
            ds.field("name", &self.name());
            ds.field("description", &self.description());
            ds.field("version", &self.version());
            ds.field("subgraph_metadata", &self.subgraph_metadata());
            ds.field("author", &self.author());
            ds.field("license", &self.license());
            ds.field("associated_files", &self.associated_files());
            ds.field("min_parser_version", &self.min_parser_version());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `ModelMetadata`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_metadata_unchecked`.
    pub fn root_as_model_metadata(
        buf: &[u8],
    ) -> Result<ModelMetadata, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<ModelMetadata>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `ModelMetadata` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_model_metadata_unchecked`.
    pub fn size_prefixed_root_as_model_metadata(
        buf: &[u8],
    ) -> Result<ModelMetadata, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<ModelMetadata>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `ModelMetadata` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_metadata_unchecked`.
    pub fn root_as_model_metadata_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<ModelMetadata<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<ModelMetadata<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `ModelMetadata` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_model_metadata_unchecked`.
    pub fn size_prefixed_root_as_model_metadata_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<ModelMetadata<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<ModelMetadata<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a ModelMetadata and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `ModelMetadata`.
    pub unsafe fn root_as_model_metadata_unchecked(buf: &[u8]) -> ModelMetadata {
        flatbuffers::root_unchecked::<ModelMetadata>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed ModelMetadata and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `ModelMetadata`.
    pub unsafe fn size_prefixed_root_as_model_metadata_unchecked(buf: &[u8]) -> ModelMetadata {
        flatbuffers::size_prefixed_root_unchecked::<ModelMetadata>(buf)
    }
    pub const MODEL_METADATA_IDENTIFIER: &str = "M001";

    #[inline]
    pub fn model_metadata_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, MODEL_METADATA_IDENTIFIER, false)
    }

    #[inline]
    pub fn model_metadata_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
        flatbuffers::buffer_has_identifier(buf, MODEL_METADATA_IDENTIFIER, true)
    }

    pub const MODEL_METADATA_EXTENSION: &str = "tflitemeta";

    #[inline]
    pub fn finish_model_metadata_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<ModelMetadata<'a>>,
    ) {
        fbb.finish(root, Some(MODEL_METADATA_IDENTIFIER));
    }

    #[inline]
    pub fn finish_size_prefixed_model_metadata_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<ModelMetadata<'a>>,
    ) {
        fbb.finish_size_prefixed(root, Some(MODEL_METADATA_IDENTIFIER));
    }
} // pub mod tflite
